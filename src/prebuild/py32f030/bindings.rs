/* automatically generated by rust-bindgen 0.69.4 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const PRIORITY_HIGHEST: u32 = 0;
pub const PRIORITY_HIGH: u32 = 1;
pub const PRIORITY_LOW: u32 = 2;
pub const PRIORITY_LOWEST: u32 = 3;
pub const USE_RTOS: u32 = 0;
pub const PREFETCH_ENABLE: u32 = 0;
pub const __PY32F0_DEVICE_VERSION_MAIN: u32 = 1;
pub const __PY32F0_DEVICE_VERSION_SUB1: u32 = 0;
pub const __PY32F0_DEVICE_VERSION_SUB2: u32 = 0;
pub const __PY32F0_DEVICE_VERSION_RC: u32 = 0;
pub const __PY32F0_DEVICE_VERSION: u32 = 16777216;
pub const __CM0PLUS_REV: u32 = 0;
pub const __MPU_PRESENT: u32 = 0;
pub const __VTOR_PRESENT: u32 = 1;
pub const __NVIC_PRIO_BITS: u32 = 2;
pub const __Vendor_SysTickConfig: u32 = 0;
pub const __CM0PLUS_CMSIS_VERSION_MAIN: u32 = 4;
pub const __CM0PLUS_CMSIS_VERSION_SUB: u32 = 30;
pub const __CM0PLUS_CMSIS_VERSION: u32 = 262174;
pub const __CORTEX_M: u32 = 0;
pub const __FPU_USED: u32 = 0;
pub const APSR_N_Pos: u32 = 31;
pub const APSR_N_Msk: u32 = 2147483648;
pub const APSR_Z_Pos: u32 = 30;
pub const APSR_Z_Msk: u32 = 1073741824;
pub const APSR_C_Pos: u32 = 29;
pub const APSR_C_Msk: u32 = 536870912;
pub const APSR_V_Pos: u32 = 28;
pub const APSR_V_Msk: u32 = 268435456;
pub const IPSR_ISR_Pos: u32 = 0;
pub const IPSR_ISR_Msk: u32 = 511;
pub const xPSR_N_Pos: u32 = 31;
pub const xPSR_N_Msk: u32 = 2147483648;
pub const xPSR_Z_Pos: u32 = 30;
pub const xPSR_Z_Msk: u32 = 1073741824;
pub const xPSR_C_Pos: u32 = 29;
pub const xPSR_C_Msk: u32 = 536870912;
pub const xPSR_V_Pos: u32 = 28;
pub const xPSR_V_Msk: u32 = 268435456;
pub const xPSR_T_Pos: u32 = 24;
pub const xPSR_T_Msk: u32 = 16777216;
pub const xPSR_ISR_Pos: u32 = 0;
pub const xPSR_ISR_Msk: u32 = 511;
pub const CONTROL_SPSEL_Pos: u32 = 1;
pub const CONTROL_SPSEL_Msk: u32 = 2;
pub const CONTROL_nPRIV_Pos: u32 = 0;
pub const CONTROL_nPRIV_Msk: u32 = 1;
pub const SCB_CPUID_IMPLEMENTER_Pos: u32 = 24;
pub const SCB_CPUID_IMPLEMENTER_Msk: u32 = 4278190080;
pub const SCB_CPUID_VARIANT_Pos: u32 = 20;
pub const SCB_CPUID_VARIANT_Msk: u32 = 15728640;
pub const SCB_CPUID_ARCHITECTURE_Pos: u32 = 16;
pub const SCB_CPUID_ARCHITECTURE_Msk: u32 = 983040;
pub const SCB_CPUID_PARTNO_Pos: u32 = 4;
pub const SCB_CPUID_PARTNO_Msk: u32 = 65520;
pub const SCB_CPUID_REVISION_Pos: u32 = 0;
pub const SCB_CPUID_REVISION_Msk: u32 = 15;
pub const SCB_ICSR_NMIPENDSET_Pos: u32 = 31;
pub const SCB_ICSR_NMIPENDSET_Msk: u32 = 2147483648;
pub const SCB_ICSR_PENDSVSET_Pos: u32 = 28;
pub const SCB_ICSR_PENDSVSET_Msk: u32 = 268435456;
pub const SCB_ICSR_PENDSVCLR_Pos: u32 = 27;
pub const SCB_ICSR_PENDSVCLR_Msk: u32 = 134217728;
pub const SCB_ICSR_PENDSTSET_Pos: u32 = 26;
pub const SCB_ICSR_PENDSTSET_Msk: u32 = 67108864;
pub const SCB_ICSR_PENDSTCLR_Pos: u32 = 25;
pub const SCB_ICSR_PENDSTCLR_Msk: u32 = 33554432;
pub const SCB_ICSR_ISRPREEMPT_Pos: u32 = 23;
pub const SCB_ICSR_ISRPREEMPT_Msk: u32 = 8388608;
pub const SCB_ICSR_ISRPENDING_Pos: u32 = 22;
pub const SCB_ICSR_ISRPENDING_Msk: u32 = 4194304;
pub const SCB_ICSR_VECTPENDING_Pos: u32 = 12;
pub const SCB_ICSR_VECTPENDING_Msk: u32 = 2093056;
pub const SCB_ICSR_VECTACTIVE_Pos: u32 = 0;
pub const SCB_ICSR_VECTACTIVE_Msk: u32 = 511;
pub const SCB_VTOR_TBLOFF_Pos: u32 = 8;
pub const SCB_VTOR_TBLOFF_Msk: u32 = 4294967040;
pub const SCB_AIRCR_VECTKEY_Pos: u32 = 16;
pub const SCB_AIRCR_VECTKEY_Msk: u32 = 4294901760;
pub const SCB_AIRCR_VECTKEYSTAT_Pos: u32 = 16;
pub const SCB_AIRCR_VECTKEYSTAT_Msk: u32 = 4294901760;
pub const SCB_AIRCR_ENDIANESS_Pos: u32 = 15;
pub const SCB_AIRCR_ENDIANESS_Msk: u32 = 32768;
pub const SCB_AIRCR_SYSRESETREQ_Pos: u32 = 2;
pub const SCB_AIRCR_SYSRESETREQ_Msk: u32 = 4;
pub const SCB_AIRCR_VECTCLRACTIVE_Pos: u32 = 1;
pub const SCB_AIRCR_VECTCLRACTIVE_Msk: u32 = 2;
pub const SCB_SCR_SEVONPEND_Pos: u32 = 4;
pub const SCB_SCR_SEVONPEND_Msk: u32 = 16;
pub const SCB_SCR_SLEEPDEEP_Pos: u32 = 2;
pub const SCB_SCR_SLEEPDEEP_Msk: u32 = 4;
pub const SCB_SCR_SLEEPONEXIT_Pos: u32 = 1;
pub const SCB_SCR_SLEEPONEXIT_Msk: u32 = 2;
pub const SCB_CCR_STKALIGN_Pos: u32 = 9;
pub const SCB_CCR_STKALIGN_Msk: u32 = 512;
pub const SCB_CCR_UNALIGN_TRP_Pos: u32 = 3;
pub const SCB_CCR_UNALIGN_TRP_Msk: u32 = 8;
pub const SCB_SHCSR_SVCALLPENDED_Pos: u32 = 15;
pub const SCB_SHCSR_SVCALLPENDED_Msk: u32 = 32768;
pub const SysTick_CTRL_COUNTFLAG_Pos: u32 = 16;
pub const SysTick_CTRL_COUNTFLAG_Msk: u32 = 65536;
pub const SysTick_CTRL_CLKSOURCE_Pos: u32 = 2;
pub const SysTick_CTRL_CLKSOURCE_Msk: u32 = 4;
pub const SysTick_CTRL_TICKINT_Pos: u32 = 1;
pub const SysTick_CTRL_TICKINT_Msk: u32 = 2;
pub const SysTick_CTRL_ENABLE_Pos: u32 = 0;
pub const SysTick_CTRL_ENABLE_Msk: u32 = 1;
pub const SysTick_LOAD_RELOAD_Pos: u32 = 0;
pub const SysTick_LOAD_RELOAD_Msk: u32 = 16777215;
pub const SysTick_VAL_CURRENT_Pos: u32 = 0;
pub const SysTick_VAL_CURRENT_Msk: u32 = 16777215;
pub const SysTick_CALIB_NOREF_Pos: u32 = 31;
pub const SysTick_CALIB_NOREF_Msk: u32 = 2147483648;
pub const SysTick_CALIB_SKEW_Pos: u32 = 30;
pub const SysTick_CALIB_SKEW_Msk: u32 = 1073741824;
pub const SysTick_CALIB_TENMS_Pos: u32 = 0;
pub const SysTick_CALIB_TENMS_Msk: u32 = 16777215;
pub const SCS_BASE: u32 = 3758153728;
pub const SysTick_BASE: u32 = 3758153744;
pub const NVIC_BASE: u32 = 3758153984;
pub const SCB_BASE: u32 = 3758157056;
pub const FLASH_BASE: u32 = 134217728;
pub const FLASH_END: u32 = 134250495;
pub const FLASH_SIZE: u32 = 32768;
pub const FLASH_PAGE_SIZE: u32 = 128;
pub const FLASH_PAGE_NB: u32 = 256;
pub const FLASH_SECTOR_SIZE: u32 = 4096;
pub const FLASH_SECTOR_NB: u32 = 8;
pub const SRAM_BASE: u32 = 536870912;
pub const SRAM_END: u32 = 536875007;
pub const PERIPH_BASE: u32 = 1073741824;
pub const IOPORT_BASE: u32 = 1342177280;
pub const APBPERIPH_BASE: u32 = 1073741824;
pub const AHBPERIPH_BASE: u32 = 1073872896;
pub const TIM3_BASE: u32 = 1073742848;
pub const TIM14_BASE: u32 = 1073750016;
pub const LED_BASE: u32 = 1073751040;
pub const RTC_BASE: u32 = 1073752064;
pub const WWDG_BASE: u32 = 1073753088;
pub const IWDG_BASE: u32 = 1073754112;
pub const SPI2_BASE: u32 = 1073756160;
pub const USART2_BASE: u32 = 1073759232;
pub const I2C_BASE: u32 = 1073763328;
pub const PWR_BASE: u32 = 1073770496;
pub const LPTIM_BASE: u32 = 1073773568;
pub const SYSCFG_BASE: u32 = 1073807360;
pub const COMP1_BASE: u32 = 1073807872;
pub const COMP2_BASE: u32 = 1073807888;
pub const ADC1_BASE: u32 = 1073816576;
pub const ADC_BASE: u32 = 1073817352;
pub const TIM1_BASE: u32 = 1073818624;
pub const SPI1_BASE: u32 = 1073819648;
pub const USART1_BASE: u32 = 1073821696;
pub const TIM16_BASE: u32 = 1073824768;
pub const TIM17_BASE: u32 = 1073825792;
pub const DBGMCU_BASE: u32 = 1073829888;
pub const DMA1_BASE: u32 = 1073872896;
pub const DMA1_Channel1_BASE: u32 = 1073872904;
pub const DMA1_Channel2_BASE: u32 = 1073872924;
pub const DMA1_Channel3_BASE: u32 = 1073872944;
pub const RCC_BASE: u32 = 1073876992;
pub const EXTI_BASE: u32 = 1073879040;
pub const FLASH_R_BASE: u32 = 1073881088;
pub const OB_BASE: u32 = 536809088;
pub const FLASHSIZE_BASE: u32 = 536809468;
pub const UID_BASE: u32 = 536808960;
pub const CRC_BASE: u32 = 1073885184;
pub const GPIOA_BASE: u32 = 1342177280;
pub const GPIOB_BASE: u32 = 1342178304;
pub const GPIOF_BASE: u32 = 1342182400;
pub const ADC_ISR_EOSMP_Pos: u32 = 1;
pub const ADC_ISR_EOSMP_Msk: u32 = 2;
pub const ADC_ISR_EOSMP: u32 = 2;
pub const ADC_ISR_EOC_Pos: u32 = 2;
pub const ADC_ISR_EOC_Msk: u32 = 4;
pub const ADC_ISR_EOC: u32 = 4;
pub const ADC_ISR_EOSEQ_Pos: u32 = 3;
pub const ADC_ISR_EOSEQ_Msk: u32 = 8;
pub const ADC_ISR_EOSEQ: u32 = 8;
pub const ADC_ISR_OVR_Pos: u32 = 4;
pub const ADC_ISR_OVR_Msk: u32 = 16;
pub const ADC_ISR_OVR: u32 = 16;
pub const ADC_ISR_AWD_Pos: u32 = 7;
pub const ADC_ISR_AWD_Msk: u32 = 128;
pub const ADC_ISR_AWD: u32 = 128;
pub const ADC_IER_EOSMPIE_Pos: u32 = 1;
pub const ADC_IER_EOSMPIE_Msk: u32 = 2;
pub const ADC_IER_EOSMPIE: u32 = 2;
pub const ADC_IER_EOCIE_Pos: u32 = 2;
pub const ADC_IER_EOCIE_Msk: u32 = 4;
pub const ADC_IER_EOCIE: u32 = 4;
pub const ADC_IER_EOSEQIE_Pos: u32 = 3;
pub const ADC_IER_EOSEQIE_Msk: u32 = 8;
pub const ADC_IER_EOSEQIE: u32 = 8;
pub const ADC_IER_OVRIE_Pos: u32 = 4;
pub const ADC_IER_OVRIE_Msk: u32 = 16;
pub const ADC_IER_OVRIE: u32 = 16;
pub const ADC_IER_AWDIE_Pos: u32 = 7;
pub const ADC_IER_AWDIE_Msk: u32 = 128;
pub const ADC_IER_AWDIE: u32 = 128;
pub const ADC_CR_ADEN_Pos: u32 = 0;
pub const ADC_CR_ADEN_Msk: u32 = 1;
pub const ADC_CR_ADEN: u32 = 1;
pub const ADC_CR_ADSTART_Pos: u32 = 2;
pub const ADC_CR_ADSTART_Msk: u32 = 4;
pub const ADC_CR_ADSTART: u32 = 4;
pub const ADC_CR_ADSTP_Pos: u32 = 4;
pub const ADC_CR_ADSTP_Msk: u32 = 16;
pub const ADC_CR_ADSTP: u32 = 16;
pub const ADC_CR_ADCAL_Pos: u32 = 31;
pub const ADC_CR_ADCAL_Msk: u32 = 2147483648;
pub const ADC_CR_ADCAL: u32 = 2147483648;
pub const ADC_CFGR1_DMAEN_Pos: u32 = 0;
pub const ADC_CFGR1_DMAEN_Msk: u32 = 1;
pub const ADC_CFGR1_DMAEN: u32 = 1;
pub const ADC_CFGR1_DMACFG_Pos: u32 = 1;
pub const ADC_CFGR1_DMACFG_Msk: u32 = 2;
pub const ADC_CFGR1_DMACFG: u32 = 2;
pub const ADC_CFGR1_SCANDIR_Pos: u32 = 2;
pub const ADC_CFGR1_SCANDIR_Msk: u32 = 4;
pub const ADC_CFGR1_SCANDIR: u32 = 4;
pub const ADC_CFGR1_RESSEL_Pos: u32 = 3;
pub const ADC_CFGR1_RESSEL_Msk: u32 = 24;
pub const ADC_CFGR1_RESSEL: u32 = 24;
pub const ADC_CFGR1_RESSEL_0: u32 = 8;
pub const ADC_CFGR1_RESSEL_1: u32 = 16;
pub const ADC_CFGR1_ALIGN_Pos: u32 = 5;
pub const ADC_CFGR1_ALIGN_Msk: u32 = 32;
pub const ADC_CFGR1_ALIGN: u32 = 32;
pub const ADC_CFGR1_EXTSEL_Pos: u32 = 6;
pub const ADC_CFGR1_EXTSEL_Msk: u32 = 448;
pub const ADC_CFGR1_EXTSEL: u32 = 448;
pub const ADC_CFGR1_EXTSEL_0: u32 = 64;
pub const ADC_CFGR1_EXTSEL_1: u32 = 128;
pub const ADC_CFGR1_EXTSEL_2: u32 = 256;
pub const ADC_CFGR1_EXTEN_Pos: u32 = 10;
pub const ADC_CFGR1_EXTEN_Msk: u32 = 3072;
pub const ADC_CFGR1_EXTEN: u32 = 3072;
pub const ADC_CFGR1_EXTEN_0: u32 = 1024;
pub const ADC_CFGR1_EXTEN_1: u32 = 2048;
pub const ADC_CFGR1_OVRMOD_Pos: u32 = 12;
pub const ADC_CFGR1_OVRMOD_Msk: u32 = 4096;
pub const ADC_CFGR1_OVRMOD: u32 = 4096;
pub const ADC_CFGR1_CONT_Pos: u32 = 13;
pub const ADC_CFGR1_CONT_Msk: u32 = 8192;
pub const ADC_CFGR1_CONT: u32 = 8192;
pub const ADC_CFGR1_WAIT_Pos: u32 = 14;
pub const ADC_CFGR1_WAIT_Msk: u32 = 16384;
pub const ADC_CFGR1_WAIT: u32 = 16384;
pub const ADC_CFGR1_DISCEN_Pos: u32 = 16;
pub const ADC_CFGR1_DISCEN_Msk: u32 = 65536;
pub const ADC_CFGR1_DISCEN: u32 = 65536;
pub const ADC_CFGR1_AWDSGL_Pos: u32 = 22;
pub const ADC_CFGR1_AWDSGL_Msk: u32 = 4194304;
pub const ADC_CFGR1_AWDSGL: u32 = 4194304;
pub const ADC_CFGR1_AWDEN_Pos: u32 = 23;
pub const ADC_CFGR1_AWDEN_Msk: u32 = 8388608;
pub const ADC_CFGR1_AWDEN: u32 = 8388608;
pub const ADC_CFGR1_AWDCH_Pos: u32 = 26;
pub const ADC_CFGR1_AWDCH_Msk: u32 = 1006632960;
pub const ADC_CFGR1_AWDCH: u32 = 1006632960;
pub const ADC_CFGR1_AWDCH_0: u32 = 67108864;
pub const ADC_CFGR1_AWDCH_1: u32 = 134217728;
pub const ADC_CFGR1_AWDCH_2: u32 = 268435456;
pub const ADC_CFGR1_AWDCH_3: u32 = 536870912;
pub const ADC_CFGR2_CKMODE_Pos: u32 = 28;
pub const ADC_CFGR2_CKMODE_Msk: u32 = 4026531840;
pub const ADC_CFGR2_CKMODE: u32 = 4026531840;
pub const ADC_CFGR2_CKMODE_0: u32 = 268435456;
pub const ADC_CFGR2_CKMODE_1: u32 = 536870912;
pub const ADC_CFGR2_CKMODE_2: u32 = 1073741824;
pub const ADC_CFGR2_CKMODE_3: u32 = 2147483648;
pub const ADC_SMPR_SMP_Pos: u32 = 0;
pub const ADC_SMPR_SMP_Msk: u32 = 7;
pub const ADC_SMPR_SMP: u32 = 7;
pub const ADC_SMPR_SMP_0: u32 = 1;
pub const ADC_SMPR_SMP_1: u32 = 2;
pub const ADC_SMPR_SMP_2: u32 = 4;
pub const ADC_TR_LT_Pos: u32 = 0;
pub const ADC_TR_LT_Msk: u32 = 4095;
pub const ADC_TR_LT: u32 = 4095;
pub const ADC_TR_LT_0: u32 = 1;
pub const ADC_TR_LT_1: u32 = 2;
pub const ADC_TR_LT_2: u32 = 4;
pub const ADC_TR_LT_3: u32 = 8;
pub const ADC_TR_LT_4: u32 = 16;
pub const ADC_TR_LT_5: u32 = 32;
pub const ADC_TR_LT_6: u32 = 64;
pub const ADC_TR_LT_7: u32 = 128;
pub const ADC_TR_LT_8: u32 = 256;
pub const ADC_TR_LT_9: u32 = 512;
pub const ADC_TR_LT_10: u32 = 1024;
pub const ADC_TR_LT_11: u32 = 2048;
pub const ADC_TR_HT_Pos: u32 = 16;
pub const ADC_TR_HT_Msk: u32 = 268369920;
pub const ADC_TR_HT: u32 = 268369920;
pub const ADC_TR_HT_0: u32 = 65536;
pub const ADC_TR_HT_1: u32 = 131072;
pub const ADC_TR_HT_2: u32 = 262144;
pub const ADC_TR_HT_3: u32 = 524288;
pub const ADC_TR_HT_4: u32 = 1048576;
pub const ADC_TR_HT_5: u32 = 2097152;
pub const ADC_TR_HT_6: u32 = 4194304;
pub const ADC_TR_HT_7: u32 = 8388608;
pub const ADC_TR_HT_8: u32 = 16777216;
pub const ADC_TR_HT_9: u32 = 33554432;
pub const ADC_TR_HT_10: u32 = 67108864;
pub const ADC_TR_HT_11: u32 = 134217728;
pub const ADC_CHSELR_CHSEL_Pos: u32 = 0;
pub const ADC_CHSELR_CHSEL_Msk: u32 = 7167;
pub const ADC_CHSELR_CHSEL: u32 = 7167;
pub const ADC_CHSELR_CHSEL12_Pos: u32 = 12;
pub const ADC_CHSELR_CHSEL12_Msk: u32 = 4096;
pub const ADC_CHSELR_CHSEL12: u32 = 4096;
pub const ADC_CHSELR_CHSEL11_Pos: u32 = 11;
pub const ADC_CHSELR_CHSEL11_Msk: u32 = 2048;
pub const ADC_CHSELR_CHSEL11: u32 = 2048;
pub const ADC_CHSELR_CHSEL9_Pos: u32 = 9;
pub const ADC_CHSELR_CHSEL9_Msk: u32 = 512;
pub const ADC_CHSELR_CHSEL9: u32 = 512;
pub const ADC_CHSELR_CHSEL8_Pos: u32 = 8;
pub const ADC_CHSELR_CHSEL8_Msk: u32 = 256;
pub const ADC_CHSELR_CHSEL8: u32 = 256;
pub const ADC_CHSELR_CHSEL7_Pos: u32 = 7;
pub const ADC_CHSELR_CHSEL7_Msk: u32 = 128;
pub const ADC_CHSELR_CHSEL7: u32 = 128;
pub const ADC_CHSELR_CHSEL6_Pos: u32 = 6;
pub const ADC_CHSELR_CHSEL6_Msk: u32 = 64;
pub const ADC_CHSELR_CHSEL6: u32 = 64;
pub const ADC_CHSELR_CHSEL5_Pos: u32 = 5;
pub const ADC_CHSELR_CHSEL5_Msk: u32 = 32;
pub const ADC_CHSELR_CHSEL5: u32 = 32;
pub const ADC_CHSELR_CHSEL4_Pos: u32 = 4;
pub const ADC_CHSELR_CHSEL4_Msk: u32 = 16;
pub const ADC_CHSELR_CHSEL4: u32 = 16;
pub const ADC_CHSELR_CHSEL3_Pos: u32 = 3;
pub const ADC_CHSELR_CHSEL3_Msk: u32 = 8;
pub const ADC_CHSELR_CHSEL3: u32 = 8;
pub const ADC_CHSELR_CHSEL2_Pos: u32 = 2;
pub const ADC_CHSELR_CHSEL2_Msk: u32 = 4;
pub const ADC_CHSELR_CHSEL2: u32 = 4;
pub const ADC_CHSELR_CHSEL1_Pos: u32 = 1;
pub const ADC_CHSELR_CHSEL1_Msk: u32 = 2;
pub const ADC_CHSELR_CHSEL1: u32 = 2;
pub const ADC_CHSELR_CHSEL0_Pos: u32 = 0;
pub const ADC_CHSELR_CHSEL0_Msk: u32 = 1;
pub const ADC_CHSELR_CHSEL0: u32 = 1;
pub const ADC_DR_DATA_Pos: u32 = 0;
pub const ADC_DR_DATA_Msk: u32 = 65535;
pub const ADC_DR_DATA: u32 = 65535;
pub const ADC_DR_DATA_0: u32 = 1;
pub const ADC_DR_DATA_1: u32 = 2;
pub const ADC_DR_DATA_2: u32 = 4;
pub const ADC_DR_DATA_3: u32 = 8;
pub const ADC_DR_DATA_4: u32 = 16;
pub const ADC_DR_DATA_5: u32 = 32;
pub const ADC_DR_DATA_6: u32 = 64;
pub const ADC_DR_DATA_7: u32 = 128;
pub const ADC_DR_DATA_8: u32 = 256;
pub const ADC_DR_DATA_9: u32 = 512;
pub const ADC_DR_DATA_10: u32 = 1024;
pub const ADC_DR_DATA_11: u32 = 2048;
pub const ADC_DR_DATA_12: u32 = 4096;
pub const ADC_DR_DATA_13: u32 = 8192;
pub const ADC_DR_DATA_14: u32 = 16384;
pub const ADC_DR_DATA_15: u32 = 32768;
pub const ADC_CCSR_CALSEL_Pos: u32 = 11;
pub const ADC_CCSR_CALSEL_Msk: u32 = 2048;
pub const ADC_CCSR_CALSEL: u32 = 2048;
pub const ADC_CCSR_CALSMP_Pos: u32 = 12;
pub const ADC_CCSR_CALSMP_Msk: u32 = 12288;
pub const ADC_CCSR_CALSMP: u32 = 12288;
pub const ADC_CCSR_CALSMP_0: u32 = 4096;
pub const ADC_CCSR_CALSMP_1: u32 = 8192;
pub const ADC_CCSR_CALFAIL_Pos: u32 = 30;
pub const ADC_CCSR_CALFAIL_Msk: u32 = 1073741824;
pub const ADC_CCSR_CALFAIL: u32 = 1073741824;
pub const ADC_CCSR_CALON_Pos: u32 = 31;
pub const ADC_CCSR_CALON_Msk: u32 = 2147483648;
pub const ADC_CCSR_CALON: u32 = 2147483648;
pub const ADC_CCR_VREFEN_Pos: u32 = 22;
pub const ADC_CCR_VREFEN_Msk: u32 = 4194304;
pub const ADC_CCR_VREFEN: u32 = 4194304;
pub const ADC_CCR_TSEN_Pos: u32 = 23;
pub const ADC_CCR_TSEN_Msk: u32 = 8388608;
pub const ADC_CCR_TSEN: u32 = 8388608;
pub const CRC_DR_DR_Pos: u32 = 0;
pub const CRC_DR_DR_Msk: u32 = 4294967295;
pub const CRC_DR_DR: u32 = 4294967295;
pub const CRC_IDR_IDR_Pos: u32 = 0;
pub const CRC_IDR_IDR_Msk: u32 = 255;
pub const CRC_IDR_IDR: u32 = 255;
pub const CRC_CR_RESET_Pos: u32 = 0;
pub const CRC_CR_RESET_Msk: u32 = 1;
pub const CRC_CR_RESET: u32 = 1;
pub const DBGMCU_IDCODE_DEV_ID_Pos: u32 = 0;
pub const DBGMCU_IDCODE_DEV_ID_Msk: u32 = 4095;
pub const DBGMCU_IDCODE_DEV_ID: u32 = 4095;
pub const DBGMCU_IDCODE_REV_ID_Pos: u32 = 16;
pub const DBGMCU_IDCODE_REV_ID_Msk: u32 = 4294901760;
pub const DBGMCU_IDCODE_REV_ID: u32 = 4294901760;
pub const DBGMCU_CR_DBG_STOP_Pos: u32 = 1;
pub const DBGMCU_CR_DBG_STOP_Msk: u32 = 2;
pub const DBGMCU_CR_DBG_STOP: u32 = 2;
pub const DBGMCU_APB_FZ1_DBG_TIM3_STOP_Pos: u32 = 1;
pub const DBGMCU_APB_FZ1_DBG_TIM3_STOP_Msk: u32 = 2;
pub const DBGMCU_APB_FZ1_DBG_TIM3_STOP: u32 = 2;
pub const DBGMCU_APB_FZ1_DBG_RTC_STOP_Pos: u32 = 10;
pub const DBGMCU_APB_FZ1_DBG_RTC_STOP_Msk: u32 = 1024;
pub const DBGMCU_APB_FZ1_DBG_RTC_STOP: u32 = 1024;
pub const DBGMCU_APB_FZ1_DBG_WWDG_STOP_Pos: u32 = 11;
pub const DBGMCU_APB_FZ1_DBG_WWDG_STOP_Msk: u32 = 2048;
pub const DBGMCU_APB_FZ1_DBG_WWDG_STOP: u32 = 2048;
pub const DBGMCU_APB_FZ1_DBG_IWDG_STOP_Pos: u32 = 12;
pub const DBGMCU_APB_FZ1_DBG_IWDG_STOP_Msk: u32 = 4096;
pub const DBGMCU_APB_FZ1_DBG_IWDG_STOP: u32 = 4096;
pub const DBGMCU_APB_FZ1_DBG_LPTIM_STOP_Pos: u32 = 31;
pub const DBGMCU_APB_FZ1_DBG_LPTIM_STOP_Msk: u32 = 2147483648;
pub const DBGMCU_APB_FZ1_DBG_LPTIM_STOP: u32 = 2147483648;
pub const DBGMCU_APB_FZ2_DBG_TIM1_STOP_Pos: u32 = 11;
pub const DBGMCU_APB_FZ2_DBG_TIM1_STOP_Msk: u32 = 2048;
pub const DBGMCU_APB_FZ2_DBG_TIM1_STOP: u32 = 2048;
pub const DBGMCU_APB_FZ2_DBG_TIM14_STOP_Pos: u32 = 15;
pub const DBGMCU_APB_FZ2_DBG_TIM14_STOP_Msk: u32 = 32768;
pub const DBGMCU_APB_FZ2_DBG_TIM14_STOP: u32 = 32768;
pub const DBGMCU_APB_FZ2_DBG_TIM16_STOP_Pos: u32 = 17;
pub const DBGMCU_APB_FZ2_DBG_TIM16_STOP_Msk: u32 = 131072;
pub const DBGMCU_APB_FZ2_DBG_TIM16_STOP: u32 = 131072;
pub const DBGMCU_APB_FZ2_DBG_TIM17_STOP_Pos: u32 = 18;
pub const DBGMCU_APB_FZ2_DBG_TIM17_STOP_Msk: u32 = 262144;
pub const DBGMCU_APB_FZ2_DBG_TIM17_STOP: u32 = 262144;
pub const DMA_ISR_GIF1_Pos: u32 = 0;
pub const DMA_ISR_GIF1_Msk: u32 = 1;
pub const DMA_ISR_GIF1: u32 = 1;
pub const DMA_ISR_TCIF1_Pos: u32 = 1;
pub const DMA_ISR_TCIF1_Msk: u32 = 2;
pub const DMA_ISR_TCIF1: u32 = 2;
pub const DMA_ISR_HTIF1_Pos: u32 = 2;
pub const DMA_ISR_HTIF1_Msk: u32 = 4;
pub const DMA_ISR_HTIF1: u32 = 4;
pub const DMA_ISR_TEIF1_Pos: u32 = 3;
pub const DMA_ISR_TEIF1_Msk: u32 = 8;
pub const DMA_ISR_TEIF1: u32 = 8;
pub const DMA_ISR_GIF2_Pos: u32 = 4;
pub const DMA_ISR_GIF2_Msk: u32 = 16;
pub const DMA_ISR_GIF2: u32 = 16;
pub const DMA_ISR_TCIF2_Pos: u32 = 5;
pub const DMA_ISR_TCIF2_Msk: u32 = 32;
pub const DMA_ISR_TCIF2: u32 = 32;
pub const DMA_ISR_HTIF2_Pos: u32 = 6;
pub const DMA_ISR_HTIF2_Msk: u32 = 64;
pub const DMA_ISR_HTIF2: u32 = 64;
pub const DMA_ISR_TEIF2_Pos: u32 = 7;
pub const DMA_ISR_TEIF2_Msk: u32 = 128;
pub const DMA_ISR_TEIF2: u32 = 128;
pub const DMA_ISR_GIF3_Pos: u32 = 8;
pub const DMA_ISR_GIF3_Msk: u32 = 256;
pub const DMA_ISR_GIF3: u32 = 256;
pub const DMA_ISR_TCIF3_Pos: u32 = 9;
pub const DMA_ISR_TCIF3_Msk: u32 = 512;
pub const DMA_ISR_TCIF3: u32 = 512;
pub const DMA_ISR_HTIF3_Pos: u32 = 10;
pub const DMA_ISR_HTIF3_Msk: u32 = 1024;
pub const DMA_ISR_HTIF3: u32 = 1024;
pub const DMA_ISR_TEIF3_Pos: u32 = 11;
pub const DMA_ISR_TEIF3_Msk: u32 = 2048;
pub const DMA_ISR_TEIF3: u32 = 2048;
pub const DMA_IFCR_CGIF1_Pos: u32 = 0;
pub const DMA_IFCR_CGIF1_Msk: u32 = 1;
pub const DMA_IFCR_CGIF1: u32 = 1;
pub const DMA_IFCR_CTCIF1_Pos: u32 = 1;
pub const DMA_IFCR_CTCIF1_Msk: u32 = 2;
pub const DMA_IFCR_CTCIF1: u32 = 2;
pub const DMA_IFCR_CHTIF1_Pos: u32 = 2;
pub const DMA_IFCR_CHTIF1_Msk: u32 = 4;
pub const DMA_IFCR_CHTIF1: u32 = 4;
pub const DMA_IFCR_CTEIF1_Pos: u32 = 3;
pub const DMA_IFCR_CTEIF1_Msk: u32 = 8;
pub const DMA_IFCR_CTEIF1: u32 = 8;
pub const DMA_IFCR_CGIF2_Pos: u32 = 4;
pub const DMA_IFCR_CGIF2_Msk: u32 = 16;
pub const DMA_IFCR_CGIF2: u32 = 16;
pub const DMA_IFCR_CTCIF2_Pos: u32 = 5;
pub const DMA_IFCR_CTCIF2_Msk: u32 = 32;
pub const DMA_IFCR_CTCIF2: u32 = 32;
pub const DMA_IFCR_CHTIF2_Pos: u32 = 6;
pub const DMA_IFCR_CHTIF2_Msk: u32 = 64;
pub const DMA_IFCR_CHTIF2: u32 = 64;
pub const DMA_IFCR_CTEIF2_Pos: u32 = 7;
pub const DMA_IFCR_CTEIF2_Msk: u32 = 128;
pub const DMA_IFCR_CTEIF2: u32 = 128;
pub const DMA_IFCR_CGIF3_Pos: u32 = 8;
pub const DMA_IFCR_CGIF3_Msk: u32 = 256;
pub const DMA_IFCR_CGIF3: u32 = 256;
pub const DMA_IFCR_CTCIF3_Pos: u32 = 9;
pub const DMA_IFCR_CTCIF3_Msk: u32 = 512;
pub const DMA_IFCR_CTCIF3: u32 = 512;
pub const DMA_IFCR_CHTIF3_Pos: u32 = 10;
pub const DMA_IFCR_CHTIF3_Msk: u32 = 1024;
pub const DMA_IFCR_CHTIF3: u32 = 1024;
pub const DMA_IFCR_CTEIF3_Pos: u32 = 11;
pub const DMA_IFCR_CTEIF3_Msk: u32 = 2048;
pub const DMA_IFCR_CTEIF3: u32 = 2048;
pub const DMA_CCR_EN_Pos: u32 = 0;
pub const DMA_CCR_EN_Msk: u32 = 1;
pub const DMA_CCR_EN: u32 = 1;
pub const DMA_CCR_TCIE_Pos: u32 = 1;
pub const DMA_CCR_TCIE_Msk: u32 = 2;
pub const DMA_CCR_TCIE: u32 = 2;
pub const DMA_CCR_HTIE_Pos: u32 = 2;
pub const DMA_CCR_HTIE_Msk: u32 = 4;
pub const DMA_CCR_HTIE: u32 = 4;
pub const DMA_CCR_TEIE_Pos: u32 = 3;
pub const DMA_CCR_TEIE_Msk: u32 = 8;
pub const DMA_CCR_TEIE: u32 = 8;
pub const DMA_CCR_DIR_Pos: u32 = 4;
pub const DMA_CCR_DIR_Msk: u32 = 16;
pub const DMA_CCR_DIR: u32 = 16;
pub const DMA_CCR_CIRC_Pos: u32 = 5;
pub const DMA_CCR_CIRC_Msk: u32 = 32;
pub const DMA_CCR_CIRC: u32 = 32;
pub const DMA_CCR_PINC_Pos: u32 = 6;
pub const DMA_CCR_PINC_Msk: u32 = 64;
pub const DMA_CCR_PINC: u32 = 64;
pub const DMA_CCR_MINC_Pos: u32 = 7;
pub const DMA_CCR_MINC_Msk: u32 = 128;
pub const DMA_CCR_MINC: u32 = 128;
pub const DMA_CCR_PSIZE_Pos: u32 = 8;
pub const DMA_CCR_PSIZE_Msk: u32 = 768;
pub const DMA_CCR_PSIZE: u32 = 768;
pub const DMA_CCR_PSIZE_0: u32 = 256;
pub const DMA_CCR_PSIZE_1: u32 = 512;
pub const DMA_CCR_MSIZE_Pos: u32 = 10;
pub const DMA_CCR_MSIZE_Msk: u32 = 3072;
pub const DMA_CCR_MSIZE: u32 = 3072;
pub const DMA_CCR_MSIZE_0: u32 = 1024;
pub const DMA_CCR_MSIZE_1: u32 = 2048;
pub const DMA_CCR_PL_Pos: u32 = 12;
pub const DMA_CCR_PL_Msk: u32 = 12288;
pub const DMA_CCR_PL: u32 = 12288;
pub const DMA_CCR_PL_0: u32 = 4096;
pub const DMA_CCR_PL_1: u32 = 8192;
pub const DMA_CCR_MEM2MEM_Pos: u32 = 14;
pub const DMA_CCR_MEM2MEM_Msk: u32 = 16384;
pub const DMA_CCR_MEM2MEM: u32 = 16384;
pub const DMA_CNDTR_NDT_Pos: u32 = 0;
pub const DMA_CNDTR_NDT_Msk: u32 = 65535;
pub const DMA_CNDTR_NDT: u32 = 65535;
pub const DMA_CPAR_PA_Pos: u32 = 0;
pub const DMA_CPAR_PA_Msk: u32 = 4294967295;
pub const DMA_CPAR_PA: u32 = 4294967295;
pub const DMA_CMAR_MA_Pos: u32 = 0;
pub const DMA_CMAR_MA_Msk: u32 = 4294967295;
pub const DMA_CMAR_MA: u32 = 4294967295;
pub const EXTI_RTSR_RT0_Pos: u32 = 0;
pub const EXTI_RTSR_RT0_Msk: u32 = 1;
pub const EXTI_RTSR_RT0: u32 = 1;
pub const EXTI_RTSR_RT1_Pos: u32 = 1;
pub const EXTI_RTSR_RT1_Msk: u32 = 2;
pub const EXTI_RTSR_RT1: u32 = 2;
pub const EXTI_RTSR_RT2_Pos: u32 = 2;
pub const EXTI_RTSR_RT2_Msk: u32 = 4;
pub const EXTI_RTSR_RT2: u32 = 4;
pub const EXTI_RTSR_RT3_Pos: u32 = 3;
pub const EXTI_RTSR_RT3_Msk: u32 = 8;
pub const EXTI_RTSR_RT3: u32 = 8;
pub const EXTI_RTSR_RT4_Pos: u32 = 4;
pub const EXTI_RTSR_RT4_Msk: u32 = 16;
pub const EXTI_RTSR_RT4: u32 = 16;
pub const EXTI_RTSR_RT5_Pos: u32 = 5;
pub const EXTI_RTSR_RT5_Msk: u32 = 32;
pub const EXTI_RTSR_RT5: u32 = 32;
pub const EXTI_RTSR_RT6_Pos: u32 = 6;
pub const EXTI_RTSR_RT6_Msk: u32 = 64;
pub const EXTI_RTSR_RT6: u32 = 64;
pub const EXTI_RTSR_RT7_Pos: u32 = 7;
pub const EXTI_RTSR_RT7_Msk: u32 = 128;
pub const EXTI_RTSR_RT7: u32 = 128;
pub const EXTI_RTSR_RT8_Pos: u32 = 8;
pub const EXTI_RTSR_RT8_Msk: u32 = 256;
pub const EXTI_RTSR_RT8: u32 = 256;
pub const EXTI_RTSR_RT9_Pos: u32 = 9;
pub const EXTI_RTSR_RT9_Msk: u32 = 512;
pub const EXTI_RTSR_RT9: u32 = 512;
pub const EXTI_RTSR_RT10_Pos: u32 = 10;
pub const EXTI_RTSR_RT10_Msk: u32 = 1024;
pub const EXTI_RTSR_RT10: u32 = 1024;
pub const EXTI_RTSR_RT11_Pos: u32 = 11;
pub const EXTI_RTSR_RT11_Msk: u32 = 2048;
pub const EXTI_RTSR_RT11: u32 = 2048;
pub const EXTI_RTSR_RT12_Pos: u32 = 12;
pub const EXTI_RTSR_RT12_Msk: u32 = 4096;
pub const EXTI_RTSR_RT12: u32 = 4096;
pub const EXTI_RTSR_RT13_Pos: u32 = 13;
pub const EXTI_RTSR_RT13_Msk: u32 = 8192;
pub const EXTI_RTSR_RT13: u32 = 8192;
pub const EXTI_RTSR_RT14_Pos: u32 = 14;
pub const EXTI_RTSR_RT14_Msk: u32 = 16384;
pub const EXTI_RTSR_RT14: u32 = 16384;
pub const EXTI_RTSR_RT15_Pos: u32 = 15;
pub const EXTI_RTSR_RT15_Msk: u32 = 32768;
pub const EXTI_RTSR_RT15: u32 = 32768;
pub const EXTI_RTSR_RT16_Pos: u32 = 16;
pub const EXTI_RTSR_RT16_Msk: u32 = 65536;
pub const EXTI_RTSR_RT16: u32 = 65536;
pub const EXTI_RTSR_RT17_Pos: u32 = 17;
pub const EXTI_RTSR_RT17_Msk: u32 = 65536;
pub const EXTI_RTSR_RT17: u32 = 65536;
pub const EXTI_RTSR_RT18_Pos: u32 = 18;
pub const EXTI_RTSR_RT18_Msk: u32 = 262144;
pub const EXTI_RTSR_RT18: u32 = 262144;
pub const EXTI_FTSR_FT0_Pos: u32 = 0;
pub const EXTI_FTSR_FT0_Msk: u32 = 1;
pub const EXTI_FTSR_FT0: u32 = 1;
pub const EXTI_FTSR_FT1_Pos: u32 = 1;
pub const EXTI_FTSR_FT1_Msk: u32 = 2;
pub const EXTI_FTSR_FT1: u32 = 2;
pub const EXTI_FTSR_FT2_Pos: u32 = 2;
pub const EXTI_FTSR_FT2_Msk: u32 = 4;
pub const EXTI_FTSR_FT2: u32 = 4;
pub const EXTI_FTSR_FT3_Pos: u32 = 3;
pub const EXTI_FTSR_FT3_Msk: u32 = 8;
pub const EXTI_FTSR_FT3: u32 = 8;
pub const EXTI_FTSR_FT4_Pos: u32 = 4;
pub const EXTI_FTSR_FT4_Msk: u32 = 16;
pub const EXTI_FTSR_FT4: u32 = 16;
pub const EXTI_FTSR_FT5_Pos: u32 = 5;
pub const EXTI_FTSR_FT5_Msk: u32 = 32;
pub const EXTI_FTSR_FT5: u32 = 32;
pub const EXTI_FTSR_FT6_Pos: u32 = 6;
pub const EXTI_FTSR_FT6_Msk: u32 = 64;
pub const EXTI_FTSR_FT6: u32 = 64;
pub const EXTI_FTSR_FT7_Pos: u32 = 7;
pub const EXTI_FTSR_FT7_Msk: u32 = 128;
pub const EXTI_FTSR_FT7: u32 = 128;
pub const EXTI_FTSR_FT8_Pos: u32 = 8;
pub const EXTI_FTSR_FT8_Msk: u32 = 256;
pub const EXTI_FTSR_FT8: u32 = 256;
pub const EXTI_FTSR_FT9_Pos: u32 = 9;
pub const EXTI_FTSR_FT9_Msk: u32 = 512;
pub const EXTI_FTSR_FT9: u32 = 512;
pub const EXTI_FTSR_FT10_Pos: u32 = 10;
pub const EXTI_FTSR_FT10_Msk: u32 = 1024;
pub const EXTI_FTSR_FT10: u32 = 1024;
pub const EXTI_FTSR_FT11_Pos: u32 = 11;
pub const EXTI_FTSR_FT11_Msk: u32 = 2048;
pub const EXTI_FTSR_FT11: u32 = 2048;
pub const EXTI_FTSR_FT12_Pos: u32 = 12;
pub const EXTI_FTSR_FT12_Msk: u32 = 4096;
pub const EXTI_FTSR_FT12: u32 = 4096;
pub const EXTI_FTSR_FT13_Pos: u32 = 13;
pub const EXTI_FTSR_FT13_Msk: u32 = 8192;
pub const EXTI_FTSR_FT13: u32 = 8192;
pub const EXTI_FTSR_FT14_Pos: u32 = 14;
pub const EXTI_FTSR_FT14_Msk: u32 = 16384;
pub const EXTI_FTSR_FT14: u32 = 16384;
pub const EXTI_FTSR_FT15_Pos: u32 = 15;
pub const EXTI_FTSR_FT15_Msk: u32 = 32768;
pub const EXTI_FTSR_FT15: u32 = 32768;
pub const EXTI_FTSR_FT16_Pos: u32 = 16;
pub const EXTI_FTSR_FT16_Msk: u32 = 65536;
pub const EXTI_FTSR_FT16: u32 = 65536;
pub const EXTI_FTSR_FT17_Pos: u32 = 17;
pub const EXTI_FTSR_FT17_Msk: u32 = 131072;
pub const EXTI_FTSR_FT17: u32 = 131072;
pub const EXTI_FTSR_FT18_Pos: u32 = 18;
pub const EXTI_FTSR_FT18_Msk: u32 = 262144;
pub const EXTI_FTSR_FT18: u32 = 262144;
pub const EXTI_SWIER_SWI0_Pos: u32 = 0;
pub const EXTI_SWIER_SWI0_Msk: u32 = 1;
pub const EXTI_SWIER_SWI0: u32 = 1;
pub const EXTI_SWIER_SWI1_Pos: u32 = 1;
pub const EXTI_SWIER_SWI1_Msk: u32 = 2;
pub const EXTI_SWIER_SWI1: u32 = 2;
pub const EXTI_SWIER_SWI2_Pos: u32 = 2;
pub const EXTI_SWIER_SWI2_Msk: u32 = 4;
pub const EXTI_SWIER_SWI2: u32 = 4;
pub const EXTI_SWIER_SWI3_Pos: u32 = 3;
pub const EXTI_SWIER_SWI3_Msk: u32 = 8;
pub const EXTI_SWIER_SWI3: u32 = 8;
pub const EXTI_SWIER_SWI4_Pos: u32 = 4;
pub const EXTI_SWIER_SWI4_Msk: u32 = 16;
pub const EXTI_SWIER_SWI4: u32 = 16;
pub const EXTI_SWIER_SWI5_Pos: u32 = 5;
pub const EXTI_SWIER_SWI5_Msk: u32 = 32;
pub const EXTI_SWIER_SWI5: u32 = 32;
pub const EXTI_SWIER_SWI6_Pos: u32 = 6;
pub const EXTI_SWIER_SWI6_Msk: u32 = 64;
pub const EXTI_SWIER_SWI6: u32 = 64;
pub const EXTI_SWIER_SWI7_Pos: u32 = 7;
pub const EXTI_SWIER_SWI7_Msk: u32 = 128;
pub const EXTI_SWIER_SWI7: u32 = 128;
pub const EXTI_SWIER_SWI8_Pos: u32 = 8;
pub const EXTI_SWIER_SWI8_Msk: u32 = 256;
pub const EXTI_SWIER_SWI8: u32 = 256;
pub const EXTI_SWIER_SWI9_Pos: u32 = 9;
pub const EXTI_SWIER_SWI9_Msk: u32 = 512;
pub const EXTI_SWIER_SWI9: u32 = 512;
pub const EXTI_SWIER_SWI10_Pos: u32 = 10;
pub const EXTI_SWIER_SWI10_Msk: u32 = 1024;
pub const EXTI_SWIER_SWI10: u32 = 1024;
pub const EXTI_SWIER_SWI11_Pos: u32 = 11;
pub const EXTI_SWIER_SWI11_Msk: u32 = 2048;
pub const EXTI_SWIER_SWI11: u32 = 2048;
pub const EXTI_SWIER_SWI12_Pos: u32 = 12;
pub const EXTI_SWIER_SWI12_Msk: u32 = 4096;
pub const EXTI_SWIER_SWI12: u32 = 4096;
pub const EXTI_SWIER_SWI13_Pos: u32 = 13;
pub const EXTI_SWIER_SWI13_Msk: u32 = 8192;
pub const EXTI_SWIER_SWI13: u32 = 8192;
pub const EXTI_SWIER_SWI14_Pos: u32 = 14;
pub const EXTI_SWIER_SWI14_Msk: u32 = 16384;
pub const EXTI_SWIER_SWI14: u32 = 16384;
pub const EXTI_SWIER_SWI15_Pos: u32 = 15;
pub const EXTI_SWIER_SWI15_Msk: u32 = 32768;
pub const EXTI_SWIER_SWI15: u32 = 32768;
pub const EXTI_SWIER_SWI16_Pos: u32 = 16;
pub const EXTI_SWIER_SWI16_Msk: u32 = 65536;
pub const EXTI_SWIER_SWI16: u32 = 65536;
pub const EXTI_SWIER_SWI17_Pos: u32 = 17;
pub const EXTI_SWIER_SWI17_Msk: u32 = 131072;
pub const EXTI_SWIER_SWI17: u32 = 131072;
pub const EXTI_SWIER_SWI18_Pos: u32 = 18;
pub const EXTI_SWIER_SWI18_Msk: u32 = 262144;
pub const EXTI_SWIER_SWI18: u32 = 262144;
pub const EXTI_PR_PR0_Pos: u32 = 0;
pub const EXTI_PR_PR0_Msk: u32 = 1;
pub const EXTI_PR_PR0: u32 = 1;
pub const EXTI_PR_PR1_Pos: u32 = 1;
pub const EXTI_PR_PR1_Msk: u32 = 2;
pub const EXTI_PR_PR1: u32 = 2;
pub const EXTI_PR_PR2_Pos: u32 = 2;
pub const EXTI_PR_PR2_Msk: u32 = 4;
pub const EXTI_PR_PR2: u32 = 4;
pub const EXTI_PR_PR3_Pos: u32 = 3;
pub const EXTI_PR_PR3_Msk: u32 = 8;
pub const EXTI_PR_PR3: u32 = 8;
pub const EXTI_PR_PR_Pos: u32 = 4;
pub const EXTI_PR_PR_Msk: u32 = 16;
pub const EXTI_PR_PR4: u32 = 16;
pub const EXTI_PR_PR5_Pos: u32 = 5;
pub const EXTI_PR_PR5_Msk: u32 = 32;
pub const EXTI_PR_PR5: u32 = 32;
pub const EXTI_PR_PR6_Pos: u32 = 6;
pub const EXTI_PR_PR6_Msk: u32 = 64;
pub const EXTI_PR_PR6: u32 = 64;
pub const EXTI_PR_PR7_Pos: u32 = 7;
pub const EXTI_PR_PR7_Msk: u32 = 128;
pub const EXTI_PR_PR7: u32 = 128;
pub const EXTI_PR_PR8_Pos: u32 = 8;
pub const EXTI_PR_PR8_Msk: u32 = 256;
pub const EXTI_PR_PR8: u32 = 256;
pub const EXTI_PR_PR9_Pos: u32 = 9;
pub const EXTI_PR_PR9_Msk: u32 = 512;
pub const EXTI_PR_PR9: u32 = 512;
pub const EXTI_PR_PR10_Pos: u32 = 10;
pub const EXTI_PR_PR10_Msk: u32 = 1024;
pub const EXTI_PR_PR10: u32 = 1024;
pub const EXTI_PR_PR11_Pos: u32 = 11;
pub const EXTI_PR_PR11_Msk: u32 = 2048;
pub const EXTI_PR_PR11: u32 = 2048;
pub const EXTI_PR_PR12_Pos: u32 = 12;
pub const EXTI_PR_PR12_Msk: u32 = 4096;
pub const EXTI_PR_PR12: u32 = 4096;
pub const EXTI_PR_PR13_Pos: u32 = 13;
pub const EXTI_PR_PR13_Msk: u32 = 8192;
pub const EXTI_PR_PR13: u32 = 8192;
pub const EXTI_PR_PR14_Pos: u32 = 14;
pub const EXTI_PR_PR14_Msk: u32 = 16384;
pub const EXTI_PR_PR14: u32 = 16384;
pub const EXTI_PR_PR15_Pos: u32 = 15;
pub const EXTI_PR_PR15_Msk: u32 = 32768;
pub const EXTI_PR_PR15: u32 = 32768;
pub const EXTI_PR_PR16_Pos: u32 = 16;
pub const EXTI_PR_PR16_Msk: u32 = 65536;
pub const EXTI_PR_PR16: u32 = 65536;
pub const EXTI_PR_PR17_Pos: u32 = 17;
pub const EXTI_PR_PR17_Msk: u32 = 131072;
pub const EXTI_PR_PR17: u32 = 131072;
pub const EXTI_PR_PR18_Pos: u32 = 18;
pub const EXTI_PR_PR18_Msk: u32 = 262144;
pub const EXTI_PR_PR18: u32 = 262144;
pub const EXTI_PR_PIF0: u32 = 1;
pub const EXTI_PR_PIF1: u32 = 2;
pub const EXTI_PR_PIF2: u32 = 4;
pub const EXTI_PR_PIF3: u32 = 8;
pub const EXTI_PR_PIF4: u32 = 16;
pub const EXTI_PR_PIF5: u32 = 32;
pub const EXTI_PR_PIF6: u32 = 64;
pub const EXTI_PR_PIF7: u32 = 128;
pub const EXTI_PR_PIF8: u32 = 256;
pub const EXTI_PR_PIF9: u32 = 512;
pub const EXTI_PR_PIF10: u32 = 1024;
pub const EXTI_PR_PIF11: u32 = 2048;
pub const EXTI_PR_PIF12: u32 = 4096;
pub const EXTI_PR_PIF13: u32 = 8192;
pub const EXTI_PR_PIF14: u32 = 16384;
pub const EXTI_PR_PIF15: u32 = 32768;
pub const EXTI_PR_PIF16: u32 = 65536;
pub const EXTI_PR_PIF17: u32 = 131072;
pub const EXTI_PR_PIF18: u32 = 262144;
pub const EXTI_EXTICR1_EXTI0_Pos: u32 = 0;
pub const EXTI_EXTICR1_EXTI0_Msk: u32 = 3;
pub const EXTI_EXTICR1_EXTI0: u32 = 3;
pub const EXTI_EXTICR1_EXTI0_0: u32 = 1;
pub const EXTI_EXTICR1_EXTI0_1: u32 = 2;
pub const EXTI_EXTICR1_EXTI1_Pos: u32 = 8;
pub const EXTI_EXTICR1_EXTI1_Msk: u32 = 768;
pub const EXTI_EXTICR1_EXTI1: u32 = 768;
pub const EXTI_EXTICR1_EXTI1_0: u32 = 256;
pub const EXTI_EXTICR1_EXTI1_1: u32 = 512;
pub const EXTI_EXTICR1_EXTI2_Pos: u32 = 16;
pub const EXTI_EXTICR1_EXTI2_Msk: u32 = 196608;
pub const EXTI_EXTICR1_EXTI2: u32 = 196608;
pub const EXTI_EXTICR1_EXTI2_0: u32 = 65536;
pub const EXTI_EXTICR1_EXTI2_1: u32 = 131072;
pub const EXTI_EXTICR1_EXTI3_Pos: u32 = 24;
pub const EXTI_EXTICR1_EXTI3_Msk: u32 = 50331648;
pub const EXTI_EXTICR1_EXTI3: u32 = 50331648;
pub const EXTI_EXTICR1_EXTI3_0: u32 = 16777216;
pub const EXTI_EXTICR1_EXTI3_1: u32 = 33554432;
pub const EXTI_EXTICR2_EXTI4_Pos: u32 = 0;
pub const EXTI_EXTICR2_EXTI4_Msk: u32 = 3;
pub const EXTI_EXTICR2_EXTI4: u32 = 3;
pub const EXTI_EXTICR2_EXTI4_0: u32 = 1;
pub const EXTI_EXTICR2_EXTI4_1: u32 = 2;
pub const EXTI_EXTICR2_EXTI5_Pos: u32 = 8;
pub const EXTI_EXTICR2_EXTI5_Msk: u32 = 256;
pub const EXTI_EXTICR2_EXTI5: u32 = 256;
pub const EXTI_EXTICR2_EXTI6_Pos: u32 = 16;
pub const EXTI_EXTICR2_EXTI6_Msk: u32 = 65536;
pub const EXTI_EXTICR2_EXTI6: u32 = 65536;
pub const EXTI_EXTICR2_EXTI7_Pos: u32 = 24;
pub const EXTI_EXTICR2_EXTI7_Msk: u32 = 16777216;
pub const EXTI_EXTICR2_EXTI7: u32 = 16777216;
pub const EXTI_EXTICR3_EXTI8_Pos: u32 = 0;
pub const EXTI_EXTICR3_EXTI8_Msk: u32 = 1;
pub const EXTI_EXTICR3_EXTI8: u32 = 1;
pub const EXTI_IMR_IM_Pos: u32 = 0;
pub const EXTI_IMR_IM_Msk: u32 = 537919487;
pub const EXTI_IMR_IM: u32 = 537919487;
pub const EXTI_IMR_IM0_Pos: u32 = 0;
pub const EXTI_IMR_IM0_Msk: u32 = 1;
pub const EXTI_IMR_IM0: u32 = 1;
pub const EXTI_IMR_IM1_Pos: u32 = 1;
pub const EXTI_IMR_IM1_Msk: u32 = 2;
pub const EXTI_IMR_IM1: u32 = 2;
pub const EXTI_IMR_IM2_Pos: u32 = 2;
pub const EXTI_IMR_IM2_Msk: u32 = 4;
pub const EXTI_IMR_IM2: u32 = 4;
pub const EXTI_IMR_IM3_Pos: u32 = 3;
pub const EXTI_IMR_IM3_Msk: u32 = 8;
pub const EXTI_IMR_IM3: u32 = 8;
pub const EXTI_IMR_IM4_Pos: u32 = 4;
pub const EXTI_IMR_IM4_Msk: u32 = 16;
pub const EXTI_IMR_IM4: u32 = 16;
pub const EXTI_IMR_IM5_Pos: u32 = 5;
pub const EXTI_IMR_IM5_Msk: u32 = 32;
pub const EXTI_IMR_IM5: u32 = 32;
pub const EXTI_IMR_IM6_Pos: u32 = 6;
pub const EXTI_IMR_IM6_Msk: u32 = 64;
pub const EXTI_IMR_IM6: u32 = 64;
pub const EXTI_IMR_IM7_Pos: u32 = 7;
pub const EXTI_IMR_IM7_Msk: u32 = 128;
pub const EXTI_IMR_IM7: u32 = 128;
pub const EXTI_IMR_IM8_Pos: u32 = 8;
pub const EXTI_IMR_IM8_Msk: u32 = 256;
pub const EXTI_IMR_IM8: u32 = 256;
pub const EXTI_IMR_IM9_Pos: u32 = 9;
pub const EXTI_IMR_IM9_Msk: u32 = 512;
pub const EXTI_IMR_IM9: u32 = 512;
pub const EXTI_IMR_IM10_Pos: u32 = 10;
pub const EXTI_IMR_IM10_Msk: u32 = 1024;
pub const EXTI_IMR_IM10: u32 = 1024;
pub const EXTI_IMR_IM11_Pos: u32 = 11;
pub const EXTI_IMR_IM11_Msk: u32 = 2048;
pub const EXTI_IMR_IM11: u32 = 2048;
pub const EXTI_IMR_IM12_Pos: u32 = 12;
pub const EXTI_IMR_IM12_Msk: u32 = 4096;
pub const EXTI_IMR_IM12: u32 = 4096;
pub const EXTI_IMR_IM13_Pos: u32 = 13;
pub const EXTI_IMR_IM13_Msk: u32 = 8192;
pub const EXTI_IMR_IM13: u32 = 8192;
pub const EXTI_IMR_IM14_Pos: u32 = 14;
pub const EXTI_IMR_IM14_Msk: u32 = 16384;
pub const EXTI_IMR_IM14: u32 = 16384;
pub const EXTI_IMR_IM15_Pos: u32 = 15;
pub const EXTI_IMR_IM15_Msk: u32 = 32768;
pub const EXTI_IMR_IM15: u32 = 32768;
pub const EXTI_IMR_IM16_Pos: u32 = 16;
pub const EXTI_IMR_IM16_Msk: u32 = 65536;
pub const EXTI_IMR_IM16: u32 = 65536;
pub const EXTI_IMR_IM17_Pos: u32 = 17;
pub const EXTI_IMR_IM17_Msk: u32 = 131072;
pub const EXTI_IMR_IM17: u32 = 131072;
pub const EXTI_IMR_IM18_Pos: u32 = 18;
pub const EXTI_IMR_IM18_Msk: u32 = 262144;
pub const EXTI_IMR_IM18: u32 = 262144;
pub const EXTI_IMR_IM19_Pos: u32 = 19;
pub const EXTI_IMR_IM19_Msk: u32 = 524288;
pub const EXTI_IMR_IM19: u32 = 524288;
pub const EXTI_IMR_IM29_Pos: u32 = 29;
pub const EXTI_IMR_IM29_Msk: u32 = 536870912;
pub const EXTI_IMR_IM29: u32 = 536870912;
pub const EXTI_EMR_EM_Pos: u32 = 0;
pub const EXTI_EMR_EM_Msk: u32 = 537919487;
pub const EXTI_EMR_EM: u32 = 537919487;
pub const EXTI_EMR_EM0_Pos: u32 = 0;
pub const EXTI_EMR_EM0_Msk: u32 = 1;
pub const EXTI_EMR_EM0: u32 = 1;
pub const EXTI_EMR_EM1_Pos: u32 = 1;
pub const EXTI_EMR_EM1_Msk: u32 = 2;
pub const EXTI_EMR_EM1: u32 = 2;
pub const EXTI_EMR_EM2_Pos: u32 = 2;
pub const EXTI_EMR_EM2_Msk: u32 = 4;
pub const EXTI_EMR_EM2: u32 = 4;
pub const EXTI_EMR_EM3_Pos: u32 = 3;
pub const EXTI_EMR_EM3_Msk: u32 = 8;
pub const EXTI_EMR_EM3: u32 = 8;
pub const EXTI_EMR_EM4_Pos: u32 = 4;
pub const EXTI_EMR_EM4_Msk: u32 = 16;
pub const EXTI_EMR_EM4: u32 = 16;
pub const EXTI_EMR_EM5_Pos: u32 = 5;
pub const EXTI_EMR_EM5_Msk: u32 = 32;
pub const EXTI_EMR_EM5: u32 = 32;
pub const EXTI_EMR_EM6_Pos: u32 = 6;
pub const EXTI_EMR_EM6_Msk: u32 = 64;
pub const EXTI_EMR_EM6: u32 = 64;
pub const EXTI_EMR_EM7_Pos: u32 = 7;
pub const EXTI_EMR_EM7_Msk: u32 = 128;
pub const EXTI_EMR_EM7: u32 = 128;
pub const EXTI_EMR_EM8_Pos: u32 = 8;
pub const EXTI_EMR_EM8_Msk: u32 = 256;
pub const EXTI_EMR_EM8: u32 = 256;
pub const EXTI_EMR_EM9_Pos: u32 = 9;
pub const EXTI_EMR_EM9_Msk: u32 = 512;
pub const EXTI_EMR_EM9: u32 = 512;
pub const EXTI_EMR_EM10_Pos: u32 = 10;
pub const EXTI_EMR_EM10_Msk: u32 = 1024;
pub const EXTI_EMR_EM10: u32 = 1024;
pub const EXTI_EMR_EM11_Pos: u32 = 11;
pub const EXTI_EMR_EM11_Msk: u32 = 2048;
pub const EXTI_EMR_EM11: u32 = 2048;
pub const EXTI_EMR_EM12_Pos: u32 = 12;
pub const EXTI_EMR_EM12_Msk: u32 = 4096;
pub const EXTI_EMR_EM12: u32 = 4096;
pub const EXTI_EMR_EM13_Pos: u32 = 13;
pub const EXTI_EMR_EM13_Msk: u32 = 8192;
pub const EXTI_EMR_EM13: u32 = 8192;
pub const EXTI_EMR_EM14_Pos: u32 = 14;
pub const EXTI_EMR_EM14_Msk: u32 = 16384;
pub const EXTI_EMR_EM14: u32 = 16384;
pub const EXTI_EMR_EM15_Pos: u32 = 15;
pub const EXTI_EMR_EM15_Msk: u32 = 32768;
pub const EXTI_EMR_EM15: u32 = 32768;
pub const EXTI_EMR_EM16_Pos: u32 = 16;
pub const EXTI_EMR_EM16_Msk: u32 = 65536;
pub const EXTI_EMR_EM16: u32 = 65536;
pub const EXTI_EMR_EM17_Pos: u32 = 17;
pub const EXTI_EMR_EM17_Msk: u32 = 131072;
pub const EXTI_EMR_EM17: u32 = 131072;
pub const EXTI_EMR_EM18_Pos: u32 = 18;
pub const EXTI_EMR_EM18_Msk: u32 = 262144;
pub const EXTI_EMR_EM18: u32 = 262144;
pub const EXTI_EMR_EM19_Pos: u32 = 19;
pub const EXTI_EMR_EM19_Msk: u32 = 524288;
pub const EXTI_EMR_EM19: u32 = 524288;
pub const EXTI_EMR_EM29_Pos: u32 = 29;
pub const EXTI_EMR_EM29_Msk: u32 = 536870912;
pub const EXTI_EMR_EM29: u32 = 536870912;
pub const FLASH_ACR_LATENCY_Pos: u32 = 0;
pub const FLASH_ACR_LATENCY_Msk: u32 = 1;
pub const FLASH_ACR_LATENCY: u32 = 1;
pub const FLASH_KEYR_KEY_Pos: u32 = 0;
pub const FLASH_KEYR_KEY_Msk: u32 = 4294967295;
pub const FLASH_KEYR_KEY: u32 = 4294967295;
pub const FLASH_OPTKEYR_OPTKEY_Pos: u32 = 0;
pub const FLASH_OPTKEYR_OPTKEY_Msk: u32 = 4294967295;
pub const FLASH_OPTKEYR_OPTKEY: u32 = 4294967295;
pub const FLASH_KEY1_Pos: u32 = 0;
pub const FLASH_KEY1_Msk: u32 = 1164378403;
pub const FLASH_KEY1: u32 = 1164378403;
pub const FLASH_KEY2_Pos: u32 = 0;
pub const FLASH_KEY2_Msk: u32 = 3455027627;
pub const FLASH_KEY2: u32 = 3455027627;
pub const FLASH_OPTKEY1_Pos: u32 = 0;
pub const FLASH_OPTKEY1_Msk: u32 = 135866939;
pub const FLASH_OPTKEY1: u32 = 135866939;
pub const FLASH_OPTKEY2_Pos: u32 = 0;
pub const FLASH_OPTKEY2_Msk: u32 = 1281191551;
pub const FLASH_OPTKEY2: u32 = 1281191551;
pub const FLASH_SR_EOP_Pos: u32 = 0;
pub const FLASH_SR_EOP_Msk: u32 = 1;
pub const FLASH_SR_EOP: u32 = 1;
pub const FLASH_SR_WRPERR_Pos: u32 = 4;
pub const FLASH_SR_WRPERR_Msk: u32 = 16;
pub const FLASH_SR_WRPERR: u32 = 16;
pub const FLASH_SR_OPTVERR_Pos: u32 = 15;
pub const FLASH_SR_OPTVERR_Msk: u32 = 32768;
pub const FLASH_SR_OPTVERR: u32 = 32768;
pub const FLASH_SR_BSY_Pos: u32 = 16;
pub const FLASH_SR_BSY_Msk: u32 = 65536;
pub const FLASH_SR_BSY: u32 = 65536;
pub const FLASH_CR_PG_Pos: u32 = 0;
pub const FLASH_CR_PG_Msk: u32 = 1;
pub const FLASH_CR_PG: u32 = 1;
pub const FLASH_CR_PER_Pos: u32 = 1;
pub const FLASH_CR_PER_Msk: u32 = 2;
pub const FLASH_CR_PER: u32 = 2;
pub const FLASH_CR_MER_Pos: u32 = 2;
pub const FLASH_CR_MER_Msk: u32 = 4;
pub const FLASH_CR_MER: u32 = 4;
pub const FLASH_CR_SER_Pos: u32 = 11;
pub const FLASH_CR_SER_Msk: u32 = 2048;
pub const FLASH_CR_SER: u32 = 2048;
pub const FLASH_CR_OPTSTRT_Pos: u32 = 17;
pub const FLASH_CR_OPTSTRT_Msk: u32 = 131072;
pub const FLASH_CR_OPTSTRT: u32 = 131072;
pub const FLASH_CR_PGSTRT_Pos: u32 = 19;
pub const FLASH_CR_PGSTRT_Msk: u32 = 524288;
pub const FLASH_CR_PGSTRT: u32 = 524288;
pub const FLASH_CR_EOPIE_Pos: u32 = 24;
pub const FLASH_CR_EOPIE_Msk: u32 = 16777216;
pub const FLASH_CR_EOPIE: u32 = 16777216;
pub const FLASH_CR_ERRIE_Pos: u32 = 25;
pub const FLASH_CR_ERRIE_Msk: u32 = 33554432;
pub const FLASH_CR_ERRIE: u32 = 33554432;
pub const FLASH_CR_OBL_LAUNCH_Pos: u32 = 27;
pub const FLASH_CR_OBL_LAUNCH_Msk: u32 = 134217728;
pub const FLASH_CR_OBL_LAUNCH: u32 = 134217728;
pub const FLASH_CR_OPTLOCK_Pos: u32 = 30;
pub const FLASH_CR_OPTLOCK_Msk: u32 = 1073741824;
pub const FLASH_CR_OPTLOCK: u32 = 1073741824;
pub const FLASH_CR_LOCK_Pos: u32 = 31;
pub const FLASH_CR_LOCK_Msk: u32 = 2147483648;
pub const FLASH_CR_LOCK: u32 = 2147483648;
pub const FLASH_OPTR_RDP_Pos: u32 = 0;
pub const FLASH_OPTR_RDP_Msk: u32 = 255;
pub const FLASH_OPTR_RDP: u32 = 255;
pub const FLASH_OPTR_BOR_EN_Pos: u32 = 8;
pub const FLASH_OPTR_BOR_EN_Msk: u32 = 256;
pub const FLASH_OPTR_BOR_EN: u32 = 256;
pub const FLASH_OPTR_BOR_LEV_Pos: u32 = 9;
pub const FLASH_OPTR_BOR_LEV_Msk: u32 = 3584;
pub const FLASH_OPTR_BOR_LEV: u32 = 3584;
pub const FLASH_OPTR_BOR_LEV_0: u32 = 512;
pub const FLASH_OPTR_BOR_LEV_1: u32 = 1024;
pub const FLASH_OPTR_BOR_LEV_2: u32 = 2048;
pub const FLASH_OPTR_IWDG_SW_Pos: u32 = 12;
pub const FLASH_OPTR_IWDG_SW_Msk: u32 = 4096;
pub const FLASH_OPTR_IWDG_SW: u32 = 4096;
pub const FLASH_OPTR_WWDG_SW_Pos: u32 = 13;
pub const FLASH_OPTR_WWDG_SW_Msk: u32 = 8192;
pub const FLASH_OPTR_WWDG_SW: u32 = 8192;
pub const FLASH_OPTR_NRST_MODE_Pos: u32 = 14;
pub const FLASH_OPTR_NRST_MODE_Msk: u32 = 16384;
pub const FLASH_OPTR_NRST_MODE: u32 = 16384;
pub const FLASH_OPTR_nBOOT1_Pos: u32 = 15;
pub const FLASH_OPTR_nBOOT1_Msk: u32 = 32768;
pub const FLASH_OPTR_nBOOT1: u32 = 32768;
pub const FLASH_OPTR_RDP_LEVEL_0: u32 = 170;
pub const FLASH_OPTR_RDP_LEVEL_1: u32 = 85;
pub const FLASH_SDKR_SDK_STRT_Pos: u32 = 0;
pub const FLASH_SDKR_SDK_STRT_Msk: u32 = 31;
pub const FLASH_SDKR_SDK_STRT: u32 = 31;
pub const FLASH_SDKR_SDK_STRT_0: u32 = 1;
pub const FLASH_SDKR_SDK_STRT_1: u32 = 2;
pub const FLASH_SDKR_SDK_STRT_2: u32 = 4;
pub const FLASH_SDKR_SDK_STRT_3: u32 = 8;
pub const FLASH_SDKR_SDK_STRT_4: u32 = 16;
pub const FLASH_SDKR_SDK_END_Pos: u32 = 8;
pub const FLASH_SDKR_SDK_END_Msk: u32 = 7936;
pub const FLASH_SDKR_SDK_END: u32 = 7936;
pub const FLASH_SDKR_SDK_END_0: u32 = 256;
pub const FLASH_SDKR_SDK_END_1: u32 = 512;
pub const FLASH_SDKR_SDK_END_2: u32 = 1024;
pub const FLASH_SDKR_SDK_END_3: u32 = 2048;
pub const FLASH_SDKR_SDK_END_4: u32 = 4096;
pub const FLASH_WRPR_WRP_Pos: u32 = 0;
pub const FLASH_WRPR_WRP_Msk: u32 = 65535;
pub const FLASH_WRPR_WRP: u32 = 65535;
pub const FLASH_WRPR_WRP_0: u32 = 1;
pub const FLASH_WRPR_WRP_1: u32 = 2;
pub const FLASH_WRPR_WRP_2: u32 = 4;
pub const FLASH_WRPR_WRP_3: u32 = 8;
pub const FLASH_WRPR_WRP_4: u32 = 16;
pub const FLASH_WRPR_WRP_5: u32 = 32;
pub const FLASH_WRPR_WRP_6: u32 = 64;
pub const FLASH_WRPR_WRP_7: u32 = 128;
pub const FLASH_WRPR_WRP_8: u32 = 256;
pub const FLASH_WRPR_WRP_9: u32 = 512;
pub const FLASH_WRPR_WRP_10: u32 = 1024;
pub const FLASH_WRPR_WRP_11: u32 = 2048;
pub const FLASH_WRPR_WRP_12: u32 = 4096;
pub const FLASH_WRPR_WRP_13: u32 = 8192;
pub const FLASH_WRPR_WRP_14: u32 = 16384;
pub const FLASH_WRPR_WRP_15: u32 = 32768;
pub const FLASH_STCR_SLEEP_EN_Pos: u32 = 0;
pub const FLASH_STCR_SLEEP_EN_Msk: u32 = 1;
pub const FLASH_STCR_SLEEP_EN: u32 = 1;
pub const FLASH_STCR_SLEEP_TIME_Pos: u32 = 8;
pub const FLASH_STCR_SLEEP_TIME_Msk: u32 = 65280;
pub const FLASH_STCR_SLEEP_TIME: u32 = 65280;
pub const FLASH_TS0_TS0_Pos: u32 = 0;
pub const FLASH_TS0_TS0_Msk: u32 = 255;
pub const FLASH_TS0_TS0: u32 = 255;
pub const FLASH_TS0_TS0_0: u32 = 1;
pub const FLASH_TS0_TS0_1: u32 = 2;
pub const FLASH_TS0_TS0_2: u32 = 4;
pub const FLASH_TS0_TS0_3: u32 = 8;
pub const FLASH_TS0_TS0_4: u32 = 16;
pub const FLASH_TS0_TS0_5: u32 = 32;
pub const FLASH_TS0_TS0_6: u32 = 64;
pub const FLASH_TS0_TS0_7: u32 = 128;
pub const FLASH_TS1_TS1_Pos: u32 = 0;
pub const FLASH_TS1_TS1_Msk: u32 = 255;
pub const FLASH_TS1_TS1: u32 = 255;
pub const FLASH_TS1_TS1_0: u32 = 1;
pub const FLASH_TS1_TS1_1: u32 = 2;
pub const FLASH_TS1_TS1_2: u32 = 4;
pub const FLASH_TS1_TS1_3: u32 = 8;
pub const FLASH_TS1_TS1_4: u32 = 16;
pub const FLASH_TS1_TS1_5: u32 = 32;
pub const FLASH_TS1_TS1_6: u32 = 64;
pub const FLASH_TS1_TS1_7: u32 = 128;
pub const FLASH_TS2P_TS2P_Pos: u32 = 0;
pub const FLASH_TS2P_TS2P_Msk: u32 = 255;
pub const FLASH_TS2P_TS2P: u32 = 255;
pub const FLASH_TS2P_TS2P_0: u32 = 1;
pub const FLASH_TS2P_TS2P_1: u32 = 2;
pub const FLASH_TS2P_TS2P_2: u32 = 4;
pub const FLASH_TS2P_TS2P_3: u32 = 8;
pub const FLASH_TS2P_TS2P_4: u32 = 16;
pub const FLASH_TS2P_TS2P_5: u32 = 32;
pub const FLASH_TS2P_TS2P_6: u32 = 64;
pub const FLASH_TS2P_TS2P_7: u32 = 128;
pub const FLASH_TPS3_TPS3_Pos: u32 = 0;
pub const FLASH_TPS3_TPS3_Msk: u32 = 2047;
pub const FLASH_TPS3_TPS3: u32 = 2047;
pub const FLASH_TPS3_TPS3_0: u32 = 1;
pub const FLASH_TPS3_TPS3_1: u32 = 2;
pub const FLASH_TPS3_TPS3_2: u32 = 4;
pub const FLASH_TPS3_TPS3_3: u32 = 8;
pub const FLASH_TPS3_TPS3_4: u32 = 16;
pub const FLASH_TPS3_TPS3_5: u32 = 32;
pub const FLASH_TPS3_TPS3_6: u32 = 64;
pub const FLASH_TPS3_TPS3_7: u32 = 128;
pub const FLASH_TPS3_TPS3_8: u32 = 256;
pub const FLASH_TPS3_TPS3_9: u32 = 512;
pub const FLASH_TPS3_TPS3_10: u32 = 1024;
pub const FLASH_TS3_TS3_Pos: u32 = 0;
pub const FLASH_TS3_TS3_Msk: u32 = 255;
pub const FLASH_TS3_TS3: u32 = 255;
pub const FLASH_TS3_TS3_0: u32 = 1;
pub const FLASH_TS3_TS3_1: u32 = 2;
pub const FLASH_TS3_TS3_2: u32 = 4;
pub const FLASH_TS3_TS3_3: u32 = 8;
pub const FLASH_TS3_TS3_4: u32 = 16;
pub const FLASH_TS3_TS3_5: u32 = 32;
pub const FLASH_TS3_TS3_6: u32 = 64;
pub const FLASH_TS3_TS3_7: u32 = 128;
pub const FLASH_PERTPE_PERTPE_Pos: u32 = 0;
pub const FLASH_PERTPE_PERTPE_Msk: u32 = 131071;
pub const FLASH_PERTPE_PERTPE: u32 = 131071;
pub const FLASH_PERTPE_PERTPE_0: u32 = 1;
pub const FLASH_PERTPE_PERTPE_1: u32 = 2;
pub const FLASH_PERTPE_PERTPE_2: u32 = 4;
pub const FLASH_PERTPE_PERTPE_3: u32 = 8;
pub const FLASH_PERTPE_PERTPE_4: u32 = 16;
pub const FLASH_PERTPE_PERTPE_5: u32 = 32;
pub const FLASH_PERTPE_PERTPE_6: u32 = 64;
pub const FLASH_PERTPE_PERTPE_7: u32 = 128;
pub const FLASH_PERTPE_PERTPE_8: u32 = 256;
pub const FLASH_PERTPE_PERTPE_9: u32 = 512;
pub const FLASH_PERTPE_PERTPE_10: u32 = 1024;
pub const FLASH_PERTPE_PERTPE_11: u32 = 2048;
pub const FLASH_PERTPE_PERTPE_12: u32 = 4096;
pub const FLASH_PERTPE_PERTPE_13: u32 = 8192;
pub const FLASH_PERTPE_PERTPE_14: u32 = 16384;
pub const FLASH_PERTPE_PERTPE_15: u32 = 32768;
pub const FLASH_PERTPE_PERTPE_16: u32 = 65536;
pub const FLASH_SMERTPE_SMERTPE_Pos: u32 = 0;
pub const FLASH_SMERTPE_SMERTPE_Msk: u32 = 131071;
pub const FLASH_SMERTPE_SMERTPE: u32 = 131071;
pub const FLASH_SMERTPE_SMERTPE_0: u32 = 1;
pub const FLASH_SMERTPE_SMERTPE_1: u32 = 2;
pub const FLASH_SMERTPE_SMERTPE_2: u32 = 4;
pub const FLASH_SMERTPE_SMERTPE_3: u32 = 8;
pub const FLASH_SMERTPE_SMERTPE_4: u32 = 16;
pub const FLASH_SMERTPE_SMERTPE_5: u32 = 32;
pub const FLASH_SMERTPE_SMERTPE_6: u32 = 64;
pub const FLASH_SMERTPE_SMERTPE_7: u32 = 128;
pub const FLASH_SMERTPE_SMERTPE_8: u32 = 256;
pub const FLASH_SMERTPE_SMERTPE_9: u32 = 512;
pub const FLASH_SMERTPE_SMERTPE_10: u32 = 1024;
pub const FLASH_SMERTPE_SMERTPE_11: u32 = 2048;
pub const FLASH_SMERTPE_SMERTPE_12: u32 = 4096;
pub const FLASH_SMERTPE_SMERTPE_13: u32 = 8192;
pub const FLASH_SMERTPE_SMERTPE_14: u32 = 16384;
pub const FLASH_SMERTPE_SMERTPE_15: u32 = 32768;
pub const FLASH_SMERTPE_SMERTPE_16: u32 = 65536;
pub const FLASH_PRGTPE_PRGTPE_Pos: u32 = 0;
pub const FLASH_PRGTPE_PRGTPE_Msk: u32 = 65535;
pub const FLASH_PRGTPE_PRGTPE: u32 = 65535;
pub const FLASH_PRGTPE_PRGTPE_0: u32 = 1;
pub const FLASH_PRGTPE_PRGTPE_1: u32 = 2;
pub const FLASH_PRGTPE_PRGTPE_2: u32 = 4;
pub const FLASH_PRGTPE_PRGTPE_3: u32 = 8;
pub const FLASH_PRGTPE_PRGTPE_4: u32 = 16;
pub const FLASH_PRGTPE_PRGTPE_5: u32 = 32;
pub const FLASH_PRGTPE_PRGTPE_6: u32 = 64;
pub const FLASH_PRGTPE_PRGTPE_7: u32 = 128;
pub const FLASH_PRGTPE_PRGTPE_8: u32 = 256;
pub const FLASH_PRGTPE_PRGTPE_9: u32 = 512;
pub const FLASH_PRGTPE_PRGTPE_10: u32 = 1024;
pub const FLASH_PRGTPE_PRGTPE_11: u32 = 2048;
pub const FLASH_PRGTPE_PRGTPE_12: u32 = 4096;
pub const FLASH_PRGTPE_PRGTPE_13: u32 = 8192;
pub const FLASH_PRGTPE_PRGTPE_14: u32 = 16384;
pub const FLASH_PRGTPE_PRGTPE_15: u32 = 32768;
pub const FLASH_PRETPE_PRETPE_Pos: u32 = 0;
pub const FLASH_PRETPE_PRETPE_Msk: u32 = 16383;
pub const FLASH_PRETPE_PRETPE: u32 = 16383;
pub const FLASH_PRETPE_PRETPE_0: u32 = 1;
pub const FLASH_PRETPE_PRETPE_1: u32 = 2;
pub const FLASH_PRETPE_PRETPE_2: u32 = 4;
pub const FLASH_PRETPE_PRETPE_3: u32 = 8;
pub const FLASH_PRETPE_PRETPE_4: u32 = 16;
pub const FLASH_PRETPE_PRETPE_5: u32 = 32;
pub const FLASH_PRETPE_PRETPE_6: u32 = 64;
pub const FLASH_PRETPE_PRETPE_7: u32 = 128;
pub const FLASH_PRETPE_PRETPE_8: u32 = 256;
pub const FLASH_PRETPE_PRETPE_9: u32 = 512;
pub const FLASH_PRETPE_PRETPE_10: u32 = 1024;
pub const FLASH_PRETPE_PRETPE_11: u32 = 2048;
pub const FLASH_PRETPE_PRETPE_12: u32 = 4096;
pub const FLASH_PRETPE_PRETPE_13: u32 = 8192;
pub const GPIO_MODER_MODE0_Pos: u32 = 0;
pub const GPIO_MODER_MODE0_Msk: u32 = 3;
pub const GPIO_MODER_MODE0: u32 = 3;
pub const GPIO_MODER_MODE0_0: u32 = 1;
pub const GPIO_MODER_MODE0_1: u32 = 2;
pub const GPIO_MODER_MODE1_Pos: u32 = 2;
pub const GPIO_MODER_MODE1_Msk: u32 = 12;
pub const GPIO_MODER_MODE1: u32 = 12;
pub const GPIO_MODER_MODE1_0: u32 = 4;
pub const GPIO_MODER_MODE1_1: u32 = 8;
pub const GPIO_MODER_MODE2_Pos: u32 = 4;
pub const GPIO_MODER_MODE2_Msk: u32 = 48;
pub const GPIO_MODER_MODE2: u32 = 48;
pub const GPIO_MODER_MODE2_0: u32 = 16;
pub const GPIO_MODER_MODE2_1: u32 = 32;
pub const GPIO_MODER_MODE3_Pos: u32 = 6;
pub const GPIO_MODER_MODE3_Msk: u32 = 192;
pub const GPIO_MODER_MODE3: u32 = 192;
pub const GPIO_MODER_MODE3_0: u32 = 64;
pub const GPIO_MODER_MODE3_1: u32 = 128;
pub const GPIO_MODER_MODE4_Pos: u32 = 8;
pub const GPIO_MODER_MODE4_Msk: u32 = 768;
pub const GPIO_MODER_MODE4: u32 = 768;
pub const GPIO_MODER_MODE4_0: u32 = 256;
pub const GPIO_MODER_MODE4_1: u32 = 512;
pub const GPIO_MODER_MODE5_Pos: u32 = 10;
pub const GPIO_MODER_MODE5_Msk: u32 = 3072;
pub const GPIO_MODER_MODE5: u32 = 3072;
pub const GPIO_MODER_MODE5_0: u32 = 1024;
pub const GPIO_MODER_MODE5_1: u32 = 2048;
pub const GPIO_MODER_MODE6_Pos: u32 = 12;
pub const GPIO_MODER_MODE6_Msk: u32 = 12288;
pub const GPIO_MODER_MODE6: u32 = 12288;
pub const GPIO_MODER_MODE6_0: u32 = 4096;
pub const GPIO_MODER_MODE6_1: u32 = 8192;
pub const GPIO_MODER_MODE7_Pos: u32 = 14;
pub const GPIO_MODER_MODE7_Msk: u32 = 49152;
pub const GPIO_MODER_MODE7: u32 = 49152;
pub const GPIO_MODER_MODE7_0: u32 = 16384;
pub const GPIO_MODER_MODE7_1: u32 = 32768;
pub const GPIO_MODER_MODE8_Pos: u32 = 16;
pub const GPIO_MODER_MODE8_Msk: u32 = 196608;
pub const GPIO_MODER_MODE8: u32 = 196608;
pub const GPIO_MODER_MODE8_0: u32 = 65536;
pub const GPIO_MODER_MODE8_1: u32 = 131072;
pub const GPIO_MODER_MODE9_Pos: u32 = 18;
pub const GPIO_MODER_MODE9_Msk: u32 = 786432;
pub const GPIO_MODER_MODE9: u32 = 786432;
pub const GPIO_MODER_MODE9_0: u32 = 262144;
pub const GPIO_MODER_MODE9_1: u32 = 524288;
pub const GPIO_MODER_MODE10_Pos: u32 = 20;
pub const GPIO_MODER_MODE10_Msk: u32 = 3145728;
pub const GPIO_MODER_MODE10: u32 = 3145728;
pub const GPIO_MODER_MODE10_0: u32 = 1048576;
pub const GPIO_MODER_MODE10_1: u32 = 2097152;
pub const GPIO_MODER_MODE11_Pos: u32 = 22;
pub const GPIO_MODER_MODE11_Msk: u32 = 12582912;
pub const GPIO_MODER_MODE11: u32 = 12582912;
pub const GPIO_MODER_MODE11_0: u32 = 4194304;
pub const GPIO_MODER_MODE11_1: u32 = 8388608;
pub const GPIO_MODER_MODE12_Pos: u32 = 24;
pub const GPIO_MODER_MODE12_Msk: u32 = 50331648;
pub const GPIO_MODER_MODE12: u32 = 50331648;
pub const GPIO_MODER_MODE12_0: u32 = 16777216;
pub const GPIO_MODER_MODE12_1: u32 = 33554432;
pub const GPIO_MODER_MODE13_Pos: u32 = 26;
pub const GPIO_MODER_MODE13_Msk: u32 = 201326592;
pub const GPIO_MODER_MODE13: u32 = 201326592;
pub const GPIO_MODER_MODE13_0: u32 = 67108864;
pub const GPIO_MODER_MODE13_1: u32 = 134217728;
pub const GPIO_MODER_MODE14_Pos: u32 = 28;
pub const GPIO_MODER_MODE14_Msk: u32 = 805306368;
pub const GPIO_MODER_MODE14: u32 = 805306368;
pub const GPIO_MODER_MODE14_0: u32 = 268435456;
pub const GPIO_MODER_MODE14_1: u32 = 536870912;
pub const GPIO_MODER_MODE15_Pos: u32 = 30;
pub const GPIO_MODER_MODE15_Msk: u32 = 3221225472;
pub const GPIO_MODER_MODE15: u32 = 3221225472;
pub const GPIO_MODER_MODE15_0: u32 = 1073741824;
pub const GPIO_MODER_MODE15_1: u32 = 2147483648;
pub const GPIO_OTYPER_OT0_Pos: u32 = 0;
pub const GPIO_OTYPER_OT0_Msk: u32 = 1;
pub const GPIO_OTYPER_OT0: u32 = 1;
pub const GPIO_OTYPER_OT1_Pos: u32 = 1;
pub const GPIO_OTYPER_OT1_Msk: u32 = 2;
pub const GPIO_OTYPER_OT1: u32 = 2;
pub const GPIO_OTYPER_OT2_Pos: u32 = 2;
pub const GPIO_OTYPER_OT2_Msk: u32 = 4;
pub const GPIO_OTYPER_OT2: u32 = 4;
pub const GPIO_OTYPER_OT3_Pos: u32 = 3;
pub const GPIO_OTYPER_OT3_Msk: u32 = 8;
pub const GPIO_OTYPER_OT3: u32 = 8;
pub const GPIO_OTYPER_OT4_Pos: u32 = 4;
pub const GPIO_OTYPER_OT4_Msk: u32 = 16;
pub const GPIO_OTYPER_OT4: u32 = 16;
pub const GPIO_OTYPER_OT5_Pos: u32 = 5;
pub const GPIO_OTYPER_OT5_Msk: u32 = 32;
pub const GPIO_OTYPER_OT5: u32 = 32;
pub const GPIO_OTYPER_OT6_Pos: u32 = 6;
pub const GPIO_OTYPER_OT6_Msk: u32 = 64;
pub const GPIO_OTYPER_OT6: u32 = 64;
pub const GPIO_OTYPER_OT7_Pos: u32 = 7;
pub const GPIO_OTYPER_OT7_Msk: u32 = 128;
pub const GPIO_OTYPER_OT7: u32 = 128;
pub const GPIO_OTYPER_OT8_Pos: u32 = 8;
pub const GPIO_OTYPER_OT8_Msk: u32 = 256;
pub const GPIO_OTYPER_OT8: u32 = 256;
pub const GPIO_OTYPER_OT9_Pos: u32 = 9;
pub const GPIO_OTYPER_OT9_Msk: u32 = 512;
pub const GPIO_OTYPER_OT9: u32 = 512;
pub const GPIO_OTYPER_OT10_Pos: u32 = 10;
pub const GPIO_OTYPER_OT10_Msk: u32 = 1024;
pub const GPIO_OTYPER_OT10: u32 = 1024;
pub const GPIO_OTYPER_OT11_Pos: u32 = 11;
pub const GPIO_OTYPER_OT11_Msk: u32 = 2048;
pub const GPIO_OTYPER_OT11: u32 = 2048;
pub const GPIO_OTYPER_OT12_Pos: u32 = 12;
pub const GPIO_OTYPER_OT12_Msk: u32 = 4096;
pub const GPIO_OTYPER_OT12: u32 = 4096;
pub const GPIO_OTYPER_OT13_Pos: u32 = 13;
pub const GPIO_OTYPER_OT13_Msk: u32 = 8192;
pub const GPIO_OTYPER_OT13: u32 = 8192;
pub const GPIO_OTYPER_OT14_Pos: u32 = 14;
pub const GPIO_OTYPER_OT14_Msk: u32 = 16384;
pub const GPIO_OTYPER_OT14: u32 = 16384;
pub const GPIO_OTYPER_OT15_Pos: u32 = 15;
pub const GPIO_OTYPER_OT15_Msk: u32 = 32768;
pub const GPIO_OTYPER_OT15: u32 = 32768;
pub const GPIO_OSPEEDR_OSPEED0_Pos: u32 = 0;
pub const GPIO_OSPEEDR_OSPEED0_Msk: u32 = 3;
pub const GPIO_OSPEEDR_OSPEED0: u32 = 3;
pub const GPIO_OSPEEDR_OSPEED0_0: u32 = 1;
pub const GPIO_OSPEEDR_OSPEED0_1: u32 = 2;
pub const GPIO_OSPEEDR_OSPEED1_Pos: u32 = 2;
pub const GPIO_OSPEEDR_OSPEED1_Msk: u32 = 12;
pub const GPIO_OSPEEDR_OSPEED1: u32 = 12;
pub const GPIO_OSPEEDR_OSPEED1_0: u32 = 4;
pub const GPIO_OSPEEDR_OSPEED1_1: u32 = 8;
pub const GPIO_OSPEEDR_OSPEED2_Pos: u32 = 4;
pub const GPIO_OSPEEDR_OSPEED2_Msk: u32 = 48;
pub const GPIO_OSPEEDR_OSPEED2: u32 = 48;
pub const GPIO_OSPEEDR_OSPEED2_0: u32 = 16;
pub const GPIO_OSPEEDR_OSPEED2_1: u32 = 32;
pub const GPIO_OSPEEDR_OSPEED3_Pos: u32 = 6;
pub const GPIO_OSPEEDR_OSPEED3_Msk: u32 = 192;
pub const GPIO_OSPEEDR_OSPEED3: u32 = 192;
pub const GPIO_OSPEEDR_OSPEED3_0: u32 = 64;
pub const GPIO_OSPEEDR_OSPEED3_1: u32 = 128;
pub const GPIO_OSPEEDR_OSPEED4_Pos: u32 = 8;
pub const GPIO_OSPEEDR_OSPEED4_Msk: u32 = 768;
pub const GPIO_OSPEEDR_OSPEED4: u32 = 768;
pub const GPIO_OSPEEDR_OSPEED4_0: u32 = 256;
pub const GPIO_OSPEEDR_OSPEED4_1: u32 = 512;
pub const GPIO_OSPEEDR_OSPEED5_Pos: u32 = 10;
pub const GPIO_OSPEEDR_OSPEED5_Msk: u32 = 3072;
pub const GPIO_OSPEEDR_OSPEED5: u32 = 3072;
pub const GPIO_OSPEEDR_OSPEED5_0: u32 = 1024;
pub const GPIO_OSPEEDR_OSPEED5_1: u32 = 2048;
pub const GPIO_OSPEEDR_OSPEED6_Pos: u32 = 12;
pub const GPIO_OSPEEDR_OSPEED6_Msk: u32 = 12288;
pub const GPIO_OSPEEDR_OSPEED6: u32 = 12288;
pub const GPIO_OSPEEDR_OSPEED6_0: u32 = 4096;
pub const GPIO_OSPEEDR_OSPEED6_1: u32 = 8192;
pub const GPIO_OSPEEDR_OSPEED7_Pos: u32 = 14;
pub const GPIO_OSPEEDR_OSPEED7_Msk: u32 = 49152;
pub const GPIO_OSPEEDR_OSPEED7: u32 = 49152;
pub const GPIO_OSPEEDR_OSPEED7_0: u32 = 16384;
pub const GPIO_OSPEEDR_OSPEED7_1: u32 = 32768;
pub const GPIO_OSPEEDR_OSPEED8_Pos: u32 = 16;
pub const GPIO_OSPEEDR_OSPEED8_Msk: u32 = 196608;
pub const GPIO_OSPEEDR_OSPEED8: u32 = 196608;
pub const GPIO_OSPEEDR_OSPEED8_0: u32 = 65536;
pub const GPIO_OSPEEDR_OSPEED8_1: u32 = 131072;
pub const GPIO_OSPEEDR_OSPEED9_Pos: u32 = 18;
pub const GPIO_OSPEEDR_OSPEED9_Msk: u32 = 786432;
pub const GPIO_OSPEEDR_OSPEED9: u32 = 786432;
pub const GPIO_OSPEEDR_OSPEED9_0: u32 = 262144;
pub const GPIO_OSPEEDR_OSPEED9_1: u32 = 524288;
pub const GPIO_OSPEEDR_OSPEED10_Pos: u32 = 20;
pub const GPIO_OSPEEDR_OSPEED10_Msk: u32 = 3145728;
pub const GPIO_OSPEEDR_OSPEED10: u32 = 3145728;
pub const GPIO_OSPEEDR_OSPEED10_0: u32 = 1048576;
pub const GPIO_OSPEEDR_OSPEED10_1: u32 = 2097152;
pub const GPIO_OSPEEDR_OSPEED11_Pos: u32 = 22;
pub const GPIO_OSPEEDR_OSPEED11_Msk: u32 = 12582912;
pub const GPIO_OSPEEDR_OSPEED11: u32 = 12582912;
pub const GPIO_OSPEEDR_OSPEED11_0: u32 = 4194304;
pub const GPIO_OSPEEDR_OSPEED11_1: u32 = 8388608;
pub const GPIO_OSPEEDR_OSPEED12_Pos: u32 = 24;
pub const GPIO_OSPEEDR_OSPEED12_Msk: u32 = 50331648;
pub const GPIO_OSPEEDR_OSPEED12: u32 = 50331648;
pub const GPIO_OSPEEDR_OSPEED12_0: u32 = 16777216;
pub const GPIO_OSPEEDR_OSPEED12_1: u32 = 33554432;
pub const GPIO_OSPEEDR_OSPEED13_Pos: u32 = 26;
pub const GPIO_OSPEEDR_OSPEED13_Msk: u32 = 201326592;
pub const GPIO_OSPEEDR_OSPEED13: u32 = 201326592;
pub const GPIO_OSPEEDR_OSPEED13_0: u32 = 67108864;
pub const GPIO_OSPEEDR_OSPEED13_1: u32 = 134217728;
pub const GPIO_OSPEEDR_OSPEED14_Pos: u32 = 28;
pub const GPIO_OSPEEDR_OSPEED14_Msk: u32 = 805306368;
pub const GPIO_OSPEEDR_OSPEED14: u32 = 805306368;
pub const GPIO_OSPEEDR_OSPEED14_0: u32 = 268435456;
pub const GPIO_OSPEEDR_OSPEED14_1: u32 = 536870912;
pub const GPIO_OSPEEDR_OSPEED15_Pos: u32 = 30;
pub const GPIO_OSPEEDR_OSPEED15_Msk: u32 = 3221225472;
pub const GPIO_OSPEEDR_OSPEED15: u32 = 3221225472;
pub const GPIO_OSPEEDR_OSPEED15_0: u32 = 1073741824;
pub const GPIO_OSPEEDR_OSPEED15_1: u32 = 2147483648;
pub const GPIO_PUPDR_PUPD0_Pos: u32 = 0;
pub const GPIO_PUPDR_PUPD0_Msk: u32 = 3;
pub const GPIO_PUPDR_PUPD0: u32 = 3;
pub const GPIO_PUPDR_PUPD0_0: u32 = 1;
pub const GPIO_PUPDR_PUPD0_1: u32 = 2;
pub const GPIO_PUPDR_PUPD1_Pos: u32 = 2;
pub const GPIO_PUPDR_PUPD1_Msk: u32 = 12;
pub const GPIO_PUPDR_PUPD1: u32 = 12;
pub const GPIO_PUPDR_PUPD1_0: u32 = 4;
pub const GPIO_PUPDR_PUPD1_1: u32 = 8;
pub const GPIO_PUPDR_PUPD2_Pos: u32 = 4;
pub const GPIO_PUPDR_PUPD2_Msk: u32 = 48;
pub const GPIO_PUPDR_PUPD2: u32 = 48;
pub const GPIO_PUPDR_PUPD2_0: u32 = 16;
pub const GPIO_PUPDR_PUPD2_1: u32 = 32;
pub const GPIO_PUPDR_PUPD3_Pos: u32 = 6;
pub const GPIO_PUPDR_PUPD3_Msk: u32 = 192;
pub const GPIO_PUPDR_PUPD3: u32 = 192;
pub const GPIO_PUPDR_PUPD3_0: u32 = 64;
pub const GPIO_PUPDR_PUPD3_1: u32 = 128;
pub const GPIO_PUPDR_PUPD4_Pos: u32 = 8;
pub const GPIO_PUPDR_PUPD4_Msk: u32 = 768;
pub const GPIO_PUPDR_PUPD4: u32 = 768;
pub const GPIO_PUPDR_PUPD4_0: u32 = 256;
pub const GPIO_PUPDR_PUPD4_1: u32 = 512;
pub const GPIO_PUPDR_PUPD5_Pos: u32 = 10;
pub const GPIO_PUPDR_PUPD5_Msk: u32 = 3072;
pub const GPIO_PUPDR_PUPD5: u32 = 3072;
pub const GPIO_PUPDR_PUPD5_0: u32 = 1024;
pub const GPIO_PUPDR_PUPD5_1: u32 = 2048;
pub const GPIO_PUPDR_PUPD6_Pos: u32 = 12;
pub const GPIO_PUPDR_PUPD6_Msk: u32 = 12288;
pub const GPIO_PUPDR_PUPD6: u32 = 12288;
pub const GPIO_PUPDR_PUPD6_0: u32 = 4096;
pub const GPIO_PUPDR_PUPD6_1: u32 = 8192;
pub const GPIO_PUPDR_PUPD7_Pos: u32 = 14;
pub const GPIO_PUPDR_PUPD7_Msk: u32 = 49152;
pub const GPIO_PUPDR_PUPD7: u32 = 49152;
pub const GPIO_PUPDR_PUPD7_0: u32 = 16384;
pub const GPIO_PUPDR_PUPD7_1: u32 = 32768;
pub const GPIO_PUPDR_PUPD8_Pos: u32 = 16;
pub const GPIO_PUPDR_PUPD8_Msk: u32 = 196608;
pub const GPIO_PUPDR_PUPD8: u32 = 196608;
pub const GPIO_PUPDR_PUPD8_0: u32 = 65536;
pub const GPIO_PUPDR_PUPD8_1: u32 = 131072;
pub const GPIO_PUPDR_PUPD9_Pos: u32 = 18;
pub const GPIO_PUPDR_PUPD9_Msk: u32 = 786432;
pub const GPIO_PUPDR_PUPD9: u32 = 786432;
pub const GPIO_PUPDR_PUPD9_0: u32 = 262144;
pub const GPIO_PUPDR_PUPD9_1: u32 = 524288;
pub const GPIO_PUPDR_PUPD10_Pos: u32 = 20;
pub const GPIO_PUPDR_PUPD10_Msk: u32 = 3145728;
pub const GPIO_PUPDR_PUPD10: u32 = 3145728;
pub const GPIO_PUPDR_PUPD10_0: u32 = 1048576;
pub const GPIO_PUPDR_PUPD10_1: u32 = 2097152;
pub const GPIO_PUPDR_PUPD11_Pos: u32 = 22;
pub const GPIO_PUPDR_PUPD11_Msk: u32 = 12582912;
pub const GPIO_PUPDR_PUPD11: u32 = 12582912;
pub const GPIO_PUPDR_PUPD11_0: u32 = 4194304;
pub const GPIO_PUPDR_PUPD11_1: u32 = 8388608;
pub const GPIO_PUPDR_PUPD12_Pos: u32 = 24;
pub const GPIO_PUPDR_PUPD12_Msk: u32 = 50331648;
pub const GPIO_PUPDR_PUPD12: u32 = 50331648;
pub const GPIO_PUPDR_PUPD12_0: u32 = 16777216;
pub const GPIO_PUPDR_PUPD12_1: u32 = 33554432;
pub const GPIO_PUPDR_PUPD13_Pos: u32 = 26;
pub const GPIO_PUPDR_PUPD13_Msk: u32 = 201326592;
pub const GPIO_PUPDR_PUPD13: u32 = 201326592;
pub const GPIO_PUPDR_PUPD13_0: u32 = 67108864;
pub const GPIO_PUPDR_PUPD13_1: u32 = 134217728;
pub const GPIO_PUPDR_PUPD14_Pos: u32 = 28;
pub const GPIO_PUPDR_PUPD14_Msk: u32 = 805306368;
pub const GPIO_PUPDR_PUPD14: u32 = 805306368;
pub const GPIO_PUPDR_PUPD14_0: u32 = 268435456;
pub const GPIO_PUPDR_PUPD14_1: u32 = 536870912;
pub const GPIO_PUPDR_PUPD15_Pos: u32 = 30;
pub const GPIO_PUPDR_PUPD15_Msk: u32 = 3221225472;
pub const GPIO_PUPDR_PUPD15: u32 = 3221225472;
pub const GPIO_PUPDR_PUPD15_0: u32 = 1073741824;
pub const GPIO_PUPDR_PUPD15_1: u32 = 2147483648;
pub const GPIO_IDR_ID0_Pos: u32 = 0;
pub const GPIO_IDR_ID0_Msk: u32 = 1;
pub const GPIO_IDR_ID0: u32 = 1;
pub const GPIO_IDR_ID1_Pos: u32 = 1;
pub const GPIO_IDR_ID1_Msk: u32 = 2;
pub const GPIO_IDR_ID1: u32 = 2;
pub const GPIO_IDR_ID2_Pos: u32 = 2;
pub const GPIO_IDR_ID2_Msk: u32 = 4;
pub const GPIO_IDR_ID2: u32 = 4;
pub const GPIO_IDR_ID3_Pos: u32 = 3;
pub const GPIO_IDR_ID3_Msk: u32 = 8;
pub const GPIO_IDR_ID3: u32 = 8;
pub const GPIO_IDR_ID4_Pos: u32 = 4;
pub const GPIO_IDR_ID4_Msk: u32 = 16;
pub const GPIO_IDR_ID4: u32 = 16;
pub const GPIO_IDR_ID5_Pos: u32 = 5;
pub const GPIO_IDR_ID5_Msk: u32 = 32;
pub const GPIO_IDR_ID5: u32 = 32;
pub const GPIO_IDR_ID6_Pos: u32 = 6;
pub const GPIO_IDR_ID6_Msk: u32 = 64;
pub const GPIO_IDR_ID6: u32 = 64;
pub const GPIO_IDR_ID7_Pos: u32 = 7;
pub const GPIO_IDR_ID7_Msk: u32 = 128;
pub const GPIO_IDR_ID7: u32 = 128;
pub const GPIO_IDR_ID8_Pos: u32 = 8;
pub const GPIO_IDR_ID8_Msk: u32 = 256;
pub const GPIO_IDR_ID8: u32 = 256;
pub const GPIO_IDR_ID9_Pos: u32 = 9;
pub const GPIO_IDR_ID9_Msk: u32 = 512;
pub const GPIO_IDR_ID9: u32 = 512;
pub const GPIO_IDR_ID10_Pos: u32 = 10;
pub const GPIO_IDR_ID10_Msk: u32 = 1024;
pub const GPIO_IDR_ID10: u32 = 1024;
pub const GPIO_IDR_ID11_Pos: u32 = 11;
pub const GPIO_IDR_ID11_Msk: u32 = 2048;
pub const GPIO_IDR_ID11: u32 = 2048;
pub const GPIO_IDR_ID12_Pos: u32 = 12;
pub const GPIO_IDR_ID12_Msk: u32 = 4096;
pub const GPIO_IDR_ID12: u32 = 4096;
pub const GPIO_IDR_ID13_Pos: u32 = 13;
pub const GPIO_IDR_ID13_Msk: u32 = 8192;
pub const GPIO_IDR_ID13: u32 = 8192;
pub const GPIO_IDR_ID14_Pos: u32 = 14;
pub const GPIO_IDR_ID14_Msk: u32 = 16384;
pub const GPIO_IDR_ID14: u32 = 16384;
pub const GPIO_IDR_ID15_Pos: u32 = 15;
pub const GPIO_IDR_ID15_Msk: u32 = 32768;
pub const GPIO_IDR_ID15: u32 = 32768;
pub const GPIO_ODR_OD0_Pos: u32 = 0;
pub const GPIO_ODR_OD0_Msk: u32 = 1;
pub const GPIO_ODR_OD0: u32 = 1;
pub const GPIO_ODR_OD1_Pos: u32 = 1;
pub const GPIO_ODR_OD1_Msk: u32 = 2;
pub const GPIO_ODR_OD1: u32 = 2;
pub const GPIO_ODR_OD2_Pos: u32 = 2;
pub const GPIO_ODR_OD2_Msk: u32 = 4;
pub const GPIO_ODR_OD2: u32 = 4;
pub const GPIO_ODR_OD3_Pos: u32 = 3;
pub const GPIO_ODR_OD3_Msk: u32 = 8;
pub const GPIO_ODR_OD3: u32 = 8;
pub const GPIO_ODR_OD4_Pos: u32 = 4;
pub const GPIO_ODR_OD4_Msk: u32 = 16;
pub const GPIO_ODR_OD4: u32 = 16;
pub const GPIO_ODR_OD5_Pos: u32 = 5;
pub const GPIO_ODR_OD5_Msk: u32 = 32;
pub const GPIO_ODR_OD5: u32 = 32;
pub const GPIO_ODR_OD6_Pos: u32 = 6;
pub const GPIO_ODR_OD6_Msk: u32 = 64;
pub const GPIO_ODR_OD6: u32 = 64;
pub const GPIO_ODR_OD7_Pos: u32 = 7;
pub const GPIO_ODR_OD7_Msk: u32 = 128;
pub const GPIO_ODR_OD7: u32 = 128;
pub const GPIO_ODR_OD8_Pos: u32 = 8;
pub const GPIO_ODR_OD8_Msk: u32 = 256;
pub const GPIO_ODR_OD8: u32 = 256;
pub const GPIO_ODR_OD9_Pos: u32 = 9;
pub const GPIO_ODR_OD9_Msk: u32 = 512;
pub const GPIO_ODR_OD9: u32 = 512;
pub const GPIO_ODR_OD10_Pos: u32 = 10;
pub const GPIO_ODR_OD10_Msk: u32 = 1024;
pub const GPIO_ODR_OD10: u32 = 1024;
pub const GPIO_ODR_OD11_Pos: u32 = 11;
pub const GPIO_ODR_OD11_Msk: u32 = 2048;
pub const GPIO_ODR_OD11: u32 = 2048;
pub const GPIO_ODR_OD12_Pos: u32 = 12;
pub const GPIO_ODR_OD12_Msk: u32 = 4096;
pub const GPIO_ODR_OD12: u32 = 4096;
pub const GPIO_ODR_OD13_Pos: u32 = 13;
pub const GPIO_ODR_OD13_Msk: u32 = 8192;
pub const GPIO_ODR_OD13: u32 = 8192;
pub const GPIO_ODR_OD14_Pos: u32 = 14;
pub const GPIO_ODR_OD14_Msk: u32 = 16384;
pub const GPIO_ODR_OD14: u32 = 16384;
pub const GPIO_ODR_OD15_Pos: u32 = 15;
pub const GPIO_ODR_OD15_Msk: u32 = 32768;
pub const GPIO_ODR_OD15: u32 = 32768;
pub const GPIO_BSRR_BS0_Pos: u32 = 0;
pub const GPIO_BSRR_BS0_Msk: u32 = 1;
pub const GPIO_BSRR_BS0: u32 = 1;
pub const GPIO_BSRR_BS1_Pos: u32 = 1;
pub const GPIO_BSRR_BS1_Msk: u32 = 2;
pub const GPIO_BSRR_BS1: u32 = 2;
pub const GPIO_BSRR_BS2_Pos: u32 = 2;
pub const GPIO_BSRR_BS2_Msk: u32 = 4;
pub const GPIO_BSRR_BS2: u32 = 4;
pub const GPIO_BSRR_BS3_Pos: u32 = 3;
pub const GPIO_BSRR_BS3_Msk: u32 = 8;
pub const GPIO_BSRR_BS3: u32 = 8;
pub const GPIO_BSRR_BS4_Pos: u32 = 4;
pub const GPIO_BSRR_BS4_Msk: u32 = 16;
pub const GPIO_BSRR_BS4: u32 = 16;
pub const GPIO_BSRR_BS5_Pos: u32 = 5;
pub const GPIO_BSRR_BS5_Msk: u32 = 32;
pub const GPIO_BSRR_BS5: u32 = 32;
pub const GPIO_BSRR_BS6_Pos: u32 = 6;
pub const GPIO_BSRR_BS6_Msk: u32 = 64;
pub const GPIO_BSRR_BS6: u32 = 64;
pub const GPIO_BSRR_BS7_Pos: u32 = 7;
pub const GPIO_BSRR_BS7_Msk: u32 = 128;
pub const GPIO_BSRR_BS7: u32 = 128;
pub const GPIO_BSRR_BS8_Pos: u32 = 8;
pub const GPIO_BSRR_BS8_Msk: u32 = 256;
pub const GPIO_BSRR_BS8: u32 = 256;
pub const GPIO_BSRR_BS9_Pos: u32 = 9;
pub const GPIO_BSRR_BS9_Msk: u32 = 512;
pub const GPIO_BSRR_BS9: u32 = 512;
pub const GPIO_BSRR_BS10_Pos: u32 = 10;
pub const GPIO_BSRR_BS10_Msk: u32 = 1024;
pub const GPIO_BSRR_BS10: u32 = 1024;
pub const GPIO_BSRR_BS11_Pos: u32 = 11;
pub const GPIO_BSRR_BS11_Msk: u32 = 2048;
pub const GPIO_BSRR_BS11: u32 = 2048;
pub const GPIO_BSRR_BS12_Pos: u32 = 12;
pub const GPIO_BSRR_BS12_Msk: u32 = 4096;
pub const GPIO_BSRR_BS12: u32 = 4096;
pub const GPIO_BSRR_BS13_Pos: u32 = 13;
pub const GPIO_BSRR_BS13_Msk: u32 = 8192;
pub const GPIO_BSRR_BS13: u32 = 8192;
pub const GPIO_BSRR_BS14_Pos: u32 = 14;
pub const GPIO_BSRR_BS14_Msk: u32 = 16384;
pub const GPIO_BSRR_BS14: u32 = 16384;
pub const GPIO_BSRR_BS15_Pos: u32 = 15;
pub const GPIO_BSRR_BS15_Msk: u32 = 32768;
pub const GPIO_BSRR_BS15: u32 = 32768;
pub const GPIO_BSRR_BR0_Pos: u32 = 16;
pub const GPIO_BSRR_BR0_Msk: u32 = 65536;
pub const GPIO_BSRR_BR0: u32 = 65536;
pub const GPIO_BSRR_BR1_Pos: u32 = 17;
pub const GPIO_BSRR_BR1_Msk: u32 = 131072;
pub const GPIO_BSRR_BR1: u32 = 131072;
pub const GPIO_BSRR_BR2_Pos: u32 = 18;
pub const GPIO_BSRR_BR2_Msk: u32 = 262144;
pub const GPIO_BSRR_BR2: u32 = 262144;
pub const GPIO_BSRR_BR3_Pos: u32 = 19;
pub const GPIO_BSRR_BR3_Msk: u32 = 524288;
pub const GPIO_BSRR_BR3: u32 = 524288;
pub const GPIO_BSRR_BR4_Pos: u32 = 20;
pub const GPIO_BSRR_BR4_Msk: u32 = 1048576;
pub const GPIO_BSRR_BR4: u32 = 1048576;
pub const GPIO_BSRR_BR5_Pos: u32 = 21;
pub const GPIO_BSRR_BR5_Msk: u32 = 2097152;
pub const GPIO_BSRR_BR5: u32 = 2097152;
pub const GPIO_BSRR_BR6_Pos: u32 = 22;
pub const GPIO_BSRR_BR6_Msk: u32 = 4194304;
pub const GPIO_BSRR_BR6: u32 = 4194304;
pub const GPIO_BSRR_BR7_Pos: u32 = 23;
pub const GPIO_BSRR_BR7_Msk: u32 = 8388608;
pub const GPIO_BSRR_BR7: u32 = 8388608;
pub const GPIO_BSRR_BR8_Pos: u32 = 24;
pub const GPIO_BSRR_BR8_Msk: u32 = 16777216;
pub const GPIO_BSRR_BR8: u32 = 16777216;
pub const GPIO_BSRR_BR9_Pos: u32 = 25;
pub const GPIO_BSRR_BR9_Msk: u32 = 33554432;
pub const GPIO_BSRR_BR9: u32 = 33554432;
pub const GPIO_BSRR_BR10_Pos: u32 = 26;
pub const GPIO_BSRR_BR10_Msk: u32 = 67108864;
pub const GPIO_BSRR_BR10: u32 = 67108864;
pub const GPIO_BSRR_BR11_Pos: u32 = 27;
pub const GPIO_BSRR_BR11_Msk: u32 = 134217728;
pub const GPIO_BSRR_BR11: u32 = 134217728;
pub const GPIO_BSRR_BR12_Pos: u32 = 28;
pub const GPIO_BSRR_BR12_Msk: u32 = 268435456;
pub const GPIO_BSRR_BR12: u32 = 268435456;
pub const GPIO_BSRR_BR13_Pos: u32 = 29;
pub const GPIO_BSRR_BR13_Msk: u32 = 536870912;
pub const GPIO_BSRR_BR13: u32 = 536870912;
pub const GPIO_BSRR_BR14_Pos: u32 = 30;
pub const GPIO_BSRR_BR14_Msk: u32 = 1073741824;
pub const GPIO_BSRR_BR14: u32 = 1073741824;
pub const GPIO_BSRR_BR15_Pos: u32 = 31;
pub const GPIO_BSRR_BR15_Msk: u32 = 2147483648;
pub const GPIO_BSRR_BR15: u32 = 2147483648;
pub const GPIO_LCKR_LCK0_Pos: u32 = 0;
pub const GPIO_LCKR_LCK0_Msk: u32 = 1;
pub const GPIO_LCKR_LCK0: u32 = 1;
pub const GPIO_LCKR_LCK1_Pos: u32 = 1;
pub const GPIO_LCKR_LCK1_Msk: u32 = 2;
pub const GPIO_LCKR_LCK1: u32 = 2;
pub const GPIO_LCKR_LCK2_Pos: u32 = 2;
pub const GPIO_LCKR_LCK2_Msk: u32 = 4;
pub const GPIO_LCKR_LCK2: u32 = 4;
pub const GPIO_LCKR_LCK3_Pos: u32 = 3;
pub const GPIO_LCKR_LCK3_Msk: u32 = 8;
pub const GPIO_LCKR_LCK3: u32 = 8;
pub const GPIO_LCKR_LCK4_Pos: u32 = 4;
pub const GPIO_LCKR_LCK4_Msk: u32 = 16;
pub const GPIO_LCKR_LCK4: u32 = 16;
pub const GPIO_LCKR_LCK5_Pos: u32 = 5;
pub const GPIO_LCKR_LCK5_Msk: u32 = 32;
pub const GPIO_LCKR_LCK5: u32 = 32;
pub const GPIO_LCKR_LCK6_Pos: u32 = 6;
pub const GPIO_LCKR_LCK6_Msk: u32 = 64;
pub const GPIO_LCKR_LCK6: u32 = 64;
pub const GPIO_LCKR_LCK7_Pos: u32 = 7;
pub const GPIO_LCKR_LCK7_Msk: u32 = 128;
pub const GPIO_LCKR_LCK7: u32 = 128;
pub const GPIO_LCKR_LCK8_Pos: u32 = 8;
pub const GPIO_LCKR_LCK8_Msk: u32 = 256;
pub const GPIO_LCKR_LCK8: u32 = 256;
pub const GPIO_LCKR_LCK9_Pos: u32 = 9;
pub const GPIO_LCKR_LCK9_Msk: u32 = 512;
pub const GPIO_LCKR_LCK9: u32 = 512;
pub const GPIO_LCKR_LCK10_Pos: u32 = 10;
pub const GPIO_LCKR_LCK10_Msk: u32 = 1024;
pub const GPIO_LCKR_LCK10: u32 = 1024;
pub const GPIO_LCKR_LCK11_Pos: u32 = 11;
pub const GPIO_LCKR_LCK11_Msk: u32 = 2048;
pub const GPIO_LCKR_LCK11: u32 = 2048;
pub const GPIO_LCKR_LCK12_Pos: u32 = 12;
pub const GPIO_LCKR_LCK12_Msk: u32 = 4096;
pub const GPIO_LCKR_LCK12: u32 = 4096;
pub const GPIO_LCKR_LCK13_Pos: u32 = 13;
pub const GPIO_LCKR_LCK13_Msk: u32 = 8192;
pub const GPIO_LCKR_LCK13: u32 = 8192;
pub const GPIO_LCKR_LCK14_Pos: u32 = 14;
pub const GPIO_LCKR_LCK14_Msk: u32 = 16384;
pub const GPIO_LCKR_LCK14: u32 = 16384;
pub const GPIO_LCKR_LCK15_Pos: u32 = 15;
pub const GPIO_LCKR_LCK15_Msk: u32 = 32768;
pub const GPIO_LCKR_LCK15: u32 = 32768;
pub const GPIO_LCKR_LCKK_Pos: u32 = 16;
pub const GPIO_LCKR_LCKK_Msk: u32 = 65536;
pub const GPIO_LCKR_LCKK: u32 = 65536;
pub const GPIO_AFRL_AFSEL0_Pos: u32 = 0;
pub const GPIO_AFRL_AFSEL0_Msk: u32 = 15;
pub const GPIO_AFRL_AFSEL0: u32 = 15;
pub const GPIO_AFRL_AFSEL0_0: u32 = 1;
pub const GPIO_AFRL_AFSEL0_1: u32 = 2;
pub const GPIO_AFRL_AFSEL0_2: u32 = 4;
pub const GPIO_AFRL_AFSEL0_3: u32 = 8;
pub const GPIO_AFRL_AFSEL1_Pos: u32 = 4;
pub const GPIO_AFRL_AFSEL1_Msk: u32 = 240;
pub const GPIO_AFRL_AFSEL1: u32 = 240;
pub const GPIO_AFRL_AFSEL1_0: u32 = 16;
pub const GPIO_AFRL_AFSEL1_1: u32 = 32;
pub const GPIO_AFRL_AFSEL1_2: u32 = 64;
pub const GPIO_AFRL_AFSEL1_3: u32 = 128;
pub const GPIO_AFRL_AFSEL2_Pos: u32 = 8;
pub const GPIO_AFRL_AFSEL2_Msk: u32 = 3840;
pub const GPIO_AFRL_AFSEL2: u32 = 3840;
pub const GPIO_AFRL_AFSEL2_0: u32 = 256;
pub const GPIO_AFRL_AFSEL2_1: u32 = 512;
pub const GPIO_AFRL_AFSEL2_2: u32 = 1024;
pub const GPIO_AFRL_AFSEL2_3: u32 = 2048;
pub const GPIO_AFRL_AFSEL3_Pos: u32 = 12;
pub const GPIO_AFRL_AFSEL3_Msk: u32 = 61440;
pub const GPIO_AFRL_AFSEL3: u32 = 61440;
pub const GPIO_AFRL_AFSEL3_0: u32 = 4096;
pub const GPIO_AFRL_AFSEL3_1: u32 = 8192;
pub const GPIO_AFRL_AFSEL3_2: u32 = 16384;
pub const GPIO_AFRL_AFSEL3_3: u32 = 32768;
pub const GPIO_AFRL_AFSEL4_Pos: u32 = 16;
pub const GPIO_AFRL_AFSEL4_Msk: u32 = 983040;
pub const GPIO_AFRL_AFSEL4: u32 = 983040;
pub const GPIO_AFRL_AFSEL4_0: u32 = 65536;
pub const GPIO_AFRL_AFSEL4_1: u32 = 131072;
pub const GPIO_AFRL_AFSEL4_2: u32 = 262144;
pub const GPIO_AFRL_AFSEL4_3: u32 = 524288;
pub const GPIO_AFRL_AFSEL5_Pos: u32 = 20;
pub const GPIO_AFRL_AFSEL5_Msk: u32 = 15728640;
pub const GPIO_AFRL_AFSEL5: u32 = 15728640;
pub const GPIO_AFRL_AFSEL5_0: u32 = 1048576;
pub const GPIO_AFRL_AFSEL5_1: u32 = 2097152;
pub const GPIO_AFRL_AFSEL5_2: u32 = 4194304;
pub const GPIO_AFRL_AFSEL5_3: u32 = 8388608;
pub const GPIO_AFRL_AFSEL6_Pos: u32 = 24;
pub const GPIO_AFRL_AFSEL6_Msk: u32 = 251658240;
pub const GPIO_AFRL_AFSEL6: u32 = 251658240;
pub const GPIO_AFRL_AFSEL6_0: u32 = 16777216;
pub const GPIO_AFRL_AFSEL6_1: u32 = 33554432;
pub const GPIO_AFRL_AFSEL6_2: u32 = 67108864;
pub const GPIO_AFRL_AFSEL6_3: u32 = 134217728;
pub const GPIO_AFRL_AFSEL7_Pos: u32 = 28;
pub const GPIO_AFRL_AFSEL7_Msk: u32 = 4026531840;
pub const GPIO_AFRL_AFSEL7: u32 = 4026531840;
pub const GPIO_AFRL_AFSEL7_0: u32 = 268435456;
pub const GPIO_AFRL_AFSEL7_1: u32 = 536870912;
pub const GPIO_AFRL_AFSEL7_2: u32 = 1073741824;
pub const GPIO_AFRL_AFSEL7_3: u32 = 2147483648;
pub const GPIO_AFRH_AFSEL8_Pos: u32 = 0;
pub const GPIO_AFRH_AFSEL8_Msk: u32 = 15;
pub const GPIO_AFRH_AFSEL8: u32 = 15;
pub const GPIO_AFRH_AFSEL8_0: u32 = 1;
pub const GPIO_AFRH_AFSEL8_1: u32 = 2;
pub const GPIO_AFRH_AFSEL8_2: u32 = 4;
pub const GPIO_AFRH_AFSEL8_3: u32 = 8;
pub const GPIO_AFRH_AFSEL9_Pos: u32 = 4;
pub const GPIO_AFRH_AFSEL9_Msk: u32 = 240;
pub const GPIO_AFRH_AFSEL9: u32 = 240;
pub const GPIO_AFRH_AFSEL9_0: u32 = 16;
pub const GPIO_AFRH_AFSEL9_1: u32 = 32;
pub const GPIO_AFRH_AFSEL9_2: u32 = 64;
pub const GPIO_AFRH_AFSEL9_3: u32 = 128;
pub const GPIO_AFRH_AFSEL10_Pos: u32 = 8;
pub const GPIO_AFRH_AFSEL10_Msk: u32 = 3840;
pub const GPIO_AFRH_AFSEL10: u32 = 3840;
pub const GPIO_AFRH_AFSEL10_0: u32 = 256;
pub const GPIO_AFRH_AFSEL10_1: u32 = 512;
pub const GPIO_AFRH_AFSEL10_2: u32 = 1024;
pub const GPIO_AFRH_AFSEL10_3: u32 = 2048;
pub const GPIO_AFRH_AFSEL11_Pos: u32 = 12;
pub const GPIO_AFRH_AFSEL11_Msk: u32 = 61440;
pub const GPIO_AFRH_AFSEL11: u32 = 61440;
pub const GPIO_AFRH_AFSEL11_0: u32 = 4096;
pub const GPIO_AFRH_AFSEL11_1: u32 = 8192;
pub const GPIO_AFRH_AFSEL11_2: u32 = 16384;
pub const GPIO_AFRH_AFSEL11_3: u32 = 32768;
pub const GPIO_AFRH_AFSEL12_Pos: u32 = 16;
pub const GPIO_AFRH_AFSEL12_Msk: u32 = 983040;
pub const GPIO_AFRH_AFSEL12: u32 = 983040;
pub const GPIO_AFRH_AFSEL12_0: u32 = 65536;
pub const GPIO_AFRH_AFSEL12_1: u32 = 131072;
pub const GPIO_AFRH_AFSEL12_2: u32 = 262144;
pub const GPIO_AFRH_AFSEL12_3: u32 = 524288;
pub const GPIO_AFRH_AFSEL13_Pos: u32 = 20;
pub const GPIO_AFRH_AFSEL13_Msk: u32 = 15728640;
pub const GPIO_AFRH_AFSEL13: u32 = 15728640;
pub const GPIO_AFRH_AFSEL13_0: u32 = 1048576;
pub const GPIO_AFRH_AFSEL13_1: u32 = 2097152;
pub const GPIO_AFRH_AFSEL13_2: u32 = 4194304;
pub const GPIO_AFRH_AFSEL13_3: u32 = 8388608;
pub const GPIO_AFRH_AFSEL14_Pos: u32 = 24;
pub const GPIO_AFRH_AFSEL14_Msk: u32 = 251658240;
pub const GPIO_AFRH_AFSEL14: u32 = 251658240;
pub const GPIO_AFRH_AFSEL14_0: u32 = 16777216;
pub const GPIO_AFRH_AFSEL14_1: u32 = 33554432;
pub const GPIO_AFRH_AFSEL14_2: u32 = 67108864;
pub const GPIO_AFRH_AFSEL14_3: u32 = 134217728;
pub const GPIO_AFRH_AFSEL15_Pos: u32 = 28;
pub const GPIO_AFRH_AFSEL15_Msk: u32 = 4026531840;
pub const GPIO_AFRH_AFSEL15: u32 = 4026531840;
pub const GPIO_AFRH_AFSEL15_0: u32 = 268435456;
pub const GPIO_AFRH_AFSEL15_1: u32 = 536870912;
pub const GPIO_AFRH_AFSEL15_2: u32 = 1073741824;
pub const GPIO_AFRH_AFSEL15_3: u32 = 2147483648;
pub const GPIO_BRR_BR0_Pos: u32 = 0;
pub const GPIO_BRR_BR0_Msk: u32 = 1;
pub const GPIO_BRR_BR0: u32 = 1;
pub const GPIO_BRR_BR1_Pos: u32 = 1;
pub const GPIO_BRR_BR1_Msk: u32 = 2;
pub const GPIO_BRR_BR1: u32 = 2;
pub const GPIO_BRR_BR2_Pos: u32 = 2;
pub const GPIO_BRR_BR2_Msk: u32 = 4;
pub const GPIO_BRR_BR2: u32 = 4;
pub const GPIO_BRR_BR3_Pos: u32 = 3;
pub const GPIO_BRR_BR3_Msk: u32 = 8;
pub const GPIO_BRR_BR3: u32 = 8;
pub const GPIO_BRR_BR4_Pos: u32 = 4;
pub const GPIO_BRR_BR4_Msk: u32 = 16;
pub const GPIO_BRR_BR4: u32 = 16;
pub const GPIO_BRR_BR5_Pos: u32 = 5;
pub const GPIO_BRR_BR5_Msk: u32 = 32;
pub const GPIO_BRR_BR5: u32 = 32;
pub const GPIO_BRR_BR6_Pos: u32 = 6;
pub const GPIO_BRR_BR6_Msk: u32 = 64;
pub const GPIO_BRR_BR6: u32 = 64;
pub const GPIO_BRR_BR7_Pos: u32 = 7;
pub const GPIO_BRR_BR7_Msk: u32 = 128;
pub const GPIO_BRR_BR7: u32 = 128;
pub const GPIO_BRR_BR8_Pos: u32 = 8;
pub const GPIO_BRR_BR8_Msk: u32 = 256;
pub const GPIO_BRR_BR8: u32 = 256;
pub const GPIO_BRR_BR9_Pos: u32 = 9;
pub const GPIO_BRR_BR9_Msk: u32 = 512;
pub const GPIO_BRR_BR9: u32 = 512;
pub const GPIO_BRR_BR10_Pos: u32 = 10;
pub const GPIO_BRR_BR10_Msk: u32 = 1024;
pub const GPIO_BRR_BR10: u32 = 1024;
pub const GPIO_BRR_BR11_Pos: u32 = 11;
pub const GPIO_BRR_BR11_Msk: u32 = 2048;
pub const GPIO_BRR_BR11: u32 = 2048;
pub const GPIO_BRR_BR12_Pos: u32 = 12;
pub const GPIO_BRR_BR12_Msk: u32 = 4096;
pub const GPIO_BRR_BR12: u32 = 4096;
pub const GPIO_BRR_BR13_Pos: u32 = 13;
pub const GPIO_BRR_BR13_Msk: u32 = 8192;
pub const GPIO_BRR_BR13: u32 = 8192;
pub const GPIO_BRR_BR14_Pos: u32 = 14;
pub const GPIO_BRR_BR14_Msk: u32 = 16384;
pub const GPIO_BRR_BR14: u32 = 16384;
pub const GPIO_BRR_BR15_Pos: u32 = 15;
pub const GPIO_BRR_BR15_Msk: u32 = 32768;
pub const GPIO_BRR_BR15: u32 = 32768;
pub const I2C_CR1_PE_Pos: u32 = 0;
pub const I2C_CR1_PE_Msk: u32 = 1;
pub const I2C_CR1_PE: u32 = 1;
pub const I2C_CR1_ENGC_Pos: u32 = 6;
pub const I2C_CR1_ENGC_Msk: u32 = 64;
pub const I2C_CR1_ENGC: u32 = 64;
pub const I2C_CR1_NOSTRETCH_Pos: u32 = 7;
pub const I2C_CR1_NOSTRETCH_Msk: u32 = 128;
pub const I2C_CR1_NOSTRETCH: u32 = 128;
pub const I2C_CR1_START_Pos: u32 = 8;
pub const I2C_CR1_START_Msk: u32 = 256;
pub const I2C_CR1_START: u32 = 256;
pub const I2C_CR1_STOP_Pos: u32 = 9;
pub const I2C_CR1_STOP_Msk: u32 = 512;
pub const I2C_CR1_STOP: u32 = 512;
pub const I2C_CR1_ACK_Pos: u32 = 10;
pub const I2C_CR1_ACK_Msk: u32 = 1024;
pub const I2C_CR1_ACK: u32 = 1024;
pub const I2C_CR1_POS_Pos: u32 = 11;
pub const I2C_CR1_POS_Msk: u32 = 2048;
pub const I2C_CR1_POS: u32 = 2048;
pub const I2C_CR1_SWRST_Pos: u32 = 15;
pub const I2C_CR1_SWRST_Msk: u32 = 32768;
pub const I2C_CR1_SWRST: u32 = 32768;
pub const I2C_CR2_FREQ_Pos: u32 = 0;
pub const I2C_CR2_FREQ_Msk: u32 = 63;
pub const I2C_CR2_FREQ: u32 = 63;
pub const I2C_CR2_FREQ_0: u32 = 1;
pub const I2C_CR2_FREQ_1: u32 = 2;
pub const I2C_CR2_FREQ_2: u32 = 4;
pub const I2C_CR2_FREQ_3: u32 = 8;
pub const I2C_CR2_FREQ_4: u32 = 16;
pub const I2C_CR2_FREQ_5: u32 = 32;
pub const I2C_CR2_ITERREN_Pos: u32 = 8;
pub const I2C_CR2_ITERREN_Msk: u32 = 256;
pub const I2C_CR2_ITERREN: u32 = 256;
pub const I2C_CR2_ITEVTEN_Pos: u32 = 9;
pub const I2C_CR2_ITEVTEN_Msk: u32 = 512;
pub const I2C_CR2_ITEVTEN: u32 = 512;
pub const I2C_CR2_ITBUFEN_Pos: u32 = 10;
pub const I2C_CR2_ITBUFEN_Msk: u32 = 1024;
pub const I2C_CR2_ITBUFEN: u32 = 1024;
pub const I2C_CR2_DMAEN_Pos: u32 = 11;
pub const I2C_CR2_DMAEN_Msk: u32 = 2048;
pub const I2C_CR2_DMAEN: u32 = 2048;
pub const I2C_CR2_LAST_Pos: u32 = 12;
pub const I2C_CR2_LAST_Msk: u32 = 4096;
pub const I2C_CR2_LAST: u32 = 4096;
pub const I2C_OAR1_ADD1_7: u32 = 254;
pub const I2C_OAR1_ADD1_Pos: u32 = 1;
pub const I2C_OAR1_ADD1_Msk: u32 = 2;
pub const I2C_OAR1_ADD1: u32 = 2;
pub const I2C_OAR1_ADD2_Pos: u32 = 2;
pub const I2C_OAR1_ADD2_Msk: u32 = 4;
pub const I2C_OAR1_ADD2: u32 = 4;
pub const I2C_OAR1_ADD3_Pos: u32 = 3;
pub const I2C_OAR1_ADD3_Msk: u32 = 8;
pub const I2C_OAR1_ADD3: u32 = 8;
pub const I2C_OAR1_ADD4_Pos: u32 = 4;
pub const I2C_OAR1_ADD4_Msk: u32 = 16;
pub const I2C_OAR1_ADD4: u32 = 16;
pub const I2C_OAR1_ADD5_Pos: u32 = 5;
pub const I2C_OAR1_ADD5_Msk: u32 = 32;
pub const I2C_OAR1_ADD5: u32 = 32;
pub const I2C_OAR1_ADD6_Pos: u32 = 6;
pub const I2C_OAR1_ADD6_Msk: u32 = 64;
pub const I2C_OAR1_ADD6: u32 = 64;
pub const I2C_OAR1_ADD7_Pos: u32 = 7;
pub const I2C_OAR1_ADD7_Msk: u32 = 128;
pub const I2C_OAR1_ADD7: u32 = 128;
pub const I2C_DR_DR_Pos: u32 = 0;
pub const I2C_DR_DR_Msk: u32 = 255;
pub const I2C_DR_DR: u32 = 255;
pub const I2C_DR_DR_0: u32 = 1;
pub const I2C_DR_DR_1: u32 = 2;
pub const I2C_DR_DR_2: u32 = 4;
pub const I2C_DR_DR_3: u32 = 8;
pub const I2C_DR_DR_4: u32 = 16;
pub const I2C_DR_DR_5: u32 = 32;
pub const I2C_DR_DR_6: u32 = 64;
pub const I2C_DR_DR_7: u32 = 128;
pub const I2C_SR1_SB_Pos: u32 = 0;
pub const I2C_SR1_SB_Msk: u32 = 1;
pub const I2C_SR1_SB: u32 = 1;
pub const I2C_SR1_ADDR_Pos: u32 = 1;
pub const I2C_SR1_ADDR_Msk: u32 = 2;
pub const I2C_SR1_ADDR: u32 = 2;
pub const I2C_SR1_BTF_Pos: u32 = 2;
pub const I2C_SR1_BTF_Msk: u32 = 4;
pub const I2C_SR1_BTF: u32 = 4;
pub const I2C_SR1_STOPF_Pos: u32 = 4;
pub const I2C_SR1_STOPF_Msk: u32 = 16;
pub const I2C_SR1_STOPF: u32 = 16;
pub const I2C_SR1_RXNE_Pos: u32 = 6;
pub const I2C_SR1_RXNE_Msk: u32 = 64;
pub const I2C_SR1_RXNE: u32 = 64;
pub const I2C_SR1_TXE_Pos: u32 = 7;
pub const I2C_SR1_TXE_Msk: u32 = 128;
pub const I2C_SR1_TXE: u32 = 128;
pub const I2C_SR1_BERR_Pos: u32 = 8;
pub const I2C_SR1_BERR_Msk: u32 = 256;
pub const I2C_SR1_BERR: u32 = 256;
pub const I2C_SR1_ARLO_Pos: u32 = 9;
pub const I2C_SR1_ARLO_Msk: u32 = 512;
pub const I2C_SR1_ARLO: u32 = 512;
pub const I2C_SR1_AF_Pos: u32 = 10;
pub const I2C_SR1_AF_Msk: u32 = 1024;
pub const I2C_SR1_AF: u32 = 1024;
pub const I2C_SR1_OVR_Pos: u32 = 11;
pub const I2C_SR1_OVR_Msk: u32 = 2048;
pub const I2C_SR1_OVR: u32 = 2048;
pub const I2C_SR1_PECERR_Pos: u32 = 12;
pub const I2C_SR1_PECERR_Msk: u32 = 4096;
pub const I2C_SR1_PECERR: u32 = 4096;
pub const I2C_SR2_MSL_Pos: u32 = 0;
pub const I2C_SR2_MSL_Msk: u32 = 1;
pub const I2C_SR2_MSL: u32 = 1;
pub const I2C_SR2_BUSY_Pos: u32 = 1;
pub const I2C_SR2_BUSY_Msk: u32 = 2;
pub const I2C_SR2_BUSY: u32 = 2;
pub const I2C_SR2_TRA_Pos: u32 = 2;
pub const I2C_SR2_TRA_Msk: u32 = 4;
pub const I2C_SR2_TRA: u32 = 4;
pub const I2C_SR2_GENCALL_Pos: u32 = 4;
pub const I2C_SR2_GENCALL_Msk: u32 = 16;
pub const I2C_SR2_GENCALL: u32 = 16;
pub const I2C_SR2_PEC_Pos: u32 = 8;
pub const I2C_SR2_PEC_Msk: u32 = 65280;
pub const I2C_SR2_PEC: u32 = 65280;
pub const I2C_CCR_CCR_Pos: u32 = 0;
pub const I2C_CCR_CCR_Msk: u32 = 4095;
pub const I2C_CCR_CCR: u32 = 4095;
pub const I2C_CCR_DUTY_Pos: u32 = 14;
pub const I2C_CCR_DUTY_Msk: u32 = 16384;
pub const I2C_CCR_DUTY: u32 = 16384;
pub const I2C_CCR_FS_Pos: u32 = 15;
pub const I2C_CCR_FS_Msk: u32 = 32768;
pub const I2C_CCR_FS: u32 = 32768;
pub const I2C_TRISE_TRISE_Pos: u32 = 0;
pub const I2C_TRISE_TRISE_Msk: u32 = 63;
pub const I2C_TRISE_TRISE: u32 = 63;
pub const IWDG_KR_KEY_Pos: u32 = 0;
pub const IWDG_KR_KEY_Msk: u32 = 65535;
pub const IWDG_KR_KEY: u32 = 65535;
pub const IWDG_PR_PR_Pos: u32 = 0;
pub const IWDG_PR_PR_Msk: u32 = 7;
pub const IWDG_PR_PR: u32 = 7;
pub const IWDG_PR_PR_0: u32 = 1;
pub const IWDG_PR_PR_1: u32 = 2;
pub const IWDG_PR_PR_2: u32 = 4;
pub const IWDG_RLR_RL_Pos: u32 = 0;
pub const IWDG_RLR_RL_Msk: u32 = 4095;
pub const IWDG_RLR_RL: u32 = 4095;
pub const IWDG_SR_PVU_Pos: u32 = 0;
pub const IWDG_SR_PVU_Msk: u32 = 1;
pub const IWDG_SR_PVU: u32 = 1;
pub const IWDG_SR_RVU_Pos: u32 = 1;
pub const IWDG_SR_RVU_Msk: u32 = 2;
pub const IWDG_SR_RVU: u32 = 2;
pub const LED_CR_LEDON_Pos: u32 = 0;
pub const LED_CR_LEDON_Msk: u32 = 1;
pub const LED_CR_LEDON: u32 = 1;
pub const LED_CR_LED_COM_SEL_Pos: u32 = 1;
pub const LED_CR_LED_COM_SEL_Msk: u32 = 6;
pub const LED_CR_LED_COM_SEL: u32 = 6;
pub const LED_CR_LED_COM_SEL_0: u32 = 2;
pub const LED_CR_LED_COM_SEL_1: u32 = 4;
pub const LED_CR_IE_Pos: u32 = 3;
pub const LED_CR_IE_Msk: u32 = 8;
pub const LED_CR_IE: u32 = 8;
pub const LED_CR_EHS_Pos: u32 = 12;
pub const LED_CR_EHS_Msk: u32 = 4096;
pub const LED_CR_EHS: u32 = 4096;
pub const LED_PR_PR_Pos: u32 = 0;
pub const LED_PR_PR_Msk: u32 = 255;
pub const LED_PR_PR: u32 = 255;
pub const LED_PR_PR_0: u32 = 1;
pub const LED_PR_PR_1: u32 = 2;
pub const LED_PR_PR_2: u32 = 4;
pub const LED_PR_PR_3: u32 = 8;
pub const LED_PR_PR_4: u32 = 16;
pub const LED_PR_PR_5: u32 = 32;
pub const LED_PR_PR_6: u32 = 64;
pub const LED_PR_PR_7: u32 = 128;
pub const LED_TR_T1_Pos: u32 = 0;
pub const LED_TR_T1_Msk: u32 = 255;
pub const LED_TR_T1: u32 = 255;
pub const LED_TR_T1_0: u32 = 1;
pub const LED_TR_T1_1: u32 = 2;
pub const LED_TR_T1_2: u32 = 4;
pub const LED_TR_T1_3: u32 = 8;
pub const LED_TR_T1_4: u32 = 16;
pub const LED_TR_T1_5: u32 = 32;
pub const LED_TR_T1_6: u32 = 64;
pub const LED_TR_T1_7: u32 = 128;
pub const LED_TR_T2_Pos: u32 = 8;
pub const LED_TR_T2_Msk: u32 = 65280;
pub const LED_TR_T2: u32 = 65280;
pub const LED_TR_T2_0: u32 = 256;
pub const LED_TR_T2_1: u32 = 512;
pub const LED_TR_T2_2: u32 = 1024;
pub const LED_TR_T2_3: u32 = 2048;
pub const LED_TR_T2_4: u32 = 4096;
pub const LED_TR_T2_5: u32 = 8192;
pub const LED_TR_T2_6: u32 = 16384;
pub const LED_TR_T2_7: u32 = 32768;
pub const LED_DR0_DATA0_Pos: u32 = 0;
pub const LED_DR0_DATA0_Msk: u32 = 255;
pub const LED_DR0_DATA0: u32 = 255;
pub const LED_DR0_DATA0_A: u32 = 1;
pub const LED_DR0_DATA0_B: u32 = 2;
pub const LED_DR0_DATA0_C: u32 = 4;
pub const LED_DR0_DATA0_D: u32 = 8;
pub const LED_DR0_DATA0_E: u32 = 16;
pub const LED_DR0_DATA0_F: u32 = 32;
pub const LED_DR0_DATA0_G: u32 = 64;
pub const LED_DR0_DATA0_DP: u32 = 128;
pub const LED_DR1_DATA1_Pos: u32 = 0;
pub const LED_DR1_DATA1_Msk: u32 = 255;
pub const LED_DR1_DATA1: u32 = 255;
pub const LED_DR1_DATA1_A: u32 = 1;
pub const LED_DR1_DATA1_B: u32 = 2;
pub const LED_DR1_DATA1_C: u32 = 4;
pub const LED_DR1_DATA1_D: u32 = 8;
pub const LED_DR1_DATA1_E: u32 = 16;
pub const LED_DR1_DATA1_F: u32 = 32;
pub const LED_DR1_DATA1_G: u32 = 64;
pub const LED_DR1_DATA1_DP: u32 = 128;
pub const LED_DR2_DATA2_Pos: u32 = 0;
pub const LED_DR2_DATA2_Msk: u32 = 255;
pub const LED_DR2_DATA2: u32 = 255;
pub const LED_DR2_DATA2_A: u32 = 1;
pub const LED_DR2_DATA2_B: u32 = 2;
pub const LED_DR2_DATA2_C: u32 = 4;
pub const LED_DR2_DATA2_D: u32 = 8;
pub const LED_DR2_DATA2_E: u32 = 16;
pub const LED_DR2_DATA2_F: u32 = 32;
pub const LED_DR2_DATA2_G: u32 = 64;
pub const LED_DR2_DATA2_DP: u32 = 128;
pub const LED_DR3_DATA3_Pos: u32 = 0;
pub const LED_DR3_DATA3_Msk: u32 = 255;
pub const LED_DR3_DATA3: u32 = 255;
pub const LED_DR3_DATA3_A: u32 = 1;
pub const LED_DR3_DATA3_B: u32 = 2;
pub const LED_DR3_DATA3_C: u32 = 4;
pub const LED_DR3_DATA3_D: u32 = 8;
pub const LED_DR3_DATA3_E: u32 = 16;
pub const LED_DR3_DATA3_F: u32 = 32;
pub const LED_DR3_DATA3_G: u32 = 64;
pub const LED_DR3_DATA3_DP: u32 = 128;
pub const LED_IR_FLAG_Pos: u32 = 0;
pub const LED_IR_FLAG_Msk: u32 = 1;
pub const LED_IR_FLAG: u32 = 1;
pub const PWR_CR1_BIAS_CR_Pos: u32 = 0;
pub const PWR_CR1_BIAS_CR_Msk: u32 = 15;
pub const PWR_CR1_BIAS_CR: u32 = 15;
pub const PWR_CR1_BIAS_CR_0: u32 = 1;
pub const PWR_CR1_BIAS_CR_1: u32 = 2;
pub const PWR_CR1_BIAS_CR_2: u32 = 4;
pub const PWR_CR1_BIAS_CR_3: u32 = 8;
pub const PWR_CR1_BIAS_CR_SEL_Pos: u32 = 4;
pub const PWR_CR1_BIAS_CR_SEL_Msk: u32 = 16;
pub const PWR_CR1_BIAS_CR_SEL: u32 = 16;
pub const PWR_CR1_DBP_Pos: u32 = 8;
pub const PWR_CR1_DBP_Msk: u32 = 256;
pub const PWR_CR1_DBP: u32 = 256;
pub const PWR_CR1_VOS_Pos: u32 = 9;
pub const PWR_CR1_VOS_Msk: u32 = 512;
pub const PWR_CR1_VOS: u32 = 512;
pub const PWR_CR1_MRRDY_TIME_Pos: u32 = 10;
pub const PWR_CR1_MRRDY_TIME_Msk: u32 = 3072;
pub const PWR_CR1_MRRDY_TIME: u32 = 3072;
pub const PWR_CR1_MRRDY_TIME_0: u32 = 1024;
pub const PWR_CR1_MRRDY_TIME_1: u32 = 2048;
pub const PWR_CR1_FLS_SLPTIME_Pos: u32 = 12;
pub const PWR_CR1_FLS_SLPTIME_Msk: u32 = 12288;
pub const PWR_CR1_FLS_SLPTIME: u32 = 12288;
pub const PWR_CR1_FLS_SLPTIME_0: u32 = 4096;
pub const PWR_CR1_FLS_SLPTIME_1: u32 = 8192;
pub const PWR_CR1_LPR_Pos: u32 = 14;
pub const PWR_CR1_LPR_Msk: u32 = 16384;
pub const PWR_CR1_LPR: u32 = 16384;
pub const PWR_CR1_SRAM_RETV_Pos: u32 = 16;
pub const PWR_CR1_SRAM_RETV_Msk: u32 = 458752;
pub const PWR_CR1_SRAM_RETV: u32 = 458752;
pub const PWR_CR1_SRAM_RETV_0: u32 = 65536;
pub const PWR_CR1_SRAM_RETV_1: u32 = 131072;
pub const PWR_CR1_SRAM_RETV_2: u32 = 262144;
pub const PWR_CR1_HSION_CTRL_Pos: u32 = 19;
pub const PWR_CR1_HSION_CTRL_Msk: u32 = 524288;
pub const PWR_CR1_HSION_CTRL: u32 = 524288;
pub const PWR_CR2_PVDE_Pos: u32 = 0;
pub const PWR_CR2_PVDE_Msk: u32 = 1;
pub const PWR_CR2_PVDE: u32 = 1;
pub const PWR_CR2_SRCSEL_Pos: u32 = 2;
pub const PWR_CR2_SRCSEL_Msk: u32 = 4;
pub const PWR_CR2_SRCSEL: u32 = 4;
pub const PWR_CR2_PVDT_Pos: u32 = 4;
pub const PWR_CR2_PVDT_Msk: u32 = 112;
pub const PWR_CR2_PVDT: u32 = 112;
pub const PWR_CR2_PVDT_0: u32 = 16;
pub const PWR_CR2_PVDT_1: u32 = 32;
pub const PWR_CR2_PVDT_2: u32 = 64;
pub const PWR_CR2_FLTEN_Pos: u32 = 8;
pub const PWR_CR2_FLTEN_Msk: u32 = 256;
pub const PWR_CR2_FLTEN: u32 = 256;
pub const PWR_CR2_FLT_TIME_Pos: u32 = 9;
pub const PWR_CR2_FLT_TIME_Msk: u32 = 3584;
pub const PWR_CR2_FLT_TIME: u32 = 3584;
pub const PWR_CR2_FLT_TIME_0: u32 = 512;
pub const PWR_CR2_FLT_TIME_1: u32 = 1024;
pub const PWR_CR2_FLT_TIME_2: u32 = 2048;
pub const PWR_SR_PVDO_Pos: u32 = 11;
pub const PWR_SR_PVDO_Msk: u32 = 2048;
pub const PWR_SR_PVDO: u32 = 2048;
pub const RCC_CR_HSION_Pos: u32 = 8;
pub const RCC_CR_HSION_Msk: u32 = 256;
pub const RCC_CR_HSION: u32 = 256;
pub const RCC_CR_HSIRDY_Pos: u32 = 10;
pub const RCC_CR_HSIRDY_Msk: u32 = 1024;
pub const RCC_CR_HSIRDY: u32 = 1024;
pub const RCC_CR_HSIDIV_Pos: u32 = 11;
pub const RCC_CR_HSIDIV_Msk: u32 = 14336;
pub const RCC_CR_HSIDIV: u32 = 14336;
pub const RCC_CR_HSIDIV_0: u32 = 2048;
pub const RCC_CR_HSIDIV_1: u32 = 4096;
pub const RCC_CR_HSIDIV_2: u32 = 8192;
pub const RCC_CR_HSEON_Pos: u32 = 16;
pub const RCC_CR_HSEON_Msk: u32 = 65536;
pub const RCC_CR_HSEON: u32 = 65536;
pub const RCC_CR_HSERDY_Pos: u32 = 17;
pub const RCC_CR_HSERDY_Msk: u32 = 131072;
pub const RCC_CR_HSERDY: u32 = 131072;
pub const RCC_CR_HSEBYP_Pos: u32 = 18;
pub const RCC_CR_HSEBYP_Msk: u32 = 262144;
pub const RCC_CR_HSEBYP: u32 = 262144;
pub const RCC_CR_CSSON_Pos: u32 = 19;
pub const RCC_CR_CSSON_Msk: u32 = 524288;
pub const RCC_CR_CSSON: u32 = 524288;
pub const RCC_CR_PLLON_Pos: u32 = 24;
pub const RCC_CR_PLLON_Msk: u32 = 16777216;
pub const RCC_CR_PLLON: u32 = 16777216;
pub const RCC_CR_PLLRDY_Pos: u32 = 25;
pub const RCC_CR_PLLRDY_Msk: u32 = 33554432;
pub const RCC_CR_PLLRDY: u32 = 33554432;
pub const RCC_ICSCR_HSI_TRIM_Pos: u32 = 0;
pub const RCC_ICSCR_HSI_TRIM_Msk: u32 = 8191;
pub const RCC_ICSCR_HSI_TRIM: u32 = 8191;
pub const RCC_ICSCR_HSI_TRIM_0: u32 = 1;
pub const RCC_ICSCR_HSI_TRIM_1: u32 = 2;
pub const RCC_ICSCR_HSI_TRIM_2: u32 = 4;
pub const RCC_ICSCR_HSI_TRIM_3: u32 = 8;
pub const RCC_ICSCR_HSI_TRIM_4: u32 = 16;
pub const RCC_ICSCR_HSI_TRIM_5: u32 = 32;
pub const RCC_ICSCR_HSI_TRIM_6: u32 = 64;
pub const RCC_ICSCR_HSI_TRIM_7: u32 = 128;
pub const RCC_ICSCR_HSI_TRIM_8: u32 = 256;
pub const RCC_ICSCR_HSI_TRIM_9: u32 = 512;
pub const RCC_ICSCR_HSI_TRIM_10: u32 = 1024;
pub const RCC_ICSCR_HSI_TRIM_11: u32 = 2048;
pub const RCC_ICSCR_HSI_TRIM_12: u32 = 4096;
pub const RCC_ICSCR_HSI_FS_Pos: u32 = 13;
pub const RCC_ICSCR_HSI_FS_Msk: u32 = 57344;
pub const RCC_ICSCR_HSI_FS: u32 = 57344;
pub const RCC_ICSCR_HSI_FS_0: u32 = 8192;
pub const RCC_ICSCR_HSI_FS_1: u32 = 16384;
pub const RCC_ICSCR_HSI_FS_2: u32 = 32768;
pub const RCC_ICSCR_LSI_TRIM_Pos: u32 = 16;
pub const RCC_ICSCR_LSI_TRIM_Msk: u32 = 33488896;
pub const RCC_ICSCR_LSI_TRIM: u32 = 33488896;
pub const RCC_ICSCR_LSI_TRIM_0: u32 = 65536;
pub const RCC_ICSCR_LSI_TRIM_1: u32 = 131072;
pub const RCC_ICSCR_LSI_TRIM_2: u32 = 262144;
pub const RCC_ICSCR_LSI_TRIM_3: u32 = 524288;
pub const RCC_ICSCR_LSI_TRIM_4: u32 = 1048576;
pub const RCC_ICSCR_LSI_TRIM_5: u32 = 2097152;
pub const RCC_ICSCR_LSI_TRIM_6: u32 = 4194304;
pub const RCC_ICSCR_LSI_TRIM_7: u32 = 8388608;
pub const RCC_ICSCR_LSI_TRIM_8: u32 = 16777216;
pub const RCC_ICSCR_LSI_STARTUP_Pos: u32 = 26;
pub const RCC_ICSCR_LSI_STARTUP_Msk: u32 = 201326592;
pub const RCC_ICSCR_LSI_STARTUP: u32 = 201326592;
pub const RCC_ICSCR_LSI_STARTUP_0: u32 = 67108864;
pub const RCC_ICSCR_LSI_STARTUP_1: u32 = 134217728;
pub const RCC_CFGR_SW_Pos: u32 = 0;
pub const RCC_CFGR_SW_Msk: u32 = 7;
pub const RCC_CFGR_SW: u32 = 7;
pub const RCC_CFGR_SW_0: u32 = 1;
pub const RCC_CFGR_SW_1: u32 = 2;
pub const RCC_CFGR_SW_2: u32 = 4;
pub const RCC_CFGR_SWS_Pos: u32 = 3;
pub const RCC_CFGR_SWS_Msk: u32 = 56;
pub const RCC_CFGR_SWS: u32 = 56;
pub const RCC_CFGR_SWS_0: u32 = 8;
pub const RCC_CFGR_SWS_1: u32 = 16;
pub const RCC_CFGR_SWS_2: u32 = 32;
pub const RCC_CFGR_SWS_HSI: u32 = 0;
pub const RCC_CFGR_SWS_HSE: u32 = 8;
pub const RCC_CFGR_SWS_PLL: u32 = 16;
pub const RCC_CFGR_SWS_LSI: u32 = 24;
pub const RCC_CFGR_SWS_LSE: u32 = 32;
pub const RCC_CFGR_HPRE_Pos: u32 = 8;
pub const RCC_CFGR_HPRE_Msk: u32 = 3840;
pub const RCC_CFGR_HPRE: u32 = 3840;
pub const RCC_CFGR_HPRE_0: u32 = 256;
pub const RCC_CFGR_HPRE_1: u32 = 512;
pub const RCC_CFGR_HPRE_2: u32 = 1024;
pub const RCC_CFGR_HPRE_3: u32 = 2048;
pub const RCC_CFGR_PPRE_Pos: u32 = 12;
pub const RCC_CFGR_PPRE_Msk: u32 = 28672;
pub const RCC_CFGR_PPRE: u32 = 28672;
pub const RCC_CFGR_PPRE_0: u32 = 4096;
pub const RCC_CFGR_PPRE_1: u32 = 8192;
pub const RCC_CFGR_PPRE_2: u32 = 16384;
pub const RCC_CFGR_MCOSEL_Pos: u32 = 24;
pub const RCC_CFGR_MCOSEL_Msk: u32 = 117440512;
pub const RCC_CFGR_MCOSEL: u32 = 117440512;
pub const RCC_CFGR_MCOSEL_0: u32 = 16777216;
pub const RCC_CFGR_MCOSEL_1: u32 = 33554432;
pub const RCC_CFGR_MCOSEL_2: u32 = 67108864;
pub const RCC_CFGR_MCOPRE_Pos: u32 = 28;
pub const RCC_CFGR_MCOPRE_Msk: u32 = 1879048192;
pub const RCC_CFGR_MCOPRE: u32 = 1879048192;
pub const RCC_CFGR_MCOPRE_0: u32 = 268435456;
pub const RCC_CFGR_MCOPRE_1: u32 = 536870912;
pub const RCC_CFGR_MCOPRE_2: u32 = 1073741824;
pub const RCC_PLLCFGR_PLLSRC_Pos: u32 = 0;
pub const RCC_PLLCFGR_PLLSRC_Msk: u32 = 1;
pub const RCC_PLLCFGR_PLLSRC: u32 = 1;
pub const RCC_PLLCFGR_PLLSRC_NONE: u32 = 0;
pub const RCC_PLLCFGR_PLLSRC_HSI_Pos: u32 = 0;
pub const RCC_PLLCFGR_PLLSRC_HSI_Msk: u32 = 0;
pub const RCC_PLLCFGR_PLLSRC_HSI: u32 = 0;
pub const RCC_PLLCFGR_PLLSRC_HSE_Pos: u32 = 0;
pub const RCC_PLLCFGR_PLLSRC_HSE_Msk: u32 = 1;
pub const RCC_PLLCFGR_PLLSRC_HSE: u32 = 1;
pub const RCC_ECSCR_HSE_FREQ_Pos: u32 = 2;
pub const RCC_ECSCR_HSE_FREQ_Msk: u32 = 12;
pub const RCC_ECSCR_HSE_FREQ: u32 = 12;
pub const RCC_ECSCR_HSE_FREQ_0: u32 = 4;
pub const RCC_ECSCR_HSE_FREQ_1: u32 = 8;
pub const RCC_ECSCR_LSE_DRIVER_Pos: u32 = 16;
pub const RCC_ECSCR_LSE_DRIVER_Msk: u32 = 196608;
pub const RCC_ECSCR_LSE_DRIVER: u32 = 196608;
pub const RCC_ECSCR_LSE_DRIVER_0: u32 = 65536;
pub const RCC_ECSCR_LSE_DRIVER_1: u32 = 131072;
pub const RCC_CIER_LSIRDYIE_Pos: u32 = 0;
pub const RCC_CIER_LSIRDYIE_Msk: u32 = 1;
pub const RCC_CIER_LSIRDYIE: u32 = 1;
pub const RCC_CIER_LSERDYIE_Pos: u32 = 1;
pub const RCC_CIER_LSERDYIE_Msk: u32 = 2;
pub const RCC_CIER_LSERDYIE: u32 = 2;
pub const RCC_CIER_HSIRDYIE_Pos: u32 = 3;
pub const RCC_CIER_HSIRDYIE_Msk: u32 = 8;
pub const RCC_CIER_HSIRDYIE: u32 = 8;
pub const RCC_CIER_HSERDYIE_Pos: u32 = 4;
pub const RCC_CIER_HSERDYIE_Msk: u32 = 16;
pub const RCC_CIER_HSERDYIE: u32 = 16;
pub const RCC_CIER_PLLRDYIE_Pos: u32 = 5;
pub const RCC_CIER_PLLRDYIE_Msk: u32 = 32;
pub const RCC_CIER_PLLRDYIE: u32 = 32;
pub const RCC_CIFR_LSIRDYF_Pos: u32 = 0;
pub const RCC_CIFR_LSIRDYF_Msk: u32 = 1;
pub const RCC_CIFR_LSIRDYF: u32 = 1;
pub const RCC_CIFR_LSERDYF_Pos: u32 = 1;
pub const RCC_CIFR_LSERDYF_Msk: u32 = 2;
pub const RCC_CIFR_LSERDYF: u32 = 2;
pub const RCC_CIFR_HSIRDYF_Pos: u32 = 3;
pub const RCC_CIFR_HSIRDYF_Msk: u32 = 8;
pub const RCC_CIFR_HSIRDYF: u32 = 8;
pub const RCC_CIFR_HSERDYF_Pos: u32 = 4;
pub const RCC_CIFR_HSERDYF_Msk: u32 = 16;
pub const RCC_CIFR_HSERDYF: u32 = 16;
pub const RCC_CIFR_PLLRDYF_Pos: u32 = 5;
pub const RCC_CIFR_PLLRDYF_Msk: u32 = 32;
pub const RCC_CIFR_PLLRDYF: u32 = 32;
pub const RCC_CIFR_CSSF_Pos: u32 = 8;
pub const RCC_CIFR_CSSF_Msk: u32 = 256;
pub const RCC_CIFR_CSSF: u32 = 256;
pub const RCC_CIFR_LSECSSF_Pos: u32 = 9;
pub const RCC_CIFR_LSECSSF_Msk: u32 = 512;
pub const RCC_CIFR_LSECSSF: u32 = 512;
pub const RCC_CICR_LSIRDYC_Pos: u32 = 0;
pub const RCC_CICR_LSIRDYC_Msk: u32 = 1;
pub const RCC_CICR_LSIRDYC: u32 = 1;
pub const RCC_CICR_LSERDYC_Pos: u32 = 1;
pub const RCC_CICR_LSERDYC_Msk: u32 = 2;
pub const RCC_CICR_LSERDYC: u32 = 2;
pub const RCC_CICR_HSIRDYC_Pos: u32 = 3;
pub const RCC_CICR_HSIRDYC_Msk: u32 = 8;
pub const RCC_CICR_HSIRDYC: u32 = 8;
pub const RCC_CICR_HSERDYC_Pos: u32 = 4;
pub const RCC_CICR_HSERDYC_Msk: u32 = 16;
pub const RCC_CICR_HSERDYC: u32 = 16;
pub const RCC_CICR_PLLRDYC_Pos: u32 = 5;
pub const RCC_CICR_PLLRDYC_Msk: u32 = 32;
pub const RCC_CICR_PLLRDYC: u32 = 32;
pub const RCC_CICR_CSSC_Pos: u32 = 8;
pub const RCC_CICR_CSSC_Msk: u32 = 256;
pub const RCC_CICR_CSSC: u32 = 256;
pub const RCC_CICR_LSECSSC_Pos: u32 = 9;
pub const RCC_CICR_LSECSSC_Msk: u32 = 512;
pub const RCC_CICR_LSECSSC: u32 = 512;
pub const RCC_IOPRSTR_GPIOARST_Pos: u32 = 0;
pub const RCC_IOPRSTR_GPIOARST_Msk: u32 = 1;
pub const RCC_IOPRSTR_GPIOARST: u32 = 1;
pub const RCC_IOPRSTR_GPIOBRST_Pos: u32 = 1;
pub const RCC_IOPRSTR_GPIOBRST_Msk: u32 = 2;
pub const RCC_IOPRSTR_GPIOBRST: u32 = 2;
pub const RCC_IOPRSTR_GPIOFRST_Pos: u32 = 5;
pub const RCC_IOPRSTR_GPIOFRST_Msk: u32 = 32;
pub const RCC_IOPRSTR_GPIOFRST: u32 = 32;
pub const RCC_AHBRSTR_DMARST_Pos: u32 = 0;
pub const RCC_AHBRSTR_DMARST_Msk: u32 = 1;
pub const RCC_AHBRSTR_DMARST: u32 = 1;
pub const RCC_AHBRSTR_CRCRST_Pos: u32 = 12;
pub const RCC_AHBRSTR_CRCRST_Msk: u32 = 4096;
pub const RCC_AHBRSTR_CRCRST: u32 = 4096;
pub const RCC_APBRSTR1_TIM3RST_Pos: u32 = 1;
pub const RCC_APBRSTR1_TIM3RST_Msk: u32 = 2;
pub const RCC_APBRSTR1_TIM3RST: u32 = 2;
pub const RCC_APBRSTR1_SPI2RST_Pos: u32 = 14;
pub const RCC_APBRSTR1_SPI2RST_Msk: u32 = 16384;
pub const RCC_APBRSTR1_SPI2RST: u32 = 16384;
pub const RCC_APBRSTR1_USART2RST_Pos: u32 = 17;
pub const RCC_APBRSTR1_USART2RST_Msk: u32 = 131072;
pub const RCC_APBRSTR1_USART2RST: u32 = 131072;
pub const RCC_APBRSTR1_I2CRST_Pos: u32 = 21;
pub const RCC_APBRSTR1_I2CRST_Msk: u32 = 2097152;
pub const RCC_APBRSTR1_I2CRST: u32 = 2097152;
pub const RCC_APBRSTR1_DBGRST_Pos: u32 = 27;
pub const RCC_APBRSTR1_DBGRST_Msk: u32 = 134217728;
pub const RCC_APBRSTR1_DBGRST: u32 = 134217728;
pub const RCC_APBRSTR1_PWRRST_Pos: u32 = 28;
pub const RCC_APBRSTR1_PWRRST_Msk: u32 = 268435456;
pub const RCC_APBRSTR1_PWRRST: u32 = 268435456;
pub const RCC_APBRSTR1_LPTIMRST_Pos: u32 = 31;
pub const RCC_APBRSTR1_LPTIMRST_Msk: u32 = 2147483648;
pub const RCC_APBRSTR1_LPTIMRST: u32 = 2147483648;
pub const RCC_APBRSTR2_SYSCFGRST_Pos: u32 = 0;
pub const RCC_APBRSTR2_SYSCFGRST_Msk: u32 = 1;
pub const RCC_APBRSTR2_SYSCFGRST: u32 = 1;
pub const RCC_APBRSTR2_TIM1RST_Pos: u32 = 11;
pub const RCC_APBRSTR2_TIM1RST_Msk: u32 = 2048;
pub const RCC_APBRSTR2_TIM1RST: u32 = 2048;
pub const RCC_APBRSTR2_SPI1RST_Pos: u32 = 12;
pub const RCC_APBRSTR2_SPI1RST_Msk: u32 = 4096;
pub const RCC_APBRSTR2_SPI1RST: u32 = 4096;
pub const RCC_APBRSTR2_USART1RST_Pos: u32 = 14;
pub const RCC_APBRSTR2_USART1RST_Msk: u32 = 16384;
pub const RCC_APBRSTR2_USART1RST: u32 = 16384;
pub const RCC_APBRSTR2_TIM14RST_Pos: u32 = 15;
pub const RCC_APBRSTR2_TIM14RST_Msk: u32 = 32768;
pub const RCC_APBRSTR2_TIM14RST: u32 = 32768;
pub const RCC_APBRSTR2_TIM16RST_Pos: u32 = 17;
pub const RCC_APBRSTR2_TIM16RST_Msk: u32 = 131072;
pub const RCC_APBRSTR2_TIM16RST: u32 = 131072;
pub const RCC_APBRSTR2_TIM17RST_Pos: u32 = 18;
pub const RCC_APBRSTR2_TIM17RST_Msk: u32 = 262144;
pub const RCC_APBRSTR2_TIM17RST: u32 = 262144;
pub const RCC_APBRSTR2_ADCRST_Pos: u32 = 20;
pub const RCC_APBRSTR2_ADCRST_Msk: u32 = 1048576;
pub const RCC_APBRSTR2_ADCRST: u32 = 1048576;
pub const RCC_APBRSTR2_COMP1RST_Pos: u32 = 21;
pub const RCC_APBRSTR2_COMP1RST_Msk: u32 = 2097152;
pub const RCC_APBRSTR2_COMP1RST: u32 = 2097152;
pub const RCC_APBRSTR2_COMP2RST_Pos: u32 = 22;
pub const RCC_APBRSTR2_COMP2RST_Msk: u32 = 4194304;
pub const RCC_APBRSTR2_COMP2RST: u32 = 4194304;
pub const RCC_APBRSTR2_LEDRST_Pos: u32 = 23;
pub const RCC_APBRSTR2_LEDRST_Msk: u32 = 8388608;
pub const RCC_APBRSTR2_LEDRST: u32 = 8388608;
pub const RCC_IOPENR_GPIOAEN_Pos: u32 = 0;
pub const RCC_IOPENR_GPIOAEN_Msk: u32 = 1;
pub const RCC_IOPENR_GPIOAEN: u32 = 1;
pub const RCC_IOPENR_GPIOBEN_Pos: u32 = 1;
pub const RCC_IOPENR_GPIOBEN_Msk: u32 = 2;
pub const RCC_IOPENR_GPIOBEN: u32 = 2;
pub const RCC_IOPENR_GPIOFEN_Pos: u32 = 5;
pub const RCC_IOPENR_GPIOFEN_Msk: u32 = 32;
pub const RCC_IOPENR_GPIOFEN: u32 = 32;
pub const RCC_AHBENR_DMAEN_Pos: u32 = 0;
pub const RCC_AHBENR_DMAEN_Msk: u32 = 1;
pub const RCC_AHBENR_DMAEN: u32 = 1;
pub const RCC_AHBENR_FLASHEN_Pos: u32 = 8;
pub const RCC_AHBENR_FLASHEN_Msk: u32 = 256;
pub const RCC_AHBENR_FLASHEN: u32 = 256;
pub const RCC_AHBENR_SRAMEN_Pos: u32 = 9;
pub const RCC_AHBENR_SRAMEN_Msk: u32 = 512;
pub const RCC_AHBENR_SRAMEN: u32 = 512;
pub const RCC_AHBENR_CRCEN_Pos: u32 = 12;
pub const RCC_AHBENR_CRCEN_Msk: u32 = 4096;
pub const RCC_AHBENR_CRCEN: u32 = 4096;
pub const RCC_APBENR1_TIM3EN_Pos: u32 = 1;
pub const RCC_APBENR1_TIM3EN_Msk: u32 = 2;
pub const RCC_APBENR1_TIM3EN: u32 = 2;
pub const RCC_APBENR1_RTCAPBEN_Pos: u32 = 10;
pub const RCC_APBENR1_RTCAPBEN_Msk: u32 = 1024;
pub const RCC_APBENR1_RTCAPBEN: u32 = 1024;
pub const RCC_APBENR1_WWDGEN_Pos: u32 = 11;
pub const RCC_APBENR1_WWDGEN_Msk: u32 = 2048;
pub const RCC_APBENR1_WWDGEN: u32 = 2048;
pub const RCC_APBENR1_SPI2EN_Pos: u32 = 14;
pub const RCC_APBENR1_SPI2EN_Msk: u32 = 16384;
pub const RCC_APBENR1_SPI2EN: u32 = 16384;
pub const RCC_APBENR1_USART2EN_Pos: u32 = 17;
pub const RCC_APBENR1_USART2EN_Msk: u32 = 131072;
pub const RCC_APBENR1_USART2EN: u32 = 131072;
pub const RCC_APBENR1_I2CEN_Pos: u32 = 21;
pub const RCC_APBENR1_I2CEN_Msk: u32 = 2097152;
pub const RCC_APBENR1_I2CEN: u32 = 2097152;
pub const RCC_APBENR1_DBGEN_Pos: u32 = 27;
pub const RCC_APBENR1_DBGEN_Msk: u32 = 134217728;
pub const RCC_APBENR1_DBGEN: u32 = 134217728;
pub const RCC_APBENR1_PWREN_Pos: u32 = 28;
pub const RCC_APBENR1_PWREN_Msk: u32 = 268435456;
pub const RCC_APBENR1_PWREN: u32 = 268435456;
pub const RCC_APBENR1_LPTIMEN_Pos: u32 = 31;
pub const RCC_APBENR1_LPTIMEN_Msk: u32 = 2147483648;
pub const RCC_APBENR1_LPTIMEN: u32 = 2147483648;
pub const RCC_APBENR2_SYSCFGEN_Pos: u32 = 0;
pub const RCC_APBENR2_SYSCFGEN_Msk: u32 = 1;
pub const RCC_APBENR2_SYSCFGEN: u32 = 1;
pub const RCC_APBENR2_TIM1EN_Pos: u32 = 11;
pub const RCC_APBENR2_TIM1EN_Msk: u32 = 2048;
pub const RCC_APBENR2_TIM1EN: u32 = 2048;
pub const RCC_APBENR2_SPI1EN_Pos: u32 = 12;
pub const RCC_APBENR2_SPI1EN_Msk: u32 = 4096;
pub const RCC_APBENR2_SPI1EN: u32 = 4096;
pub const RCC_APBENR2_USART1EN_Pos: u32 = 14;
pub const RCC_APBENR2_USART1EN_Msk: u32 = 16384;
pub const RCC_APBENR2_USART1EN: u32 = 16384;
pub const RCC_APBENR2_TIM14EN_Pos: u32 = 15;
pub const RCC_APBENR2_TIM14EN_Msk: u32 = 32768;
pub const RCC_APBENR2_TIM14EN: u32 = 32768;
pub const RCC_APBENR2_TIM16EN_Pos: u32 = 17;
pub const RCC_APBENR2_TIM16EN_Msk: u32 = 131072;
pub const RCC_APBENR2_TIM16EN: u32 = 131072;
pub const RCC_APBENR2_TIM17EN_Pos: u32 = 18;
pub const RCC_APBENR2_TIM17EN_Msk: u32 = 262144;
pub const RCC_APBENR2_TIM17EN: u32 = 262144;
pub const RCC_APBENR2_ADCEN_Pos: u32 = 20;
pub const RCC_APBENR2_ADCEN_Msk: u32 = 1048576;
pub const RCC_APBENR2_ADCEN: u32 = 1048576;
pub const RCC_APBENR2_COMP1EN_Pos: u32 = 21;
pub const RCC_APBENR2_COMP1EN_Msk: u32 = 2097152;
pub const RCC_APBENR2_COMP1EN: u32 = 2097152;
pub const RCC_APBENR2_COMP2EN_Pos: u32 = 22;
pub const RCC_APBENR2_COMP2EN_Msk: u32 = 4194304;
pub const RCC_APBENR2_COMP2EN: u32 = 4194304;
pub const RCC_APBENR2_LEDEN_Pos: u32 = 23;
pub const RCC_APBENR2_LEDEN_Msk: u32 = 8388608;
pub const RCC_APBENR2_LEDEN: u32 = 8388608;
pub const RCC_CCIPR_PVDSEL_Pos: u32 = 7;
pub const RCC_CCIPR_PVDSEL_Msk: u32 = 128;
pub const RCC_CCIPR_PVDSEL: u32 = 128;
pub const RCC_CCIPR_COMP1SEL_Pos: u32 = 8;
pub const RCC_CCIPR_COMP1SEL_Msk: u32 = 256;
pub const RCC_CCIPR_COMP1SEL: u32 = 256;
pub const RCC_CCIPR_COMP2SEL_Pos: u32 = 9;
pub const RCC_CCIPR_COMP2SEL_Msk: u32 = 512;
pub const RCC_CCIPR_COMP2SEL: u32 = 512;
pub const RCC_CCIPR_LPTIMSEL_Pos: u32 = 18;
pub const RCC_CCIPR_LPTIMSEL_Msk: u32 = 786432;
pub const RCC_CCIPR_LPTIMSEL: u32 = 786432;
pub const RCC_CCIPR_LPTIMSEL_0: u32 = 262144;
pub const RCC_CCIPR_LPTIMSEL_1: u32 = 524288;
pub const RCC_BDCR_LSEON_Pos: u32 = 0;
pub const RCC_BDCR_LSEON_Msk: u32 = 1;
pub const RCC_BDCR_LSEON: u32 = 1;
pub const RCC_BDCR_LSERDY_Pos: u32 = 1;
pub const RCC_BDCR_LSERDY_Msk: u32 = 2;
pub const RCC_BDCR_LSERDY: u32 = 2;
pub const RCC_BDCR_LSEBYP_Pos: u32 = 2;
pub const RCC_BDCR_LSEBYP_Msk: u32 = 4;
pub const RCC_BDCR_LSEBYP: u32 = 4;
pub const RCC_BDCR_LSECSSON_Pos: u32 = 5;
pub const RCC_BDCR_LSECSSON_Msk: u32 = 32;
pub const RCC_BDCR_LSECSSON: u32 = 32;
pub const RCC_BDCR_LSECSSD_Pos: u32 = 6;
pub const RCC_BDCR_LSECSSD_Msk: u32 = 64;
pub const RCC_BDCR_LSECSSD: u32 = 64;
pub const RCC_BDCR_RTCSEL_Pos: u32 = 8;
pub const RCC_BDCR_RTCSEL_Msk: u32 = 768;
pub const RCC_BDCR_RTCSEL: u32 = 768;
pub const RCC_BDCR_RTCSEL_0: u32 = 256;
pub const RCC_BDCR_RTCSEL_1: u32 = 512;
pub const RCC_BDCR_RTCEN_Pos: u32 = 15;
pub const RCC_BDCR_RTCEN_Msk: u32 = 32768;
pub const RCC_BDCR_RTCEN: u32 = 32768;
pub const RCC_BDCR_BDRST_Pos: u32 = 16;
pub const RCC_BDCR_BDRST_Msk: u32 = 65536;
pub const RCC_BDCR_BDRST: u32 = 65536;
pub const RCC_BDCR_LSCOEN_Pos: u32 = 24;
pub const RCC_BDCR_LSCOEN_Msk: u32 = 16777216;
pub const RCC_BDCR_LSCOEN: u32 = 16777216;
pub const RCC_BDCR_LSCOSEL_Pos: u32 = 25;
pub const RCC_BDCR_LSCOSEL_Msk: u32 = 33554432;
pub const RCC_BDCR_LSCOSEL: u32 = 33554432;
pub const RCC_CSR_LSION_Pos: u32 = 0;
pub const RCC_CSR_LSION_Msk: u32 = 1;
pub const RCC_CSR_LSION: u32 = 1;
pub const RCC_CSR_LSIRDY_Pos: u32 = 1;
pub const RCC_CSR_LSIRDY_Msk: u32 = 2;
pub const RCC_CSR_LSIRDY: u32 = 2;
pub const RCC_CSR_NRST_FLTDIS_Pos: u32 = 8;
pub const RCC_CSR_NRST_FLTDIS_Msk: u32 = 256;
pub const RCC_CSR_NRST_FLTDIS: u32 = 256;
pub const RCC_CSR_RMVF_Pos: u32 = 23;
pub const RCC_CSR_RMVF_Msk: u32 = 8388608;
pub const RCC_CSR_RMVF: u32 = 8388608;
pub const RCC_CSR_OBLRSTF_Pos: u32 = 25;
pub const RCC_CSR_OBLRSTF_Msk: u32 = 33554432;
pub const RCC_CSR_OBLRSTF: u32 = 33554432;
pub const RCC_CSR_PINRSTF_Pos: u32 = 26;
pub const RCC_CSR_PINRSTF_Msk: u32 = 67108864;
pub const RCC_CSR_PINRSTF: u32 = 67108864;
pub const RCC_CSR_PWRRSTF_Pos: u32 = 27;
pub const RCC_CSR_PWRRSTF_Msk: u32 = 134217728;
pub const RCC_CSR_PWRRSTF: u32 = 134217728;
pub const RCC_CSR_SFTRSTF_Pos: u32 = 28;
pub const RCC_CSR_SFTRSTF_Msk: u32 = 268435456;
pub const RCC_CSR_SFTRSTF: u32 = 268435456;
pub const RCC_CSR_IWDGRSTF_Pos: u32 = 29;
pub const RCC_CSR_IWDGRSTF_Msk: u32 = 536870912;
pub const RCC_CSR_IWDGRSTF: u32 = 536870912;
pub const RCC_CSR_WWDGRSTF_Pos: u32 = 30;
pub const RCC_CSR_WWDGRSTF_Msk: u32 = 1073741824;
pub const RCC_CSR_WWDGRSTF: u32 = 1073741824;
pub const RTC_CRH_SECIE_Pos: u32 = 0;
pub const RTC_CRH_SECIE_Msk: u32 = 1;
pub const RTC_CRH_SECIE: u32 = 1;
pub const RTC_CRH_ALRIE_Pos: u32 = 1;
pub const RTC_CRH_ALRIE_Msk: u32 = 2;
pub const RTC_CRH_ALRIE: u32 = 2;
pub const RTC_CRH_OWIE_Pos: u32 = 2;
pub const RTC_CRH_OWIE_Msk: u32 = 4;
pub const RTC_CRH_OWIE: u32 = 4;
pub const RTC_CRL_SECF_Pos: u32 = 0;
pub const RTC_CRL_SECF_Msk: u32 = 1;
pub const RTC_CRL_SECF: u32 = 1;
pub const RTC_CRL_ALRF_Pos: u32 = 1;
pub const RTC_CRL_ALRF_Msk: u32 = 2;
pub const RTC_CRL_ALRF: u32 = 2;
pub const RTC_CRL_OWF_Pos: u32 = 2;
pub const RTC_CRL_OWF_Msk: u32 = 4;
pub const RTC_CRL_OWF: u32 = 4;
pub const RTC_CRL_RSF_Pos: u32 = 3;
pub const RTC_CRL_RSF_Msk: u32 = 8;
pub const RTC_CRL_RSF: u32 = 8;
pub const RTC_CRL_CNF_Pos: u32 = 4;
pub const RTC_CRL_CNF_Msk: u32 = 16;
pub const RTC_CRL_CNF: u32 = 16;
pub const RTC_CRL_RTOFF_Pos: u32 = 5;
pub const RTC_CRL_RTOFF_Msk: u32 = 32;
pub const RTC_CRL_RTOFF: u32 = 32;
pub const RTC_PRLH_PRL_Pos: u32 = 0;
pub const RTC_PRLH_PRL_Msk: u32 = 15;
pub const RTC_PRLH_PRL: u32 = 15;
pub const RTC_PRLL_PRL_Pos: u32 = 0;
pub const RTC_PRLL_PRL_Msk: u32 = 65535;
pub const RTC_PRLL_PRL: u32 = 65535;
pub const RTC_DIVH_RTC_DIV_Pos: u32 = 0;
pub const RTC_DIVH_RTC_DIV_Msk: u32 = 15;
pub const RTC_DIVH_RTC_DIV: u32 = 15;
pub const RTC_DIVL_RTC_DIV_Pos: u32 = 0;
pub const RTC_DIVL_RTC_DIV_Msk: u32 = 65535;
pub const RTC_DIVL_RTC_DIV: u32 = 65535;
pub const RTC_CNTH_RTC_CNT_Pos: u32 = 0;
pub const RTC_CNTH_RTC_CNT_Msk: u32 = 65535;
pub const RTC_CNTH_RTC_CNT: u32 = 65535;
pub const RTC_CNTL_RTC_CNT_Pos: u32 = 0;
pub const RTC_CNTL_RTC_CNT_Msk: u32 = 65535;
pub const RTC_CNTL_RTC_CNT: u32 = 65535;
pub const RTC_ALRH_RTC_ALR_Pos: u32 = 0;
pub const RTC_ALRH_RTC_ALR_Msk: u32 = 65535;
pub const RTC_ALRH_RTC_ALR: u32 = 65535;
pub const RTC_ALRL_RTC_ALR_Pos: u32 = 0;
pub const RTC_ALRL_RTC_ALR_Msk: u32 = 65535;
pub const RTC_ALRL_RTC_ALR: u32 = 65535;
pub const BKP_RTCCR_CAL_Pos: u32 = 0;
pub const BKP_RTCCR_CAL_Msk: u32 = 127;
pub const BKP_RTCCR_CAL: u32 = 127;
pub const BKP_RTCCR_CAL_0: u32 = 1;
pub const BKP_RTCCR_CAL_1: u32 = 2;
pub const BKP_RTCCR_CAL_2: u32 = 4;
pub const BKP_RTCCR_CAL_3: u32 = 8;
pub const BKP_RTCCR_CAL_4: u32 = 16;
pub const BKP_RTCCR_CAL_5: u32 = 32;
pub const BKP_RTCCR_CAL_6: u32 = 64;
pub const BKP_RTCCR_CCO_Pos: u32 = 7;
pub const BKP_RTCCR_CCO_Msk: u32 = 128;
pub const BKP_RTCCR_CCO: u32 = 128;
pub const BKP_RTCCR_ASOE_Pos: u32 = 8;
pub const BKP_RTCCR_ASOE_Msk: u32 = 256;
pub const BKP_RTCCR_ASOE: u32 = 256;
pub const BKP_RTCCR_ASOS_Pos: u32 = 9;
pub const BKP_RTCCR_ASOS_Msk: u32 = 512;
pub const BKP_RTCCR_ASOS: u32 = 512;
pub const SPI_CR1_CPHA_Pos: u32 = 0;
pub const SPI_CR1_CPHA_Msk: u32 = 1;
pub const SPI_CR1_CPHA: u32 = 1;
pub const SPI_CR1_CPOL_Pos: u32 = 1;
pub const SPI_CR1_CPOL_Msk: u32 = 2;
pub const SPI_CR1_CPOL: u32 = 2;
pub const SPI_CR1_MSTR_Pos: u32 = 2;
pub const SPI_CR1_MSTR_Msk: u32 = 4;
pub const SPI_CR1_MSTR: u32 = 4;
pub const SPI_CR1_BR_Pos: u32 = 3;
pub const SPI_CR1_BR_Msk: u32 = 56;
pub const SPI_CR1_BR: u32 = 56;
pub const SPI_CR1_BR_0: u32 = 8;
pub const SPI_CR1_BR_1: u32 = 16;
pub const SPI_CR1_BR_2: u32 = 32;
pub const SPI_CR1_SPE_Pos: u32 = 6;
pub const SPI_CR1_SPE_Msk: u32 = 64;
pub const SPI_CR1_SPE: u32 = 64;
pub const SPI_CR1_LSBFIRST_Pos: u32 = 7;
pub const SPI_CR1_LSBFIRST_Msk: u32 = 128;
pub const SPI_CR1_LSBFIRST: u32 = 128;
pub const SPI_CR1_SSI_Pos: u32 = 8;
pub const SPI_CR1_SSI_Msk: u32 = 256;
pub const SPI_CR1_SSI: u32 = 256;
pub const SPI_CR1_SSM_Pos: u32 = 9;
pub const SPI_CR1_SSM_Msk: u32 = 512;
pub const SPI_CR1_SSM: u32 = 512;
pub const SPI_CR1_RXONLY_Pos: u32 = 10;
pub const SPI_CR1_RXONLY_Msk: u32 = 1024;
pub const SPI_CR1_RXONLY: u32 = 1024;
pub const SPI_CR1_BIDIOE_Pos: u32 = 14;
pub const SPI_CR1_BIDIOE_Msk: u32 = 16384;
pub const SPI_CR1_BIDIOE: u32 = 16384;
pub const SPI_CR1_BIDIMODE_Pos: u32 = 15;
pub const SPI_CR1_BIDIMODE_Msk: u32 = 32768;
pub const SPI_CR1_BIDIMODE: u32 = 32768;
pub const SPI_CR2_RXDMAEN_Pos: u32 = 0;
pub const SPI_CR2_RXDMAEN_Msk: u32 = 1;
pub const SPI_CR2_RXDMAEN: u32 = 1;
pub const SPI_CR2_TXDMAEN_Pos: u32 = 1;
pub const SPI_CR2_TXDMAEN_Msk: u32 = 2;
pub const SPI_CR2_TXDMAEN: u32 = 2;
pub const SPI_CR2_SSOE_Pos: u32 = 2;
pub const SPI_CR2_SSOE_Msk: u32 = 4;
pub const SPI_CR2_SSOE: u32 = 4;
pub const SPI_CR2_ERRIE_Pos: u32 = 5;
pub const SPI_CR2_ERRIE_Msk: u32 = 32;
pub const SPI_CR2_ERRIE: u32 = 32;
pub const SPI_CR2_RXNEIE_Pos: u32 = 6;
pub const SPI_CR2_RXNEIE_Msk: u32 = 64;
pub const SPI_CR2_RXNEIE: u32 = 64;
pub const SPI_CR2_TXEIE_Pos: u32 = 7;
pub const SPI_CR2_TXEIE_Msk: u32 = 128;
pub const SPI_CR2_TXEIE: u32 = 128;
pub const SPI_CR2_DS_Pos: u32 = 11;
pub const SPI_CR2_DS_Msk: u32 = 2048;
pub const SPI_CR2_DS: u32 = 2048;
pub const SPI_CR2_FRXTH_Pos: u32 = 12;
pub const SPI_CR2_FRXTH_Msk: u32 = 4096;
pub const SPI_CR2_FRXTH: u32 = 4096;
pub const SPI_CR2_LDMA_RX_Pos: u32 = 13;
pub const SPI_CR2_LDMA_RX_Msk: u32 = 8192;
pub const SPI_CR2_LDMA_RX: u32 = 8192;
pub const SPI_CR2_LDMA_TX_Pos: u32 = 14;
pub const SPI_CR2_LDMA_TX_Msk: u32 = 16384;
pub const SPI_CR2_LDMA_TX: u32 = 16384;
pub const SPI_CR2_SLVFM_Pos: u32 = 15;
pub const SPI_CR2_SLVFM_Msk: u32 = 32768;
pub const SPI_CR2_SLVFM: u32 = 32768;
pub const SPI_SR_RXNE_Pos: u32 = 0;
pub const SPI_SR_RXNE_Msk: u32 = 1;
pub const SPI_SR_RXNE: u32 = 1;
pub const SPI_SR_TXE_Pos: u32 = 1;
pub const SPI_SR_TXE_Msk: u32 = 2;
pub const SPI_SR_TXE: u32 = 2;
pub const SPI_SR_MODF_Pos: u32 = 5;
pub const SPI_SR_MODF_Msk: u32 = 32;
pub const SPI_SR_MODF: u32 = 32;
pub const SPI_SR_OVR_Pos: u32 = 6;
pub const SPI_SR_OVR_Msk: u32 = 64;
pub const SPI_SR_OVR: u32 = 64;
pub const SPI_SR_BSY_Pos: u32 = 7;
pub const SPI_SR_BSY_Msk: u32 = 128;
pub const SPI_SR_BSY: u32 = 128;
pub const SPI_SR_FRLVL_Pos: u32 = 9;
pub const SPI_SR_FRLVL_Msk: u32 = 1536;
pub const SPI_SR_FRLVL: u32 = 1536;
pub const SPI_SR_FRLVL_0: u32 = 512;
pub const SPI_SR_FRLVL_1: u32 = 1024;
pub const SPI_SR_FTLVL_Pos: u32 = 11;
pub const SPI_SR_FTLVL_Msk: u32 = 6144;
pub const SPI_SR_FTLVL: u32 = 6144;
pub const SPI_SR_FTLVL_0: u32 = 2048;
pub const SPI_SR_FTLVL_1: u32 = 4096;
pub const SPI_DR_DR_Pos: u32 = 0;
pub const SPI_DR_DR_Msk: u32 = 65535;
pub const SPI_DR_DR: u32 = 65535;
pub const SYSCFG_CFGR1_MEM_MODE_Pos: u32 = 0;
pub const SYSCFG_CFGR1_MEM_MODE_Msk: u32 = 3;
pub const SYSCFG_CFGR1_MEM_MODE: u32 = 3;
pub const SYSCFG_CFGR1_MEM_MODE_0: u32 = 1;
pub const SYSCFG_CFGR1_MEM_MODE_1: u32 = 2;
pub const SYSCFG_CFGR1_I2C_PA2_ANF_Pos: u32 = 18;
pub const SYSCFG_CFGR1_I2C_PA2_ANF_Msk: u32 = 262144;
pub const SYSCFG_CFGR1_I2C_PA2_ANF: u32 = 262144;
pub const SYSCFG_CFGR1_I2C_PA3_ANF_Pos: u32 = 19;
pub const SYSCFG_CFGR1_I2C_PA3_ANF_Msk: u32 = 524288;
pub const SYSCFG_CFGR1_I2C_PA3_ANF: u32 = 524288;
pub const SYSCFG_CFGR1_I2C_PA7_ANF_Pos: u32 = 20;
pub const SYSCFG_CFGR1_I2C_PA7_ANF_Msk: u32 = 1048576;
pub const SYSCFG_CFGR1_I2C_PA7_ANF: u32 = 1048576;
pub const SYSCFG_CFGR1_I2C_PA8_ANF_Pos: u32 = 21;
pub const SYSCFG_CFGR1_I2C_PA8_ANF_Msk: u32 = 2097152;
pub const SYSCFG_CFGR1_I2C_PA8_ANF: u32 = 2097152;
pub const SYSCFG_CFGR1_I2C_PA9_ANF_Pos: u32 = 22;
pub const SYSCFG_CFGR1_I2C_PA9_ANF_Msk: u32 = 4194304;
pub const SYSCFG_CFGR1_I2C_PA9_ANF: u32 = 4194304;
pub const SYSCFG_CFGR1_I2C_PA10_ANF_Pos: u32 = 23;
pub const SYSCFG_CFGR1_I2C_PA10_ANF_Msk: u32 = 8388608;
pub const SYSCFG_CFGR1_I2C_PA10_ANF: u32 = 8388608;
pub const SYSCFG_CFGR1_I2C_PA11_ANF_Pos: u32 = 24;
pub const SYSCFG_CFGR1_I2C_PA11_ANF_Msk: u32 = 16777216;
pub const SYSCFG_CFGR1_I2C_PA11_ANF: u32 = 16777216;
pub const SYSCFG_CFGR1_I2C_PA12_ANF_Pos: u32 = 25;
pub const SYSCFG_CFGR1_I2C_PA12_ANF_Msk: u32 = 33554432;
pub const SYSCFG_CFGR1_I2C_PA12_ANF: u32 = 33554432;
pub const SYSCFG_CFGR1_I2C_PB6_ANF_Pos: u32 = 26;
pub const SYSCFG_CFGR1_I2C_PB6_ANF_Msk: u32 = 67108864;
pub const SYSCFG_CFGR1_I2C_PB6_ANF: u32 = 67108864;
pub const SYSCFG_CFGR1_I2C_PB7_ANF_Pos: u32 = 27;
pub const SYSCFG_CFGR1_I2C_PB7_ANF_Msk: u32 = 134217728;
pub const SYSCFG_CFGR1_I2C_PB7_ANF: u32 = 134217728;
pub const SYSCFG_CFGR1_I2C_PB8_ANF_Pos: u32 = 28;
pub const SYSCFG_CFGR1_I2C_PB8_ANF_Msk: u32 = 268435456;
pub const SYSCFG_CFGR1_I2C_PB8_ANF: u32 = 268435456;
pub const SYSCFG_CFGR1_I2C_PF0_ANF_Pos: u32 = 29;
pub const SYSCFG_CFGR1_I2C_PF0_ANF_Msk: u32 = 536870912;
pub const SYSCFG_CFGR1_I2C_PF0_ANF: u32 = 536870912;
pub const SYSCFG_CFGR1_I2C_PF1_ANF_Pos: u32 = 30;
pub const SYSCFG_CFGR1_I2C_PF1_ANF_Msk: u32 = 1073741824;
pub const SYSCFG_CFGR1_I2C_PF1_ANF: u32 = 1073741824;
pub const SYSCFG_CFGR2_LOCKUP_LOCK_Pos: u32 = 0;
pub const SYSCFG_CFGR2_LOCKUP_LOCK_Msk: u32 = 1;
pub const SYSCFG_CFGR2_LOCKUP_LOCK: u32 = 1;
pub const SYSCFG_CFGR2_PVD_LOCK_Pos: u32 = 2;
pub const SYSCFG_CFGR2_PVD_LOCK_Msk: u32 = 4;
pub const SYSCFG_CFGR2_PVD_LOCK: u32 = 4;
pub const SYSCFG_CFGR2_COMP1_BRK_TIM1_Pos: u32 = 3;
pub const SYSCFG_CFGR2_COMP1_BRK_TIM1_Msk: u32 = 8;
pub const SYSCFG_CFGR2_COMP1_BRK_TIM1: u32 = 8;
pub const SYSCFG_CFGR2_COMP2_BRK_TIM1_Pos: u32 = 4;
pub const SYSCFG_CFGR2_COMP2_BRK_TIM1_Msk: u32 = 16;
pub const SYSCFG_CFGR2_COMP2_BRK_TIM1: u32 = 16;
pub const SYSCFG_CFGR2_COMP1_BRK_TIM16_Pos: u32 = 5;
pub const SYSCFG_CFGR2_COMP1_BRK_TIM16_Msk: u32 = 32;
pub const SYSCFG_CFGR2_COMP1_BRK_TIM16: u32 = 32;
pub const SYSCFG_CFGR2_COMP2_BRK_TIM16_Pos: u32 = 6;
pub const SYSCFG_CFGR2_COMP2_BRK_TIM16_Msk: u32 = 64;
pub const SYSCFG_CFGR2_COMP2_BRK_TIM16: u32 = 64;
pub const SYSCFG_CFGR2_COMP1_BRK_TIM17_Pos: u32 = 7;
pub const SYSCFG_CFGR2_COMP1_BRK_TIM17_Msk: u32 = 128;
pub const SYSCFG_CFGR2_COMP1_BRK_TIM17: u32 = 128;
pub const SYSCFG_CFGR2_COMP2_BRK_TIM17_Pos: u32 = 8;
pub const SYSCFG_CFGR2_COMP2_BRK_TIM17_Msk: u32 = 256;
pub const SYSCFG_CFGR2_COMP2_BRK_TIM17: u32 = 256;
pub const SYSCFG_CFGR2_ETR_SRC_TIM1_Pos: u32 = 9;
pub const SYSCFG_CFGR2_ETR_SRC_TIM1_Msk: u32 = 1536;
pub const SYSCFG_CFGR2_ETR_SRC_TIM1: u32 = 1536;
pub const SYSCFG_CFGR2_ETR_SRC_TIM1_0: u32 = 512;
pub const SYSCFG_CFGR2_ETR_SRC_TIM1_1: u32 = 1024;
pub const SYSCFG_CFGR3_DMA1_MAP_Pos: u32 = 0;
pub const SYSCFG_CFGR3_DMA1_MAP_Msk: u32 = 31;
pub const SYSCFG_CFGR3_DMA1_MAP: u32 = 31;
pub const SYSCFG_CFGR3_DMA1_MAP_0: u32 = 1;
pub const SYSCFG_CFGR3_DMA1_MAP_1: u32 = 2;
pub const SYSCFG_CFGR3_DMA1_MAP_2: u32 = 4;
pub const SYSCFG_CFGR3_DMA1_MAP_3: u32 = 8;
pub const SYSCFG_CFGR3_DMA1_MAP_4: u32 = 16;
pub const SYSCFG_CFGR3_DMA1_ACKLVL_Pos: u32 = 5;
pub const SYSCFG_CFGR3_DMA1_ACKLVL_Msk: u32 = 32;
pub const SYSCFG_CFGR3_DMA1_ACKLVL: u32 = 32;
pub const SYSCFG_CFGR3_DMA2_MAP_Pos: u32 = 8;
pub const SYSCFG_CFGR3_DMA2_MAP_Msk: u32 = 7936;
pub const SYSCFG_CFGR3_DMA2_MAP: u32 = 7936;
pub const SYSCFG_CFGR3_DMA2_MAP_0: u32 = 256;
pub const SYSCFG_CFGR3_DMA2_MAP_1: u32 = 512;
pub const SYSCFG_CFGR3_DMA2_MAP_2: u32 = 1024;
pub const SYSCFG_CFGR3_DMA2_MAP_3: u32 = 2048;
pub const SYSCFG_CFGR3_DMA2_MAP_4: u32 = 4096;
pub const SYSCFG_CFGR3_DMA2_ACKLVL_Pos: u32 = 13;
pub const SYSCFG_CFGR3_DMA2_ACKLVL_Msk: u32 = 8192;
pub const SYSCFG_CFGR3_DMA2_ACKLVL: u32 = 8192;
pub const SYSCFG_CFGR3_DMA3_MAP_Pos: u32 = 16;
pub const SYSCFG_CFGR3_DMA3_MAP_Msk: u32 = 2031616;
pub const SYSCFG_CFGR3_DMA3_MAP: u32 = 2031616;
pub const SYSCFG_CFGR3_DMA3_MAP_0: u32 = 65536;
pub const SYSCFG_CFGR3_DMA3_MAP_1: u32 = 131072;
pub const SYSCFG_CFGR3_DMA3_MAP_2: u32 = 262144;
pub const SYSCFG_CFGR3_DMA3_MAP_3: u32 = 524288;
pub const SYSCFG_CFGR3_DMA3_MAP_4: u32 = 1048576;
pub const SYSCFG_CFGR3_DMA3_ACKLVL_Pos: u32 = 21;
pub const SYSCFG_CFGR3_DMA3_ACKLVL_Msk: u32 = 2097152;
pub const SYSCFG_CFGR3_DMA3_ACKLVL: u32 = 2097152;
pub const TIM_CR1_CEN_Pos: u32 = 0;
pub const TIM_CR1_CEN_Msk: u32 = 1;
pub const TIM_CR1_CEN: u32 = 1;
pub const TIM_CR1_UDIS_Pos: u32 = 1;
pub const TIM_CR1_UDIS_Msk: u32 = 2;
pub const TIM_CR1_UDIS: u32 = 2;
pub const TIM_CR1_URS_Pos: u32 = 2;
pub const TIM_CR1_URS_Msk: u32 = 4;
pub const TIM_CR1_URS: u32 = 4;
pub const TIM_CR1_OPM_Pos: u32 = 3;
pub const TIM_CR1_OPM_Msk: u32 = 8;
pub const TIM_CR1_OPM: u32 = 8;
pub const TIM_CR1_DIR_Pos: u32 = 4;
pub const TIM_CR1_DIR_Msk: u32 = 16;
pub const TIM_CR1_DIR: u32 = 16;
pub const TIM_CR1_CMS_Pos: u32 = 5;
pub const TIM_CR1_CMS_Msk: u32 = 96;
pub const TIM_CR1_CMS: u32 = 96;
pub const TIM_CR1_CMS_0: u32 = 32;
pub const TIM_CR1_CMS_1: u32 = 64;
pub const TIM_CR1_ARPE_Pos: u32 = 7;
pub const TIM_CR1_ARPE_Msk: u32 = 128;
pub const TIM_CR1_ARPE: u32 = 128;
pub const TIM_CR1_CKD_Pos: u32 = 8;
pub const TIM_CR1_CKD_Msk: u32 = 768;
pub const TIM_CR1_CKD: u32 = 768;
pub const TIM_CR1_CKD_0: u32 = 256;
pub const TIM_CR1_CKD_1: u32 = 512;
pub const TIM_CR2_CCPC_Pos: u32 = 0;
pub const TIM_CR2_CCPC_Msk: u32 = 1;
pub const TIM_CR2_CCPC: u32 = 1;
pub const TIM_CR2_CCUS_Pos: u32 = 2;
pub const TIM_CR2_CCUS_Msk: u32 = 4;
pub const TIM_CR2_CCUS: u32 = 4;
pub const TIM_CR2_CCDS_Pos: u32 = 3;
pub const TIM_CR2_CCDS_Msk: u32 = 8;
pub const TIM_CR2_CCDS: u32 = 8;
pub const TIM_CR2_MMS_Pos: u32 = 4;
pub const TIM_CR2_MMS_Msk: u32 = 112;
pub const TIM_CR2_MMS: u32 = 112;
pub const TIM_CR2_MMS_0: u32 = 16;
pub const TIM_CR2_MMS_1: u32 = 32;
pub const TIM_CR2_MMS_2: u32 = 64;
pub const TIM_CR2_TI1S_Pos: u32 = 7;
pub const TIM_CR2_TI1S_Msk: u32 = 128;
pub const TIM_CR2_TI1S: u32 = 128;
pub const TIM_CR2_OIS1_Pos: u32 = 8;
pub const TIM_CR2_OIS1_Msk: u32 = 256;
pub const TIM_CR2_OIS1: u32 = 256;
pub const TIM_CR2_OIS1N_Pos: u32 = 9;
pub const TIM_CR2_OIS1N_Msk: u32 = 512;
pub const TIM_CR2_OIS1N: u32 = 512;
pub const TIM_CR2_OIS2_Pos: u32 = 10;
pub const TIM_CR2_OIS2_Msk: u32 = 1024;
pub const TIM_CR2_OIS2: u32 = 1024;
pub const TIM_CR2_OIS2N_Pos: u32 = 11;
pub const TIM_CR2_OIS2N_Msk: u32 = 2048;
pub const TIM_CR2_OIS2N: u32 = 2048;
pub const TIM_CR2_OIS3_Pos: u32 = 12;
pub const TIM_CR2_OIS3_Msk: u32 = 4096;
pub const TIM_CR2_OIS3: u32 = 4096;
pub const TIM_CR2_OIS3N_Pos: u32 = 13;
pub const TIM_CR2_OIS3N_Msk: u32 = 8192;
pub const TIM_CR2_OIS3N: u32 = 8192;
pub const TIM_CR2_OIS4_Pos: u32 = 14;
pub const TIM_CR2_OIS4_Msk: u32 = 16384;
pub const TIM_CR2_OIS4: u32 = 16384;
pub const TIM_SMCR_SMS_Pos: u32 = 0;
pub const TIM_SMCR_SMS_Msk: u32 = 7;
pub const TIM_SMCR_SMS: u32 = 7;
pub const TIM_SMCR_SMS_0: u32 = 1;
pub const TIM_SMCR_SMS_1: u32 = 2;
pub const TIM_SMCR_SMS_2: u32 = 4;
pub const TIM_SMCR_OCCS_Pos: u32 = 3;
pub const TIM_SMCR_OCCS_Msk: u32 = 8;
pub const TIM_SMCR_OCCS: u32 = 8;
pub const TIM_SMCR_TS_Pos: u32 = 4;
pub const TIM_SMCR_TS_Msk: u32 = 112;
pub const TIM_SMCR_TS: u32 = 112;
pub const TIM_SMCR_TS_0: u32 = 16;
pub const TIM_SMCR_TS_1: u32 = 32;
pub const TIM_SMCR_TS_2: u32 = 64;
pub const TIM_SMCR_MSM_Pos: u32 = 7;
pub const TIM_SMCR_MSM_Msk: u32 = 128;
pub const TIM_SMCR_MSM: u32 = 128;
pub const TIM_SMCR_ETF_Pos: u32 = 8;
pub const TIM_SMCR_ETF_Msk: u32 = 3840;
pub const TIM_SMCR_ETF: u32 = 3840;
pub const TIM_SMCR_ETF_0: u32 = 256;
pub const TIM_SMCR_ETF_1: u32 = 512;
pub const TIM_SMCR_ETF_2: u32 = 1024;
pub const TIM_SMCR_ETF_3: u32 = 2048;
pub const TIM_SMCR_ETPS_Pos: u32 = 12;
pub const TIM_SMCR_ETPS_Msk: u32 = 12288;
pub const TIM_SMCR_ETPS: u32 = 12288;
pub const TIM_SMCR_ETPS_0: u32 = 4096;
pub const TIM_SMCR_ETPS_1: u32 = 8192;
pub const TIM_SMCR_ECE_Pos: u32 = 14;
pub const TIM_SMCR_ECE_Msk: u32 = 16384;
pub const TIM_SMCR_ECE: u32 = 16384;
pub const TIM_SMCR_ETP_Pos: u32 = 15;
pub const TIM_SMCR_ETP_Msk: u32 = 32768;
pub const TIM_SMCR_ETP: u32 = 32768;
pub const TIM_DIER_UIE_Pos: u32 = 0;
pub const TIM_DIER_UIE_Msk: u32 = 1;
pub const TIM_DIER_UIE: u32 = 1;
pub const TIM_DIER_CC1IE_Pos: u32 = 1;
pub const TIM_DIER_CC1IE_Msk: u32 = 2;
pub const TIM_DIER_CC1IE: u32 = 2;
pub const TIM_DIER_CC2IE_Pos: u32 = 2;
pub const TIM_DIER_CC2IE_Msk: u32 = 4;
pub const TIM_DIER_CC2IE: u32 = 4;
pub const TIM_DIER_CC3IE_Pos: u32 = 3;
pub const TIM_DIER_CC3IE_Msk: u32 = 8;
pub const TIM_DIER_CC3IE: u32 = 8;
pub const TIM_DIER_CC4IE_Pos: u32 = 4;
pub const TIM_DIER_CC4IE_Msk: u32 = 16;
pub const TIM_DIER_CC4IE: u32 = 16;
pub const TIM_DIER_COMIE_Pos: u32 = 5;
pub const TIM_DIER_COMIE_Msk: u32 = 32;
pub const TIM_DIER_COMIE: u32 = 32;
pub const TIM_DIER_TIE_Pos: u32 = 6;
pub const TIM_DIER_TIE_Msk: u32 = 64;
pub const TIM_DIER_TIE: u32 = 64;
pub const TIM_DIER_BIE_Pos: u32 = 7;
pub const TIM_DIER_BIE_Msk: u32 = 128;
pub const TIM_DIER_BIE: u32 = 128;
pub const TIM_DIER_UDE_Pos: u32 = 8;
pub const TIM_DIER_UDE_Msk: u32 = 256;
pub const TIM_DIER_UDE: u32 = 256;
pub const TIM_DIER_CC1DE_Pos: u32 = 9;
pub const TIM_DIER_CC1DE_Msk: u32 = 512;
pub const TIM_DIER_CC1DE: u32 = 512;
pub const TIM_DIER_CC2DE_Pos: u32 = 10;
pub const TIM_DIER_CC2DE_Msk: u32 = 1024;
pub const TIM_DIER_CC2DE: u32 = 1024;
pub const TIM_DIER_CC3DE_Pos: u32 = 11;
pub const TIM_DIER_CC3DE_Msk: u32 = 2048;
pub const TIM_DIER_CC3DE: u32 = 2048;
pub const TIM_DIER_CC4DE_Pos: u32 = 12;
pub const TIM_DIER_CC4DE_Msk: u32 = 4096;
pub const TIM_DIER_CC4DE: u32 = 4096;
pub const TIM_DIER_COMDE_Pos: u32 = 13;
pub const TIM_DIER_COMDE_Msk: u32 = 8192;
pub const TIM_DIER_COMDE: u32 = 8192;
pub const TIM_DIER_TDE_Pos: u32 = 14;
pub const TIM_DIER_TDE_Msk: u32 = 16384;
pub const TIM_DIER_TDE: u32 = 16384;
pub const TIM_SR_UIF_Pos: u32 = 0;
pub const TIM_SR_UIF_Msk: u32 = 1;
pub const TIM_SR_UIF: u32 = 1;
pub const TIM_SR_CC1IF_Pos: u32 = 1;
pub const TIM_SR_CC1IF_Msk: u32 = 2;
pub const TIM_SR_CC1IF: u32 = 2;
pub const TIM_SR_CC2IF_Pos: u32 = 2;
pub const TIM_SR_CC2IF_Msk: u32 = 4;
pub const TIM_SR_CC2IF: u32 = 4;
pub const TIM_SR_CC3IF_Pos: u32 = 3;
pub const TIM_SR_CC3IF_Msk: u32 = 8;
pub const TIM_SR_CC3IF: u32 = 8;
pub const TIM_SR_CC4IF_Pos: u32 = 4;
pub const TIM_SR_CC4IF_Msk: u32 = 16;
pub const TIM_SR_CC4IF: u32 = 16;
pub const TIM_SR_COMIF_Pos: u32 = 5;
pub const TIM_SR_COMIF_Msk: u32 = 32;
pub const TIM_SR_COMIF: u32 = 32;
pub const TIM_SR_TIF_Pos: u32 = 6;
pub const TIM_SR_TIF_Msk: u32 = 64;
pub const TIM_SR_TIF: u32 = 64;
pub const TIM_SR_BIF_Pos: u32 = 7;
pub const TIM_SR_BIF_Msk: u32 = 128;
pub const TIM_SR_BIF: u32 = 128;
pub const TIM_SR_CC1OF_Pos: u32 = 9;
pub const TIM_SR_CC1OF_Msk: u32 = 512;
pub const TIM_SR_CC1OF: u32 = 512;
pub const TIM_SR_CC2OF_Pos: u32 = 10;
pub const TIM_SR_CC2OF_Msk: u32 = 1024;
pub const TIM_SR_CC2OF: u32 = 1024;
pub const TIM_SR_CC3OF_Pos: u32 = 11;
pub const TIM_SR_CC3OF_Msk: u32 = 2048;
pub const TIM_SR_CC3OF: u32 = 2048;
pub const TIM_SR_CC4OF_Pos: u32 = 12;
pub const TIM_SR_CC4OF_Msk: u32 = 4096;
pub const TIM_SR_CC4OF: u32 = 4096;
pub const TIM_EGR_UG_Pos: u32 = 0;
pub const TIM_EGR_UG_Msk: u32 = 1;
pub const TIM_EGR_UG: u32 = 1;
pub const TIM_EGR_CC1G_Pos: u32 = 1;
pub const TIM_EGR_CC1G_Msk: u32 = 2;
pub const TIM_EGR_CC1G: u32 = 2;
pub const TIM_EGR_CC2G_Pos: u32 = 2;
pub const TIM_EGR_CC2G_Msk: u32 = 4;
pub const TIM_EGR_CC2G: u32 = 4;
pub const TIM_EGR_CC3G_Pos: u32 = 3;
pub const TIM_EGR_CC3G_Msk: u32 = 8;
pub const TIM_EGR_CC3G: u32 = 8;
pub const TIM_EGR_CC4G_Pos: u32 = 4;
pub const TIM_EGR_CC4G_Msk: u32 = 16;
pub const TIM_EGR_CC4G: u32 = 16;
pub const TIM_EGR_COMG_Pos: u32 = 5;
pub const TIM_EGR_COMG_Msk: u32 = 32;
pub const TIM_EGR_COMG: u32 = 32;
pub const TIM_EGR_TG_Pos: u32 = 6;
pub const TIM_EGR_TG_Msk: u32 = 64;
pub const TIM_EGR_TG: u32 = 64;
pub const TIM_EGR_BG_Pos: u32 = 7;
pub const TIM_EGR_BG_Msk: u32 = 128;
pub const TIM_EGR_BG: u32 = 128;
pub const TIM_CCMR1_CC1S_Pos: u32 = 0;
pub const TIM_CCMR1_CC1S_Msk: u32 = 3;
pub const TIM_CCMR1_CC1S: u32 = 3;
pub const TIM_CCMR1_CC1S_0: u32 = 1;
pub const TIM_CCMR1_CC1S_1: u32 = 2;
pub const TIM_CCMR1_OC1FE_Pos: u32 = 2;
pub const TIM_CCMR1_OC1FE_Msk: u32 = 4;
pub const TIM_CCMR1_OC1FE: u32 = 4;
pub const TIM_CCMR1_OC1PE_Pos: u32 = 3;
pub const TIM_CCMR1_OC1PE_Msk: u32 = 8;
pub const TIM_CCMR1_OC1PE: u32 = 8;
pub const TIM_CCMR1_OC1M_Pos: u32 = 4;
pub const TIM_CCMR1_OC1M_Msk: u32 = 112;
pub const TIM_CCMR1_OC1M: u32 = 112;
pub const TIM_CCMR1_OC1M_0: u32 = 16;
pub const TIM_CCMR1_OC1M_1: u32 = 32;
pub const TIM_CCMR1_OC1M_2: u32 = 64;
pub const TIM_CCMR1_OC1CE_Pos: u32 = 7;
pub const TIM_CCMR1_OC1CE_Msk: u32 = 128;
pub const TIM_CCMR1_OC1CE: u32 = 128;
pub const TIM_CCMR1_CC2S_Pos: u32 = 8;
pub const TIM_CCMR1_CC2S_Msk: u32 = 768;
pub const TIM_CCMR1_CC2S: u32 = 768;
pub const TIM_CCMR1_CC2S_0: u32 = 256;
pub const TIM_CCMR1_CC2S_1: u32 = 512;
pub const TIM_CCMR1_OC2FE_Pos: u32 = 10;
pub const TIM_CCMR1_OC2FE_Msk: u32 = 1024;
pub const TIM_CCMR1_OC2FE: u32 = 1024;
pub const TIM_CCMR1_OC2PE_Pos: u32 = 11;
pub const TIM_CCMR1_OC2PE_Msk: u32 = 2048;
pub const TIM_CCMR1_OC2PE: u32 = 2048;
pub const TIM_CCMR1_OC2M_Pos: u32 = 12;
pub const TIM_CCMR1_OC2M_Msk: u32 = 28672;
pub const TIM_CCMR1_OC2M: u32 = 28672;
pub const TIM_CCMR1_OC2M_0: u32 = 4096;
pub const TIM_CCMR1_OC2M_1: u32 = 8192;
pub const TIM_CCMR1_OC2M_2: u32 = 16384;
pub const TIM_CCMR1_OC2CE_Pos: u32 = 15;
pub const TIM_CCMR1_OC2CE_Msk: u32 = 32768;
pub const TIM_CCMR1_OC2CE: u32 = 32768;
pub const TIM_CCMR1_IC1PSC_Pos: u32 = 2;
pub const TIM_CCMR1_IC1PSC_Msk: u32 = 12;
pub const TIM_CCMR1_IC1PSC: u32 = 12;
pub const TIM_CCMR1_IC1PSC_0: u32 = 4;
pub const TIM_CCMR1_IC1PSC_1: u32 = 8;
pub const TIM_CCMR1_IC1F_Pos: u32 = 4;
pub const TIM_CCMR1_IC1F_Msk: u32 = 240;
pub const TIM_CCMR1_IC1F: u32 = 240;
pub const TIM_CCMR1_IC1F_0: u32 = 16;
pub const TIM_CCMR1_IC1F_1: u32 = 32;
pub const TIM_CCMR1_IC1F_2: u32 = 64;
pub const TIM_CCMR1_IC1F_3: u32 = 128;
pub const TIM_CCMR1_IC2PSC_Pos: u32 = 10;
pub const TIM_CCMR1_IC2PSC_Msk: u32 = 3072;
pub const TIM_CCMR1_IC2PSC: u32 = 3072;
pub const TIM_CCMR1_IC2PSC_0: u32 = 1024;
pub const TIM_CCMR1_IC2PSC_1: u32 = 2048;
pub const TIM_CCMR1_IC2F_Pos: u32 = 12;
pub const TIM_CCMR1_IC2F_Msk: u32 = 61440;
pub const TIM_CCMR1_IC2F: u32 = 61440;
pub const TIM_CCMR1_IC2F_0: u32 = 4096;
pub const TIM_CCMR1_IC2F_1: u32 = 8192;
pub const TIM_CCMR1_IC2F_2: u32 = 16384;
pub const TIM_CCMR1_IC2F_3: u32 = 32768;
pub const TIM_CCMR2_CC3S_Pos: u32 = 0;
pub const TIM_CCMR2_CC3S_Msk: u32 = 3;
pub const TIM_CCMR2_CC3S: u32 = 3;
pub const TIM_CCMR2_CC3S_0: u32 = 1;
pub const TIM_CCMR2_CC3S_1: u32 = 2;
pub const TIM_CCMR2_OC3FE_Pos: u32 = 2;
pub const TIM_CCMR2_OC3FE_Msk: u32 = 4;
pub const TIM_CCMR2_OC3FE: u32 = 4;
pub const TIM_CCMR2_OC3PE_Pos: u32 = 3;
pub const TIM_CCMR2_OC3PE_Msk: u32 = 8;
pub const TIM_CCMR2_OC3PE: u32 = 8;
pub const TIM_CCMR2_OC3M_Pos: u32 = 4;
pub const TIM_CCMR2_OC3M_Msk: u32 = 112;
pub const TIM_CCMR2_OC3M: u32 = 112;
pub const TIM_CCMR2_OC3M_0: u32 = 16;
pub const TIM_CCMR2_OC3M_1: u32 = 32;
pub const TIM_CCMR2_OC3M_2: u32 = 64;
pub const TIM_CCMR2_OC3CE_Pos: u32 = 7;
pub const TIM_CCMR2_OC3CE_Msk: u32 = 128;
pub const TIM_CCMR2_OC3CE: u32 = 128;
pub const TIM_CCMR2_CC4S_Pos: u32 = 8;
pub const TIM_CCMR2_CC4S_Msk: u32 = 768;
pub const TIM_CCMR2_CC4S: u32 = 768;
pub const TIM_CCMR2_CC4S_0: u32 = 256;
pub const TIM_CCMR2_CC4S_1: u32 = 512;
pub const TIM_CCMR2_OC4FE_Pos: u32 = 10;
pub const TIM_CCMR2_OC4FE_Msk: u32 = 1024;
pub const TIM_CCMR2_OC4FE: u32 = 1024;
pub const TIM_CCMR2_OC4PE_Pos: u32 = 11;
pub const TIM_CCMR2_OC4PE_Msk: u32 = 2048;
pub const TIM_CCMR2_OC4PE: u32 = 2048;
pub const TIM_CCMR2_OC4M_Pos: u32 = 12;
pub const TIM_CCMR2_OC4M_Msk: u32 = 28672;
pub const TIM_CCMR2_OC4M: u32 = 28672;
pub const TIM_CCMR2_OC4M_0: u32 = 4096;
pub const TIM_CCMR2_OC4M_1: u32 = 8192;
pub const TIM_CCMR2_OC4M_2: u32 = 16384;
pub const TIM_CCMR2_OC4CE_Pos: u32 = 15;
pub const TIM_CCMR2_OC4CE_Msk: u32 = 32768;
pub const TIM_CCMR2_OC4CE: u32 = 32768;
pub const TIM_CCMR2_IC3PSC_Pos: u32 = 2;
pub const TIM_CCMR2_IC3PSC_Msk: u32 = 12;
pub const TIM_CCMR2_IC3PSC: u32 = 12;
pub const TIM_CCMR2_IC3PSC_0: u32 = 4;
pub const TIM_CCMR2_IC3PSC_1: u32 = 8;
pub const TIM_CCMR2_IC3F_Pos: u32 = 4;
pub const TIM_CCMR2_IC3F_Msk: u32 = 240;
pub const TIM_CCMR2_IC3F: u32 = 240;
pub const TIM_CCMR2_IC3F_0: u32 = 16;
pub const TIM_CCMR2_IC3F_1: u32 = 32;
pub const TIM_CCMR2_IC3F_2: u32 = 64;
pub const TIM_CCMR2_IC3F_3: u32 = 128;
pub const TIM_CCMR2_IC4PSC_Pos: u32 = 10;
pub const TIM_CCMR2_IC4PSC_Msk: u32 = 3072;
pub const TIM_CCMR2_IC4PSC: u32 = 3072;
pub const TIM_CCMR2_IC4PSC_0: u32 = 1024;
pub const TIM_CCMR2_IC4PSC_1: u32 = 2048;
pub const TIM_CCMR2_IC4F_Pos: u32 = 12;
pub const TIM_CCMR2_IC4F_Msk: u32 = 61440;
pub const TIM_CCMR2_IC4F: u32 = 61440;
pub const TIM_CCMR2_IC4F_0: u32 = 4096;
pub const TIM_CCMR2_IC4F_1: u32 = 8192;
pub const TIM_CCMR2_IC4F_2: u32 = 16384;
pub const TIM_CCMR2_IC4F_3: u32 = 32768;
pub const TIM_CCER_CC1E_Pos: u32 = 0;
pub const TIM_CCER_CC1E_Msk: u32 = 1;
pub const TIM_CCER_CC1E: u32 = 1;
pub const TIM_CCER_CC1P_Pos: u32 = 1;
pub const TIM_CCER_CC1P_Msk: u32 = 2;
pub const TIM_CCER_CC1P: u32 = 2;
pub const TIM_CCER_CC1NE_Pos: u32 = 2;
pub const TIM_CCER_CC1NE_Msk: u32 = 4;
pub const TIM_CCER_CC1NE: u32 = 4;
pub const TIM_CCER_CC1NP_Pos: u32 = 3;
pub const TIM_CCER_CC1NP_Msk: u32 = 8;
pub const TIM_CCER_CC1NP: u32 = 8;
pub const TIM_CCER_CC2E_Pos: u32 = 4;
pub const TIM_CCER_CC2E_Msk: u32 = 16;
pub const TIM_CCER_CC2E: u32 = 16;
pub const TIM_CCER_CC2P_Pos: u32 = 5;
pub const TIM_CCER_CC2P_Msk: u32 = 32;
pub const TIM_CCER_CC2P: u32 = 32;
pub const TIM_CCER_CC2NE_Pos: u32 = 6;
pub const TIM_CCER_CC2NE_Msk: u32 = 64;
pub const TIM_CCER_CC2NE: u32 = 64;
pub const TIM_CCER_CC2NP_Pos: u32 = 7;
pub const TIM_CCER_CC2NP_Msk: u32 = 128;
pub const TIM_CCER_CC2NP: u32 = 128;
pub const TIM_CCER_CC3E_Pos: u32 = 8;
pub const TIM_CCER_CC3E_Msk: u32 = 256;
pub const TIM_CCER_CC3E: u32 = 256;
pub const TIM_CCER_CC3P_Pos: u32 = 9;
pub const TIM_CCER_CC3P_Msk: u32 = 512;
pub const TIM_CCER_CC3P: u32 = 512;
pub const TIM_CCER_CC3NE_Pos: u32 = 10;
pub const TIM_CCER_CC3NE_Msk: u32 = 1024;
pub const TIM_CCER_CC3NE: u32 = 1024;
pub const TIM_CCER_CC3NP_Pos: u32 = 11;
pub const TIM_CCER_CC3NP_Msk: u32 = 2048;
pub const TIM_CCER_CC3NP: u32 = 2048;
pub const TIM_CCER_CC4E_Pos: u32 = 12;
pub const TIM_CCER_CC4E_Msk: u32 = 4096;
pub const TIM_CCER_CC4E: u32 = 4096;
pub const TIM_CCER_CC4P_Pos: u32 = 13;
pub const TIM_CCER_CC4P_Msk: u32 = 8192;
pub const TIM_CCER_CC4P: u32 = 8192;
pub const TIM_CCER_CC4NP_Pos: u32 = 15;
pub const TIM_CCER_CC4NP_Msk: u32 = 32768;
pub const TIM_CCER_CC4NP: u32 = 32768;
pub const TIM_CNT_CNT_Pos: u32 = 0;
pub const TIM_CNT_CNT_Msk: u32 = 65535;
pub const TIM_CNT_CNT: u32 = 65535;
pub const TIM_PSC_PSC_Pos: u32 = 0;
pub const TIM_PSC_PSC_Msk: u32 = 65535;
pub const TIM_PSC_PSC: u32 = 65535;
pub const TIM_ARR_ARR_Pos: u32 = 0;
pub const TIM_ARR_ARR_Msk: u32 = 65535;
pub const TIM_ARR_ARR: u32 = 65535;
pub const TIM_RCR_REP_Pos: u32 = 0;
pub const TIM_RCR_REP_Msk: u32 = 255;
pub const TIM_RCR_REP: u32 = 255;
pub const TIM_CCR1_CCR1_Pos: u32 = 0;
pub const TIM_CCR1_CCR1_Msk: u32 = 65535;
pub const TIM_CCR1_CCR1: u32 = 65535;
pub const TIM_CCR2_CCR2_Pos: u32 = 0;
pub const TIM_CCR2_CCR2_Msk: u32 = 65535;
pub const TIM_CCR2_CCR2: u32 = 65535;
pub const TIM_CCR3_CCR3_Pos: u32 = 0;
pub const TIM_CCR3_CCR3_Msk: u32 = 65535;
pub const TIM_CCR3_CCR3: u32 = 65535;
pub const TIM_CCR4_CCR4_Pos: u32 = 0;
pub const TIM_CCR4_CCR4_Msk: u32 = 65535;
pub const TIM_CCR4_CCR4: u32 = 65535;
pub const TIM_BDTR_DTG_Pos: u32 = 0;
pub const TIM_BDTR_DTG_Msk: u32 = 255;
pub const TIM_BDTR_DTG: u32 = 255;
pub const TIM_BDTR_DTG_0: u32 = 1;
pub const TIM_BDTR_DTG_1: u32 = 2;
pub const TIM_BDTR_DTG_2: u32 = 4;
pub const TIM_BDTR_DTG_3: u32 = 8;
pub const TIM_BDTR_DTG_4: u32 = 16;
pub const TIM_BDTR_DTG_5: u32 = 32;
pub const TIM_BDTR_DTG_6: u32 = 64;
pub const TIM_BDTR_DTG_7: u32 = 128;
pub const TIM_BDTR_LOCK_Pos: u32 = 8;
pub const TIM_BDTR_LOCK_Msk: u32 = 768;
pub const TIM_BDTR_LOCK: u32 = 768;
pub const TIM_BDTR_LOCK_0: u32 = 256;
pub const TIM_BDTR_LOCK_1: u32 = 512;
pub const TIM_BDTR_OSSI_Pos: u32 = 10;
pub const TIM_BDTR_OSSI_Msk: u32 = 1024;
pub const TIM_BDTR_OSSI: u32 = 1024;
pub const TIM_BDTR_OSSR_Pos: u32 = 11;
pub const TIM_BDTR_OSSR_Msk: u32 = 2048;
pub const TIM_BDTR_OSSR: u32 = 2048;
pub const TIM_BDTR_BKE_Pos: u32 = 12;
pub const TIM_BDTR_BKE_Msk: u32 = 4096;
pub const TIM_BDTR_BKE: u32 = 4096;
pub const TIM_BDTR_BKP_Pos: u32 = 13;
pub const TIM_BDTR_BKP_Msk: u32 = 8192;
pub const TIM_BDTR_BKP: u32 = 8192;
pub const TIM_BDTR_AOE_Pos: u32 = 14;
pub const TIM_BDTR_AOE_Msk: u32 = 16384;
pub const TIM_BDTR_AOE: u32 = 16384;
pub const TIM_BDTR_MOE_Pos: u32 = 15;
pub const TIM_BDTR_MOE_Msk: u32 = 32768;
pub const TIM_BDTR_MOE: u32 = 32768;
pub const TIM_DCR_DBA_Pos: u32 = 0;
pub const TIM_DCR_DBA_Msk: u32 = 31;
pub const TIM_DCR_DBA: u32 = 31;
pub const TIM_DCR_DBA_0: u32 = 1;
pub const TIM_DCR_DBA_1: u32 = 2;
pub const TIM_DCR_DBA_2: u32 = 4;
pub const TIM_DCR_DBA_3: u32 = 8;
pub const TIM_DCR_DBA_4: u32 = 16;
pub const TIM_DCR_DBL_Pos: u32 = 8;
pub const TIM_DCR_DBL_Msk: u32 = 7936;
pub const TIM_DCR_DBL: u32 = 7936;
pub const TIM_DCR_DBL_0: u32 = 256;
pub const TIM_DCR_DBL_1: u32 = 512;
pub const TIM_DCR_DBL_2: u32 = 1024;
pub const TIM_DCR_DBL_3: u32 = 2048;
pub const TIM_DCR_DBL_4: u32 = 4096;
pub const TIM_DMAR_DMAB_Pos: u32 = 0;
pub const TIM_DMAR_DMAB_Msk: u32 = 65535;
pub const TIM_DMAR_DMAB: u32 = 65535;
pub const TIM14_OR_TI1_RMP_Pos: u32 = 0;
pub const TIM14_OR_TI1_RMP_Msk: u32 = 3;
pub const TIM14_OR_TI1_RMP: u32 = 3;
pub const TIM14_OR_TI1_RMP_0: u32 = 1;
pub const TIM14_OR_TI1_RMP_1: u32 = 2;
pub const LPTIM_ISR_ARRM_Pos: u32 = 1;
pub const LPTIM_ISR_ARRM_Msk: u32 = 2;
pub const LPTIM_ISR_ARRM: u32 = 2;
pub const LPTIM_ICR_ARRMCF_Pos: u32 = 1;
pub const LPTIM_ICR_ARRMCF_Msk: u32 = 2;
pub const LPTIM_ICR_ARRMCF: u32 = 2;
pub const LPTIM_IER_ARRMIE_Pos: u32 = 1;
pub const LPTIM_IER_ARRMIE_Msk: u32 = 2;
pub const LPTIM_IER_ARRMIE: u32 = 2;
pub const LPTIM_CFGR_PRESC_Pos: u32 = 9;
pub const LPTIM_CFGR_PRESC_Msk: u32 = 3584;
pub const LPTIM_CFGR_PRESC: u32 = 3584;
pub const LPTIM_CFGR_PRESC_0: u32 = 512;
pub const LPTIM_CFGR_PRESC_1: u32 = 1024;
pub const LPTIM_CFGR_PRESC_2: u32 = 2048;
pub const LPTIM_CFGR_PRELOAD_Pos: u32 = 22;
pub const LPTIM_CFGR_PRELOAD_Msk: u32 = 4194304;
pub const LPTIM_CFGR_PRELOAD: u32 = 4194304;
pub const LPTIM_CR_ENABLE_Pos: u32 = 0;
pub const LPTIM_CR_ENABLE_Msk: u32 = 1;
pub const LPTIM_CR_ENABLE: u32 = 1;
pub const LPTIM_CR_SNGSTRT_Pos: u32 = 1;
pub const LPTIM_CR_SNGSTRT_Msk: u32 = 2;
pub const LPTIM_CR_SNGSTRT: u32 = 2;
pub const LPTIM_CR_RSTARE_Pos: u32 = 4;
pub const LPTIM_CR_RSTARE_Msk: u32 = 16;
pub const LPTIM_CR_RSTARE: u32 = 16;
pub const LPTIM_ARR_ARR_Pos: u32 = 0;
pub const LPTIM_ARR_ARR_Msk: u32 = 65535;
pub const LPTIM_ARR_ARR: u32 = 65535;
pub const LPTIM_CNT_CNT_Pos: u32 = 0;
pub const LPTIM_CNT_CNT_Msk: u32 = 65535;
pub const LPTIM_CNT_CNT: u32 = 65535;
pub const COMP_CSR_EN_Pos: u32 = 0;
pub const COMP_CSR_EN_Msk: u32 = 1;
pub const COMP_CSR_EN: u32 = 1;
pub const COMP_CSR_COMP1_EN: u32 = 1;
pub const COMP_CSR_COMP2_EN: u32 = 1;
pub const COMP_CSR_SCALER_EN_Pos: u32 = 1;
pub const COMP_CSR_SCALER_EN_Msk: u32 = 2;
pub const COMP_CSR_SCALER_EN: u32 = 2;
pub const COMP_CSR_INMSEL_Pos: u32 = 4;
pub const COMP_CSR_INMSEL_Msk: u32 = 240;
pub const COMP_CSR_INMSEL: u32 = 240;
pub const COMP_CSR_INMSEL_0: u32 = 16;
pub const COMP_CSR_INMSEL_1: u32 = 32;
pub const COMP_CSR_INMSEL_2: u32 = 64;
pub const COMP_CSR_INMSEL_3: u32 = 128;
pub const COMP_CSR_INPSEL_Pos: u32 = 8;
pub const COMP_CSR_INPSEL_Msk: u32 = 768;
pub const COMP_CSR_INPSEL: u32 = 768;
pub const COMP_CSR_INPSEL_0: u32 = 256;
pub const COMP_CSR_INPSEL_1: u32 = 512;
pub const COMP_CSR_WINMODE_Pos: u32 = 11;
pub const COMP_CSR_WINMODE_Msk: u32 = 2048;
pub const COMP_CSR_WINMODE: u32 = 2048;
pub const COMP_CSR_POLARITY_Pos: u32 = 15;
pub const COMP_CSR_POLARITY_Msk: u32 = 32768;
pub const COMP_CSR_POLARITY: u32 = 32768;
pub const COMP_CSR_HYST_Pos: u32 = 16;
pub const COMP_CSR_HYST_Msk: u32 = 65536;
pub const COMP_CSR_HYST: u32 = 65536;
pub const COMP_CSR_PWRMODE_Pos: u32 = 18;
pub const COMP_CSR_PWRMODE_Msk: u32 = 786432;
pub const COMP_CSR_PWRMODE: u32 = 786432;
pub const COMP_CSR_PWRMODE_0: u32 = 262144;
pub const COMP_CSR_PWRMODE_1: u32 = 524288;
pub const COMP_CSR_COMP_OUT_Pos: u32 = 30;
pub const COMP_CSR_COMP_OUT_Msk: u32 = 1073741824;
pub const COMP_CSR_COMP_OUT: u32 = 1073741824;
pub const COMP_CSR_LOCK_Pos: u32 = 31;
pub const COMP_CSR_LOCK_Msk: u32 = 2147483648;
pub const COMP_CSR_LOCK: u32 = 2147483648;
pub const COMP_FR_FLTEN_Pos: u32 = 0;
pub const COMP_FR_FLTEN_Msk: u32 = 1;
pub const COMP_FR_FLTEN: u32 = 1;
pub const COMP_FR_FLTCNT_Pos: u32 = 16;
pub const COMP_FR_FLTCNT_Msk: u32 = 4294901760;
pub const COMP_FR_FLTCNT: u32 = 4294901760;
pub const USART_SR_PE_Pos: u32 = 0;
pub const USART_SR_PE_Msk: u32 = 1;
pub const USART_SR_PE: u32 = 1;
pub const USART_SR_FE_Pos: u32 = 1;
pub const USART_SR_FE_Msk: u32 = 2;
pub const USART_SR_FE: u32 = 2;
pub const USART_SR_NE_Pos: u32 = 2;
pub const USART_SR_NE_Msk: u32 = 4;
pub const USART_SR_NE: u32 = 4;
pub const USART_SR_ORE_Pos: u32 = 3;
pub const USART_SR_ORE_Msk: u32 = 8;
pub const USART_SR_ORE: u32 = 8;
pub const USART_SR_IDLE_Pos: u32 = 4;
pub const USART_SR_IDLE_Msk: u32 = 16;
pub const USART_SR_IDLE: u32 = 16;
pub const USART_SR_RXNE_Pos: u32 = 5;
pub const USART_SR_RXNE_Msk: u32 = 32;
pub const USART_SR_RXNE: u32 = 32;
pub const USART_SR_TC_Pos: u32 = 6;
pub const USART_SR_TC_Msk: u32 = 64;
pub const USART_SR_TC: u32 = 64;
pub const USART_SR_TXE_Pos: u32 = 7;
pub const USART_SR_TXE_Msk: u32 = 128;
pub const USART_SR_TXE: u32 = 128;
pub const USART_SR_CTS_Pos: u32 = 9;
pub const USART_SR_CTS_Msk: u32 = 512;
pub const USART_SR_CTS: u32 = 512;
pub const USART_SR_ABRF_Pos: u32 = 10;
pub const USART_SR_ABRF_Msk: u32 = 1024;
pub const USART_SR_ABRF: u32 = 1024;
pub const USART_SR_ABRE_Pos: u32 = 11;
pub const USART_SR_ABRE_Msk: u32 = 2048;
pub const USART_SR_ABRE: u32 = 2048;
pub const USART_SR_ABRRQ_Pos: u32 = 12;
pub const USART_SR_ABRRQ_Msk: u32 = 4096;
pub const USART_SR_ABRRQ: u32 = 4096;
pub const USART_DR_DR_Pos: u32 = 0;
pub const USART_DR_DR_Msk: u32 = 511;
pub const USART_DR_DR: u32 = 511;
pub const USART_BRR_DIV_Fraction_Pos: u32 = 0;
pub const USART_BRR_DIV_Fraction_Msk: u32 = 15;
pub const USART_BRR_DIV_Fraction: u32 = 15;
pub const USART_BRR_DIV_Mantissa_Pos: u32 = 4;
pub const USART_BRR_DIV_Mantissa_Msk: u32 = 65520;
pub const USART_BRR_DIV_Mantissa: u32 = 65520;
pub const USART_CR1_SBK_Pos: u32 = 0;
pub const USART_CR1_SBK_Msk: u32 = 1;
pub const USART_CR1_SBK: u32 = 1;
pub const USART_CR1_RWU_Pos: u32 = 1;
pub const USART_CR1_RWU_Msk: u32 = 2;
pub const USART_CR1_RWU: u32 = 2;
pub const USART_CR1_RE_Pos: u32 = 2;
pub const USART_CR1_RE_Msk: u32 = 4;
pub const USART_CR1_RE: u32 = 4;
pub const USART_CR1_TE_Pos: u32 = 3;
pub const USART_CR1_TE_Msk: u32 = 8;
pub const USART_CR1_TE: u32 = 8;
pub const USART_CR1_IDLEIE_Pos: u32 = 4;
pub const USART_CR1_IDLEIE_Msk: u32 = 16;
pub const USART_CR1_IDLEIE: u32 = 16;
pub const USART_CR1_RXNEIE_Pos: u32 = 5;
pub const USART_CR1_RXNEIE_Msk: u32 = 32;
pub const USART_CR1_RXNEIE: u32 = 32;
pub const USART_CR1_TCIE_Pos: u32 = 6;
pub const USART_CR1_TCIE_Msk: u32 = 64;
pub const USART_CR1_TCIE: u32 = 64;
pub const USART_CR1_TXEIE_Pos: u32 = 7;
pub const USART_CR1_TXEIE_Msk: u32 = 128;
pub const USART_CR1_TXEIE: u32 = 128;
pub const USART_CR1_PEIE_Pos: u32 = 8;
pub const USART_CR1_PEIE_Msk: u32 = 256;
pub const USART_CR1_PEIE: u32 = 256;
pub const USART_CR1_PS_Pos: u32 = 9;
pub const USART_CR1_PS_Msk: u32 = 512;
pub const USART_CR1_PS: u32 = 512;
pub const USART_CR1_PCE_Pos: u32 = 10;
pub const USART_CR1_PCE_Msk: u32 = 1024;
pub const USART_CR1_PCE: u32 = 1024;
pub const USART_CR1_WAKE_Pos: u32 = 11;
pub const USART_CR1_WAKE_Msk: u32 = 2048;
pub const USART_CR1_WAKE: u32 = 2048;
pub const USART_CR1_M_Pos: u32 = 12;
pub const USART_CR1_M_Msk: u32 = 4096;
pub const USART_CR1_M: u32 = 4096;
pub const USART_CR1_UE_Pos: u32 = 13;
pub const USART_CR1_UE_Msk: u32 = 8192;
pub const USART_CR1_UE: u32 = 8192;
pub const USART_CR2_ADD_Pos: u32 = 0;
pub const USART_CR2_ADD_Msk: u32 = 15;
pub const USART_CR2_ADD: u32 = 15;
pub const USART_CR2_LBCL_Pos: u32 = 8;
pub const USART_CR2_LBCL_Msk: u32 = 256;
pub const USART_CR2_LBCL: u32 = 256;
pub const USART_CR2_CPHA_Pos: u32 = 9;
pub const USART_CR2_CPHA_Msk: u32 = 512;
pub const USART_CR2_CPHA: u32 = 512;
pub const USART_CR2_CPOL_Pos: u32 = 10;
pub const USART_CR2_CPOL_Msk: u32 = 1024;
pub const USART_CR2_CPOL: u32 = 1024;
pub const USART_CR2_CLKEN_Pos: u32 = 11;
pub const USART_CR2_CLKEN_Msk: u32 = 2048;
pub const USART_CR2_CLKEN: u32 = 2048;
pub const USART_CR2_STOP_Pos: u32 = 13;
pub const USART_CR2_STOP_Msk: u32 = 8192;
pub const USART_CR2_STOP: u32 = 8192;
pub const USART_CR3_EIE_Pos: u32 = 0;
pub const USART_CR3_EIE_Msk: u32 = 1;
pub const USART_CR3_EIE: u32 = 1;
pub const USART_CR3_HDSEL_Pos: u32 = 3;
pub const USART_CR3_HDSEL_Msk: u32 = 8;
pub const USART_CR3_HDSEL: u32 = 8;
pub const USART_CR3_DMAR_Pos: u32 = 6;
pub const USART_CR3_DMAR_Msk: u32 = 64;
pub const USART_CR3_DMAR: u32 = 64;
pub const USART_CR3_DMAT_Pos: u32 = 7;
pub const USART_CR3_DMAT_Msk: u32 = 128;
pub const USART_CR3_DMAT: u32 = 128;
pub const USART_CR3_RTSE_Pos: u32 = 8;
pub const USART_CR3_RTSE_Msk: u32 = 256;
pub const USART_CR3_RTSE: u32 = 256;
pub const USART_CR3_CTSE_Pos: u32 = 9;
pub const USART_CR3_CTSE_Msk: u32 = 512;
pub const USART_CR3_CTSE: u32 = 512;
pub const USART_CR3_CTSIE_Pos: u32 = 10;
pub const USART_CR3_CTSIE_Msk: u32 = 1024;
pub const USART_CR3_CTSIE: u32 = 1024;
pub const USART_CR3_OVER8_Pos: u32 = 11;
pub const USART_CR3_OVER8_Msk: u32 = 2048;
pub const USART_CR3_OVER8: u32 = 2048;
pub const USART_CR3_ABREN_Pos: u32 = 12;
pub const USART_CR3_ABREN_Msk: u32 = 4096;
pub const USART_CR3_ABREN: u32 = 4096;
pub const USART_CR3_ABRMODE_Pos: u32 = 13;
pub const USART_CR3_ABRMODE_Msk: u32 = 24576;
pub const USART_CR3_ABRMODE: u32 = 24576;
pub const USART_CR3_ABRMODE_0: u32 = 8192;
pub const USART_CR3_ABRMODE_1: u32 = 16384;
pub const WWDG_CR_T_Pos: u32 = 0;
pub const WWDG_CR_T_Msk: u32 = 127;
pub const WWDG_CR_T: u32 = 127;
pub const WWDG_CR_T_0: u32 = 1;
pub const WWDG_CR_T_1: u32 = 2;
pub const WWDG_CR_T_2: u32 = 4;
pub const WWDG_CR_T_3: u32 = 8;
pub const WWDG_CR_T_4: u32 = 16;
pub const WWDG_CR_T_5: u32 = 32;
pub const WWDG_CR_T_6: u32 = 64;
pub const WWDG_CR_WDGA_Pos: u32 = 7;
pub const WWDG_CR_WDGA_Msk: u32 = 128;
pub const WWDG_CR_WDGA: u32 = 128;
pub const WWDG_CFR_W_Pos: u32 = 0;
pub const WWDG_CFR_W_Msk: u32 = 127;
pub const WWDG_CFR_W: u32 = 127;
pub const WWDG_CFR_W_0: u32 = 1;
pub const WWDG_CFR_W_1: u32 = 2;
pub const WWDG_CFR_W_2: u32 = 4;
pub const WWDG_CFR_W_3: u32 = 8;
pub const WWDG_CFR_W_4: u32 = 16;
pub const WWDG_CFR_W_5: u32 = 32;
pub const WWDG_CFR_W_6: u32 = 64;
pub const WWDG_CFR_WDGTB_Pos: u32 = 7;
pub const WWDG_CFR_WDGTB_Msk: u32 = 384;
pub const WWDG_CFR_WDGTB: u32 = 384;
pub const WWDG_CFR_WDGTB_0: u32 = 128;
pub const WWDG_CFR_WDGTB_1: u32 = 256;
pub const WWDG_CFR_EWI_Pos: u32 = 9;
pub const WWDG_CFR_EWI_Msk: u32 = 512;
pub const WWDG_CFR_EWI: u32 = 512;
pub const WWDG_SR_EWIF_Pos: u32 = 0;
pub const WWDG_SR_EWIF_Msk: u32 = 1;
pub const WWDG_SR_EWIF: u32 = 1;
pub const HAL_MAX_DELAY: u32 = 4294967295;
pub const CR_REG_INDEX: u32 = 1;
pub const BDCR_REG_INDEX: u32 = 2;
pub const CSR_REG_INDEX: u32 = 3;
pub const RCC_FLAG_MASK: u32 = 31;
pub const RCC_DBP_TIMEOUT_VALUE: u32 = 2;
pub const RCC_OSCILLATORTYPE_NONE: u32 = 0;
pub const RCC_OSCILLATORTYPE_HSE: u32 = 1;
pub const RCC_OSCILLATORTYPE_HSI: u32 = 2;
pub const RCC_OSCILLATORTYPE_LSE: u32 = 4;
pub const RCC_OSCILLATORTYPE_LSI: u32 = 8;
pub const RCC_HSE_OFF: u32 = 0;
pub const RCC_HSE_ON: u32 = 65536;
pub const RCC_HSE_4_8MHz: u32 = 4;
pub const RCC_HSE_8_16MHz: u32 = 8;
pub const RCC_HSE_16_32MHz: u32 = 12;
pub const RCC_LSE_OFF: u32 = 0;
pub const RCC_LSE_ON: u32 = 1;
pub const RCC_LSEDRIVE_LOW: u32 = 65536;
pub const RCC_LSEDRIVE_MEDIUM: u32 = 131072;
pub const RCC_LSEDRIVE_HIGH: u32 = 196608;
pub const RCC_HSI_OFF: u32 = 0;
pub const RCC_HSI_ON: u32 = 256;
pub const RCC_HSI_DIV1: u32 = 0;
pub const RCC_HSI_DIV2: u32 = 2048;
pub const RCC_HSI_DIV4: u32 = 4096;
pub const RCC_HSI_DIV8: u32 = 6144;
pub const RCC_HSI_DIV16: u32 = 8192;
pub const RCC_HSI_DIV32: u32 = 10240;
pub const RCC_HSI_DIV64: u32 = 12288;
pub const RCC_HSI_DIV128: u32 = 14336;
pub const RCC_LSI_OFF: u32 = 0;
pub const RCC_LSI_ON: u32 = 1;
pub const RCC_PLL_NONE: u32 = 0;
pub const RCC_PLL_OFF: u32 = 1;
pub const RCC_PLL_ON: u32 = 2;
pub const RCC_PLLSOURCE_NONE: u32 = 0;
pub const RCC_PLLSOURCE_HSI: u32 = 0;
pub const RCC_PLLSOURCE_HSE: u32 = 1;
pub const RCC_CLOCKTYPE_SYSCLK: u32 = 1;
pub const RCC_CLOCKTYPE_HCLK: u32 = 2;
pub const RCC_CLOCKTYPE_PCLK1: u32 = 4;
pub const RCC_SYSCLKSOURCE_HSI: u32 = 0;
pub const RCC_SYSCLKSOURCE_HSE: u32 = 1;
pub const RCC_SYSCLKSOURCE_PLLCLK: u32 = 2;
pub const RCC_SYSCLKSOURCE_LSI: u32 = 3;
pub const RCC_SYSCLKSOURCE_LSE: u32 = 4;
pub const RCC_SYSCLKSOURCE_STATUS_HSI: u32 = 0;
pub const RCC_SYSCLKSOURCE_STATUS_HSE: u32 = 8;
pub const RCC_SYSCLKSOURCE_STATUS_PLLCLK: u32 = 16;
pub const RCC_SYSCLKSOURCE_STATUS_LSI: u32 = 24;
pub const RCC_SYSCLKSOURCE_STATUS_LSE: u32 = 32;
pub const RCC_SYSCLK_DIV1: u32 = 0;
pub const RCC_SYSCLK_DIV2: u32 = 2048;
pub const RCC_SYSCLK_DIV4: u32 = 2304;
pub const RCC_SYSCLK_DIV8: u32 = 2560;
pub const RCC_SYSCLK_DIV16: u32 = 2816;
pub const RCC_SYSCLK_DIV64: u32 = 3072;
pub const RCC_SYSCLK_DIV128: u32 = 3328;
pub const RCC_SYSCLK_DIV256: u32 = 3584;
pub const RCC_SYSCLK_DIV512: u32 = 3840;
pub const RCC_HCLK_DIV1: u32 = 0;
pub const RCC_HCLK_DIV2: u32 = 16384;
pub const RCC_HCLK_DIV4: u32 = 20480;
pub const RCC_HCLK_DIV8: u32 = 24576;
pub const RCC_HCLK_DIV16: u32 = 28672;
pub const RCC_RTCCLKSOURCE_NONE: u32 = 0;
pub const RCC_RTCCLKSOURCE_LSE: u32 = 256;
pub const RCC_RTCCLKSOURCE_LSI: u32 = 512;
pub const RCC_RTCCLKSOURCE_HSE_DIV128: u32 = 768;
pub const RCC_MCO: u32 = 0;
pub const RCC_MCO1: u32 = 0;
pub const RCC_MCO2: u32 = 1;
pub const RCC_MCO3: u32 = 2;
pub const RCC_MCO4: u32 = 3;
pub const RCC_MCO5: u32 = 4;
pub const RCC_MCO6: u32 = 5;
pub const RCC_MCO7: u32 = 6;
pub const RCC_MCO1SOURCE_NOCLOCK: u32 = 0;
pub const RCC_MCO1SOURCE_SYSCLK: u32 = 16777216;
pub const RCC_MCO1SOURCE_HSI10M: u32 = 33554432;
pub const RCC_MCO1SOURCE_HSI: u32 = 50331648;
pub const RCC_MCO1SOURCE_HSE: u32 = 67108864;
pub const RCC_MCO1SOURCE_PLLCLK: u32 = 83886080;
pub const RCC_MCO1SOURCE_LSI: u32 = 100663296;
pub const RCC_MCO1SOURCE_LSE: u32 = 117440512;
pub const RCC_MCODIV_1: u32 = 0;
pub const RCC_MCODIV_2: u32 = 268435456;
pub const RCC_MCODIV_4: u32 = 536870912;
pub const RCC_MCODIV_8: u32 = 805306368;
pub const RCC_MCODIV_16: u32 = 1073741824;
pub const RCC_MCODIV_32: u32 = 1342177280;
pub const RCC_MCODIV_64: u32 = 1610612736;
pub const RCC_MCODIV_128: u32 = 1879048192;
pub const RCC_IT_LSIRDY: u32 = 1;
pub const RCC_IT_LSERDY: u32 = 2;
pub const RCC_IT_LSECSS: u32 = 512;
pub const RCC_IT_HSIRDY: u32 = 8;
pub const RCC_IT_HSERDY: u32 = 16;
pub const RCC_IT_PLLRDY: u32 = 32;
pub const RCC_IT_CSS: u32 = 256;
pub const RCC_FLAG_HSIRDY: u32 = 42;
pub const RCC_FLAG_HSERDY: u32 = 49;
pub const RCC_FLAG_PLLRDY: u32 = 57;
pub const RCC_FLAG_LSERDY: u32 = 65;
pub const RCC_FLAG_LSIRDY: u32 = 97;
pub const RCC_FLAG_OBLRST: u32 = 121;
pub const RCC_FLAG_PINRST: u32 = 122;
pub const RCC_FLAG_PWRRST: u32 = 123;
pub const RCC_FLAG_SFTRST: u32 = 124;
pub const RCC_FLAG_IWDGRST: u32 = 125;
pub const RCC_FLAG_WWDGRST: u32 = 126;
pub const RCC_LSCOSOURCE_LSI: u32 = 0;
pub const RCC_LSCOSOURCE_LSE: u32 = 33554432;
pub const RCC_PERIPHCLK_PVD: u32 = 1;
pub const RCC_PERIPHCLK_COMP1: u32 = 2;
pub const RCC_PERIPHCLK_COMP2: u32 = 32;
pub const RCC_PERIPHCLK_LPTIM: u32 = 512;
pub const RCC_PERIPHCLK_RTC: u32 = 131072;
pub const RCC_PVDCLKSOURCE_PCLK: u32 = 0;
pub const RCC_PVDCLKSOURCE_LSC: u32 = 128;
pub const RCC_COMP1CLKSOURCE_PCLK: u32 = 0;
pub const RCC_COMP1CLKSOURCE_LSC: u32 = 256;
pub const RCC_COMP2CLKSOURCE_PCLK: u32 = 0;
pub const RCC_COMP2CLKSOURCE_LSC: u32 = 512;
pub const RCC_LPTIMCLKSOURCE_PCLK: u32 = 0;
pub const RCC_LPTIMCLKSOURCE_LSI: u32 = 262144;
pub const RCC_LPTIMCLKSOURCE_LSE: u32 = 786432;
pub const EXTI_MODE_NONE: u32 = 0;
pub const EXTI_MODE_INTERRUPT: u32 = 1;
pub const EXTI_MODE_EVENT: u32 = 2;
pub const EXTI_TRIGGER_NONE: u32 = 0;
pub const EXTI_TRIGGER_RISING: u32 = 1;
pub const EXTI_TRIGGER_FALLING: u32 = 2;
pub const EXTI_TRIGGER_RISING_FALLING: u32 = 3;
pub const EXTI_GPIOA: u32 = 0;
pub const EXTI_GPIOB: u32 = 1;
pub const EXTI_GPIOF: u32 = 2;
pub const EXTI_PROPERTY_SHIFT: u32 = 24;
pub const EXTI_DIRECT: u32 = 16777216;
pub const EXTI_CONFIG: u32 = 33554432;
pub const EXTI_GPIO: u32 = 100663296;
pub const EXTI_RESERVED: u32 = 134217728;
pub const EXTI_PROPERTY_MASK: u32 = 117440512;
pub const EXTI_REG_SHIFT: u32 = 16;
pub const EXTI_REG1: u32 = 0;
pub const EXTI_REG2: u32 = 65536;
pub const EXTI_REG_MASK: u32 = 65536;
pub const EXTI_PIN_MASK: u32 = 31;
pub const EXTI_MODE_MASK: u32 = 3;
pub const EXTI_TRIGGER_MASK: u32 = 3;
pub const EXTI_LINE_NB: u32 = 32;
pub const GPIO_PIN_MASK: u32 = 65535;
pub const GPIO_MODE_INPUT: u32 = 0;
pub const GPIO_MODE_OUTPUT_PP: u32 = 1;
pub const GPIO_MODE_OUTPUT_OD: u32 = 17;
pub const GPIO_MODE_AF_PP: u32 = 2;
pub const GPIO_MODE_AF_OD: u32 = 18;
pub const GPIO_MODE_ANALOG: u32 = 3;
pub const GPIO_MODE_IT_RISING: u32 = 269549568;
pub const GPIO_MODE_IT_FALLING: u32 = 270598144;
pub const GPIO_MODE_IT_RISING_FALLING: u32 = 271646720;
pub const GPIO_MODE_EVT_RISING: u32 = 269615104;
pub const GPIO_MODE_EVT_FALLING: u32 = 270663680;
pub const GPIO_MODE_EVT_RISING_FALLING: u32 = 271712256;
pub const GPIO_SPEED_FREQ_LOW: u32 = 0;
pub const GPIO_SPEED_FREQ_MEDIUM: u32 = 1;
pub const GPIO_SPEED_FREQ_HIGH: u32 = 2;
pub const GPIO_SPEED_FREQ_VERY_HIGH: u32 = 3;
pub const GPIO_NOPULL: u32 = 0;
pub const GPIO_PULLUP: u32 = 1;
pub const GPIO_PULLDOWN: u32 = 2;
pub const SYSTICK_CLKSOURCE_HCLK_DIV8: u32 = 0;
pub const SYSTICK_CLKSOURCE_HCLK: u32 = 4;
pub const HAL_DMA_ERROR_NONE: u32 = 0;
pub const HAL_DMA_ERROR_TE: u32 = 1;
pub const HAL_DMA_ERROR_NO_XFER: u32 = 4;
pub const HAL_DMA_ERROR_TIMEOUT: u32 = 32;
pub const HAL_DMA_ERROR_NOT_SUPPORTED: u32 = 256;
pub const DMA_PERIPH_TO_MEMORY: u32 = 0;
pub const DMA_PINC_DISABLE: u32 = 0;
pub const DMA_MINC_DISABLE: u32 = 0;
pub const DMA_PDATAALIGN_BYTE: u32 = 0;
pub const DMA_MDATAALIGN_BYTE: u32 = 0;
pub const DMA_NORMAL: u32 = 0;
pub const DMA_PRIORITY_LOW: u32 = 0;
pub const DMA_FLAG_GL1: u32 = 1;
pub const DMA_FLAG_TC1: u32 = 2;
pub const DMA_FLAG_HT1: u32 = 4;
pub const DMA_FLAG_TE1: u32 = 8;
pub const DMA_FLAG_GL2: u32 = 16;
pub const DMA_FLAG_TC2: u32 = 32;
pub const DMA_FLAG_HT2: u32 = 64;
pub const DMA_FLAG_TE2: u32 = 128;
pub const DMA_FLAG_GL3: u32 = 256;
pub const DMA_FLAG_TC3: u32 = 512;
pub const DMA_FLAG_HT3: u32 = 1024;
pub const DMA_FLAG_TE3: u32 = 2048;
pub const DMA_CHANNEL_MAP_ADC: u32 = 0;
pub const DMA_CHANNEL_MAP_SPI1_TX: u32 = 1;
pub const DMA_CHANNEL_MAP_SPI1_RX: u32 = 2;
pub const DMA_CHANNEL_MAP_SPI2_TX: u32 = 3;
pub const DMA_CHANNEL_MAP_SPI2_RX: u32 = 4;
pub const DMA_CHANNEL_MAP_USART1_TX: u32 = 5;
pub const DMA_CHANNEL_MAP_USART1_RX: u32 = 6;
pub const DMA_CHANNEL_MAP_USART2_TX: u32 = 7;
pub const DMA_CHANNEL_MAP_USART2_RX: u32 = 8;
pub const DMA_CHANNEL_MAP_I2C_TX: u32 = 9;
pub const DMA_CHANNEL_MAP_I2C_RX: u32 = 10;
pub const DMA_CHANNEL_MAP_TIM1_CH1: u32 = 11;
pub const DMA_CHANNEL_MAP_TIM1_CH2: u32 = 12;
pub const DMA_CHANNEL_MAP_TIM1_CH3: u32 = 13;
pub const DMA_CHANNEL_MAP_TIM1_CH4: u32 = 14;
pub const DMA_CHANNEL_MAP_TIM1_COM: u32 = 15;
pub const DMA_CHANNEL_MAP_TIM1_UP: u32 = 16;
pub const DMA_CHANNEL_MAP_TIM1_TRIG: u32 = 17;
pub const DMA_CHANNEL_MAP_TIM3_CH1: u32 = 18;
pub const DMA_CHANNEL_MAP_TIM3_CH3: u32 = 19;
pub const DMA_CHANNEL_MAP_TIM3_CH4: u32 = 20;
pub const DMA_CHANNEL_MAP_TIM3_TRIG: u32 = 21;
pub const DMA_CHANNEL_MAP_TIM3_UP: u32 = 22;
pub const DMA_CHANNEL_MAP_TIM16_CH1: u32 = 24;
pub const DMA_CHANNEL_MAP_TIM16_UP: u32 = 25;
pub const DMA_CHANNEL_MAP_TIM17_CH1: u32 = 26;
pub const DMA_CHANNEL_MAP_TIM17_UP: u32 = 27;
pub const DMA_CHANNEL_MAP_END: u32 = 28;
pub const HAL_ADC_STATE_RESET: u32 = 0;
pub const HAL_ADC_STATE_READY: u32 = 1;
pub const HAL_ADC_STATE_BUSY_INTERNAL: u32 = 2;
pub const HAL_ADC_STATE_TIMEOUT: u32 = 4;
pub const HAL_ADC_STATE_ERROR_INTERNAL: u32 = 16;
pub const HAL_ADC_STATE_ERROR_CONFIG: u32 = 32;
pub const HAL_ADC_STATE_ERROR_DMA: u32 = 64;
pub const HAL_ADC_STATE_REG_BUSY: u32 = 256;
pub const HAL_ADC_STATE_REG_EOC: u32 = 512;
pub const HAL_ADC_STATE_REG_OVR: u32 = 1024;
pub const HAL_ADC_STATE_REG_EOSMP: u32 = 2048;
pub const HAL_ADC_STATE_INJ_BUSY: u32 = 4096;
pub const HAL_ADC_STATE_INJ_EOC: u32 = 8192;
pub const HAL_ADC_STATE_INJ_JQOVF: u32 = 16384;
pub const HAL_ADC_STATE_AWD1: u32 = 65536;
pub const HAL_ADC_STATE_AWD2: u32 = 131072;
pub const HAL_ADC_STATE_AWD3: u32 = 262144;
pub const HAL_ADC_STATE_MULTIMODE_SLAVE: u32 = 1048576;
pub const HAL_ADC_ERROR_NONE: u32 = 0;
pub const HAL_ADC_ERROR_INTERNAL: u32 = 1;
pub const HAL_ADC_ERROR_OVR: u32 = 2;
pub const HAL_ADC_ERROR_DMA: u32 = 4;
pub const ADC_CLOCK_SYNC_PCLK_DIV1: u32 = 0;
pub const ADC_RESOLUTION_12B: u32 = 0;
pub const ADC_DATAALIGN_RIGHT: u32 = 0;
pub const ADC_SCAN_DIRECTION_FORWARD: u32 = 1;
pub const ADC_SCAN_DIRECTION_BACKWARD: u32 = 2;
pub const ADC_SCAN_ENABLE: u32 = 1;
pub const ADC_EXTERNALTRIGCONVEDGE_NONE: u32 = 0;
pub const ADC_OVR_DATA_OVERWRITTEN: u32 = 0;
pub const ADC_OVR_DATA_PRESERVED: u32 = 1;
pub const ADC_RANK_CHANNEL_NUMBER: u32 = 4096;
pub const ADC_RANK_NONE: u32 = 4097;
pub const ADC_SAMPLETIME_3CYCLES_5: u32 = 0;
pub const ADC_ANALOGWATCHDOG_NONE: u32 = 0;
pub const ADC_IT_AWD: u32 = 128;
pub const ADC_IT_OVR: u32 = 16;
pub const ADC_IT_EOS: u32 = 8;
pub const ADC_IT_EOC: u32 = 4;
pub const ADC_IT_EOSMP: u32 = 2;
pub const ADC_FLAG_AWD: u32 = 128;
pub const ADC_FLAG_OVR: u32 = 16;
pub const ADC_FLAG_EOS: u32 = 8;
pub const ADC_FLAG_EOC: u32 = 4;
pub const ADC_FLAG_EOSMP: u32 = 2;
pub const ADC_CALIBSAMPLETIME_2CYCLES: u32 = 0;
pub const ADC_CALIBSELECTION_ONLYOFFSET: u32 = 0;
pub const ADC_CALIBSTATUS_SUCCESS: u32 = 0;
pub const ADC1_2_EXTERNALTRIG_T1_TRGO: u32 = 0;
pub const ADC_FLAG_POSTCONV_ALL: u32 = 156;
pub const ADC_CCR_ALL: u32 = 12582912;
pub const ADC_CHANNEL_0: u32 = 0;
pub const ADC_CHANNEL_1: u32 = 1;
pub const ADC_CHANNEL_2: u32 = 2;
pub const ADC_CHANNEL_3: u32 = 3;
pub const ADC_CHANNEL_4: u32 = 4;
pub const ADC_CHANNEL_5: u32 = 5;
pub const ADC_CHANNEL_6: u32 = 6;
pub const ADC_CHANNEL_7: u32 = 7;
pub const ADC_CHANNEL_8: u32 = 8;
pub const ADC_CHANNEL_9: u32 = 9;
pub const ADC_CHANNEL_11: u32 = 11;
pub const ADC_CHANNEL_12: u32 = 12;
pub const ADC_CHANNEL_TEMPSENSOR: u32 = 11;
pub const ADC_CHANNEL_VREFINT: u32 = 12;
pub const ADC_EXTERNALTRIGCONV_T1_TRGO: u32 = 0;
pub const ADC_SOFTWARE_START: u32 = 449;
pub const FLASH_LATENCY_0: u32 = 0;
pub const FLASH_LATENCY_1: u32 = 1;
pub const FLASH_TYPEERASE_MASSERASE: u32 = 1;
pub const FLASH_TYPEERASE_PAGEERASE: u32 = 2;
pub const FLASH_TYPEERASE_SECTORERASE: u32 = 3;
pub const FLASH_FLAG_BSY: u32 = 65536;
pub const FLASH_FLAG_OPTVERR: u32 = 32768;
pub const FLASH_FLAG_WRPERR: u32 = 16;
pub const FLASH_FLAG_EOP: u32 = 1;
pub const FLASH_FLAG_ALL_ERRORS: u32 = 32784;
pub const FLASH_IT_EOP: u32 = 16777216;
pub const FLASH_IT_OPERR: u32 = 33554432;
pub const HAL_FLASH_ERROR_NONE: u32 = 0;
pub const HAL_FLASH_ERROR_WRP: u32 = 16;
pub const HAL_FLASH_ERROR_OPTV: u32 = 32768;
pub const FLASH_PROGRAM_ERASE_CLOCK_4MHZ: u32 = 0;
pub const FLASH_PROGRAM_ERASE_CLOCK_8MHZ: u32 = 1;
pub const FLASH_PROGRAM_ERASE_CLOCK_16MHZ: u32 = 2;
pub const FLASH_PROGRAM_ERASE_CLOCK_22p12MHZ: u32 = 3;
pub const FLASH_PROGRAM_ERASE_CLOCK_24MHZ: u32 = 4;
pub const OB_USER_BOR_EN: u32 = 256;
pub const OB_USER_BOR_LEV: u32 = 3584;
pub const OB_USER_IWDG_SW: u32 = 4096;
pub const OB_USER_WWDG_SW: u32 = 8192;
pub const OB_USER_NRST_MODE: u32 = 16384;
pub const OB_USER_nBOOT1: u32 = 32768;
pub const OB_USER_ALL: u32 = 65280;
pub const FLASH_TYPEPROGRAM_PAGE: u32 = 1;
pub const OB_BOR_DISABLE: u32 = 0;
pub const OB_BOR_ENABLE: u32 = 256;
pub const OB_IWDG_SW: u32 = 4096;
pub const OB_IWDG_HW: u32 = 0;
pub const OB_WWDG_SW: u32 = 8192;
pub const OB_WWDG_HW: u32 = 0;
pub const OB_RESET_MODE_RESET: u32 = 0;
pub const OB_RESET_MODE_GPIO: u32 = 16384;
pub const OB_BOOT1_SRAM: u32 = 0;
pub const OB_BOOT1_SYSTEM: u32 = 32768;
pub const FLASH_TIMEOUT_VALUE: u32 = 1000;
pub const FLASH_TYPENONE: u32 = 0;
pub const FLASH_FLAG_SR_ERROR: u32 = 32784;
pub const FLASH_FLAG_SR_CLEAR: u32 = 32785;
pub const HAL_I2C_ERROR_NONE: u32 = 0;
pub const HAL_I2C_ERROR_BERR: u32 = 1;
pub const HAL_I2C_ERROR_ARLO: u32 = 2;
pub const HAL_I2C_ERROR_AF: u32 = 4;
pub const HAL_I2C_ERROR_OVR: u32 = 8;
pub const HAL_I2C_ERROR_DMA: u32 = 16;
pub const HAL_I2C_ERROR_DMA_PARAM: u32 = 128;
pub const HAL_I2C_ERROR_TIMEOUT: u32 = 32;
pub const HAL_I2C_ERROR_SIZE: u32 = 64;
pub const I2C_DUTYCYCLE_2: u32 = 0;
pub const I2C_DUTYCYCLE_16_9: u32 = 16384;
pub const I2C_GENERALCALL_DISABLE: u32 = 0;
pub const I2C_GENERALCALL_ENABLE: u32 = 64;
pub const I2C_NOSTRETCH_DISABLE: u32 = 0;
pub const I2C_NOSTRETCH_ENABLE: u32 = 128;
pub const I2C_MEMADD_SIZE_8BIT: u32 = 1;
pub const I2C_MEMADD_SIZE_16BIT: u32 = 16;
pub const I2C_DIRECTION_RECEIVE: u32 = 0;
pub const I2C_DIRECTION_TRANSMIT: u32 = 1;
pub const I2C_FIRST_FRAME: u32 = 1;
pub const I2C_FIRST_AND_NEXT_FRAME: u32 = 2;
pub const I2C_NEXT_FRAME: u32 = 4;
pub const I2C_FIRST_AND_LAST_FRAME: u32 = 8;
pub const I2C_LAST_FRAME_NO_STOP: u32 = 16;
pub const I2C_LAST_FRAME: u32 = 32;
pub const I2C_OTHER_FRAME: u32 = 11141120;
pub const I2C_OTHER_AND_LAST_FRAME: u32 = 2852126720;
pub const I2C_IT_BUF: u32 = 1024;
pub const I2C_IT_EVT: u32 = 512;
pub const I2C_IT_ERR: u32 = 256;
pub const I2C_FLAG_OVR: u32 = 67584;
pub const I2C_FLAG_AF: u32 = 66560;
pub const I2C_FLAG_ARLO: u32 = 66048;
pub const I2C_FLAG_BERR: u32 = 65792;
pub const I2C_FLAG_TXE: u32 = 65664;
pub const I2C_FLAG_RXNE: u32 = 65600;
pub const I2C_FLAG_STOPF: u32 = 65552;
pub const I2C_FLAG_ADD10: u32 = 65544;
pub const I2C_FLAG_BTF: u32 = 65540;
pub const I2C_FLAG_ADDR: u32 = 65538;
pub const I2C_FLAG_SB: u32 = 65537;
pub const I2C_FLAG_DUALF: u32 = 1048704;
pub const I2C_FLAG_GENCALL: u32 = 1048592;
pub const I2C_FLAG_TRA: u32 = 1048580;
pub const I2C_FLAG_BUSY: u32 = 1048578;
pub const I2C_FLAG_MSL: u32 = 1048577;
pub const I2C_FLAG_MASK: u32 = 65535;
pub const I2C_MIN_PCLK_FREQ_STANDARD: u32 = 2000000;
pub const I2C_MIN_PCLK_FREQ_FAST: u32 = 4000000;
pub const IWDG_PRESCALER_4: u32 = 0;
pub const IWDG_PRESCALER_8: u32 = 1;
pub const IWDG_PRESCALER_16: u32 = 2;
pub const IWDG_PRESCALER_32: u32 = 3;
pub const IWDG_PRESCALER_64: u32 = 4;
pub const IWDG_PRESCALER_128: u32 = 5;
pub const IWDG_PRESCALER_256: u32 = 6;
pub const IWDG_KEY_RELOAD: u32 = 43690;
pub const IWDG_KEY_ENABLE: u32 = 52428;
pub const IWDG_KEY_WRITE_ACCESS_ENABLE: u32 = 21845;
pub const IWDG_KEY_WRITE_ACCESS_DISABLE: u32 = 0;
pub const PWR_PVD_SOURCE_VCC: u32 = 0;
pub const PWR_PVD_SOURCE_PB07: u32 = 4;
pub const PWR_PVD_FILTER_NONE: u32 = 0;
pub const PWR_PVD_FILTER_1CLOCK: u32 = 256;
pub const PWR_PVD_FILTER_2CLOCK: u32 = 768;
pub const PWR_PVD_FILTER_4CLOCK: u32 = 1280;
pub const PWR_PVD_FILTER_16CLOCK: u32 = 1792;
pub const PWR_PVD_FILTER_64CLOCK: u32 = 2304;
pub const PWR_PVD_FILTER_128CLOCK: u32 = 2816;
pub const PWR_PVD_FILTER_1024CLOCK: u32 = 3328;
pub const PWR_PVDLEVEL_0: u32 = 0;
pub const PWR_PVDLEVEL_1: u32 = 16;
pub const PWR_PVDLEVEL_2: u32 = 32;
pub const PWR_PVDLEVEL_3: u32 = 48;
pub const PWR_PVDLEVEL_4: u32 = 64;
pub const PWR_PVDLEVEL_5: u32 = 80;
pub const PWR_PVDLEVEL_6: u32 = 96;
pub const PWR_PVDLEVEL_7: u32 = 112;
pub const PWR_PVD_MODE_NORMAL: u32 = 0;
pub const PWR_PVD_MODE_IT_RISING: u32 = 65537;
pub const PWR_PVD_MODE_IT_FALLING: u32 = 65538;
pub const PWR_PVD_MODE_IT_RISING_FALLING: u32 = 65539;
pub const PWR_PVD_MODE_EVENT_RISING: u32 = 131073;
pub const PWR_PVD_MODE_EVENT_FALLING: u32 = 131074;
pub const PWR_PVD_MODE_EVENT_RISING_FALLING: u32 = 131075;
pub const PWR_EXTI_LINE_PVD: u32 = 65536;
pub const PWR_EVENT_LINE_PVD: u32 = 65536;
pub const PWR_MAINREGULATOR_ON: u32 = 0;
pub const PWR_LOWPOWERREGULATOR_ON: u32 = 16384;
pub const PWR_FLAG_PVDO: u32 = 2048;
pub const PWR_STOPMOD_LPR_VOLT_SCALE1: u32 = 0;
pub const PWR_STOPMOD_LPR_VOLT_SCALE2: u32 = 512;
pub const PWR_WAKEUP_LPR_TO_MR_DELAY_2US: u32 = 0;
pub const PWR_WAKEUP_LPR_TO_MR_DELAY_3US: u32 = 1024;
pub const PWR_WAKEUP_LPR_TO_MR_DELAY_4US: u32 = 2048;
pub const PWR_WAKEUP_LPR_TO_MR_DELAY_5US: u32 = 3072;
pub const PWR_WAKEUP_HSIEN_AFTER_MR: u32 = 0;
pub const PWR_WAKEUP_HSIEN_IMMEDIATE: u32 = 524288;
pub const PWR_SRAM_RETENTION_VOLT_0p9: u32 = 196608;
pub const PWR_SRAM_RETENTION_VOLT_VOS: u32 = 262144;
pub const PWR_WAKEUP_FLASH_DELAY_0US: u32 = 12288;
pub const PWR_WAKEUP_FLASH_DELAY_2US: u32 = 4096;
pub const PWR_WAKEUP_FLASH_DELAY_3US: u32 = 8192;
pub const PWR_WAKEUP_FLASH_DELAY_5US: u32 = 0;
pub const PWR_BIAS_CURRENTS_FROM_FACTORY_BYTES: u32 = 0;
pub const PWR_BIAS_CURRENTS_FROM_BIAS_CR: u32 = 16;
pub const PWR_WUP_POLARITY_SHIFT: u32 = 8;
pub const RTC_TIMEOUT_VALUE: u32 = 2000;
pub const RTC_RTOFF_RESET_TIMEOUT_VALUE: u32 = 4;
pub const RTC_AUTO_1_SECOND: u32 = 4294967295;
pub const RTC_FORMAT_BIN: u32 = 0;
pub const RTC_FORMAT_BCD: u32 = 1;
pub const RTC_ALARM_A: u32 = 0;
pub const RTC_OUTPUTSOURCE_NONE: u32 = 0;
pub const RTC_OUTPUTSOURCE_CALIBCLOCK: u32 = 128;
pub const RTC_OUTPUTSOURCE_ALARM: u32 = 256;
pub const RTC_OUTPUTSOURCE_SECOND: u32 = 768;
pub const RTC_IT_OW: u32 = 4;
pub const RTC_IT_ALRA: u32 = 2;
pub const RTC_IT_SEC: u32 = 1;
pub const RTC_FLAG_RTOFF: u32 = 32;
pub const RTC_FLAG_RSF: u32 = 8;
pub const RTC_FLAG_OW: u32 = 4;
pub const RTC_FLAG_ALRAF: u32 = 2;
pub const RTC_FLAG_SEC: u32 = 1;
pub const HAL_SPI_ERROR_NONE: u32 = 0;
pub const HAL_SPI_ERROR_MODF: u32 = 1;
pub const HAL_SPI_ERROR_OVR: u32 = 4;
pub const HAL_SPI_ERROR_FRE: u32 = 8;
pub const HAL_SPI_ERROR_DMA: u32 = 16;
pub const HAL_SPI_ERROR_FLAG: u32 = 32;
pub const HAL_SPI_ERROR_ABORT: u32 = 64;
pub const SPI_MODE_SLAVE: u32 = 0;
pub const SPI_MODE_MASTER: u32 = 260;
pub const SPI_DIRECTION_2LINES: u32 = 0;
pub const SPI_DIRECTION_2LINES_RXONLY: u32 = 1024;
pub const SPI_DIRECTION_1LINE: u32 = 32768;
pub const SPI_DATASIZE_8BIT: u32 = 1792;
pub const SPI_DATASIZE_16BIT: u32 = 3840;
pub const SPI_POLARITY_LOW: u32 = 0;
pub const SPI_POLARITY_HIGH: u32 = 2;
pub const SPI_PHASE_1EDGE: u32 = 0;
pub const SPI_PHASE_2EDGE: u32 = 1;
pub const SPI_NSS_SOFT: u32 = 512;
pub const SPI_NSS_HARD_INPUT: u32 = 0;
pub const SPI_NSS_HARD_OUTPUT: u32 = 262144;
pub const SPI_BAUDRATEPRESCALER_2: u32 = 0;
pub const SPI_BAUDRATEPRESCALER_4: u32 = 8;
pub const SPI_BAUDRATEPRESCALER_8: u32 = 16;
pub const SPI_BAUDRATEPRESCALER_16: u32 = 24;
pub const SPI_BAUDRATEPRESCALER_32: u32 = 32;
pub const SPI_BAUDRATEPRESCALER_64: u32 = 40;
pub const SPI_BAUDRATEPRESCALER_128: u32 = 48;
pub const SPI_BAUDRATEPRESCALER_256: u32 = 56;
pub const SPI_FIRSTBIT_MSB: u32 = 0;
pub const SPI_FIRSTBIT_LSB: u32 = 128;
pub const SPI_SLAVE_FAST_MODE_DISABLE: u32 = 0;
pub const SPI_SLAVE_FAST_MODE_ENABLE: u32 = 32768;
pub const SPI_RXFIFO_THRESHOLD: u32 = 4096;
pub const SPI_RXFIFO_THRESHOLD_QF: u32 = 4096;
pub const SPI_RXFIFO_THRESHOLD_HF: u32 = 0;
pub const SPI_IT_TXE: u32 = 128;
pub const SPI_IT_RXNE: u32 = 64;
pub const SPI_IT_ERR: u32 = 32;
pub const SPI_FLAG_RXNE: u32 = 1;
pub const SPI_FLAG_TXE: u32 = 2;
pub const SPI_FLAG_BSY: u32 = 128;
pub const SPI_FLAG_MODF: u32 = 32;
pub const SPI_FLAG_OVR: u32 = 64;
pub const SPI_FLAG_FTLVL: u32 = 6144;
pub const SPI_FLAG_FRLVL: u32 = 1536;
pub const SPI_FLAG_MASK: u32 = 7907;
pub const SPI_FTLVL_EMPTY: u32 = 0;
pub const SPI_FTLVL_QUARTER_FULL: u32 = 2048;
pub const SPI_FTLVL_HALF_FULL: u32 = 4096;
pub const SPI_FTLVL_FULL: u32 = 6144;
pub const SPI_FRLVL_EMPTY: u32 = 0;
pub const SPI_FRLVL_QUARTER_FULL: u32 = 512;
pub const SPI_FRLVL_HALF_FULL: u32 = 1024;
pub const SPI_FRLVL_FULL: u32 = 1536;
pub const TIM_CLEARINPUTSOURCE_NONE: u32 = 0;
pub const TIM_CLEARINPUTSOURCE_ETR: u32 = 1;
pub const TIM_CLEARINPUTSOURCE_OCREFCLR: u32 = 2;
pub const TIM_DMABASE_CR1: u32 = 0;
pub const TIM_DMABASE_CR2: u32 = 1;
pub const TIM_DMABASE_SMCR: u32 = 2;
pub const TIM_DMABASE_DIER: u32 = 3;
pub const TIM_DMABASE_SR: u32 = 4;
pub const TIM_DMABASE_EGR: u32 = 5;
pub const TIM_DMABASE_CCMR1: u32 = 6;
pub const TIM_DMABASE_CCMR2: u32 = 7;
pub const TIM_DMABASE_CCER: u32 = 8;
pub const TIM_DMABASE_CNT: u32 = 9;
pub const TIM_DMABASE_PSC: u32 = 10;
pub const TIM_DMABASE_ARR: u32 = 11;
pub const TIM_DMABASE_RCR: u32 = 12;
pub const TIM_DMABASE_CCR1: u32 = 13;
pub const TIM_DMABASE_CCR2: u32 = 14;
pub const TIM_DMABASE_CCR3: u32 = 15;
pub const TIM_DMABASE_CCR4: u32 = 16;
pub const TIM_DMABASE_BDTR: u32 = 17;
pub const TIM_DMABASE_DCR: u32 = 18;
pub const TIM_DMABASE_DMAR: u32 = 19;
pub const TIM_EVENTSOURCE_UPDATE: u32 = 1;
pub const TIM_EVENTSOURCE_CC1: u32 = 2;
pub const TIM_EVENTSOURCE_CC2: u32 = 4;
pub const TIM_EVENTSOURCE_CC3: u32 = 8;
pub const TIM_EVENTSOURCE_CC4: u32 = 16;
pub const TIM_EVENTSOURCE_COM: u32 = 32;
pub const TIM_EVENTSOURCE_TRIGGER: u32 = 64;
pub const TIM_EVENTSOURCE_BREAK: u32 = 128;
pub const TIM_INPUTCHANNELPOLARITY_RISING: u32 = 0;
pub const TIM_INPUTCHANNELPOLARITY_FALLING: u32 = 2;
pub const TIM_INPUTCHANNELPOLARITY_BOTHEDGE: u32 = 10;
pub const TIM_ETRPOLARITY_INVERTED: u32 = 32768;
pub const TIM_ETRPOLARITY_NONINVERTED: u32 = 0;
pub const TIM_ETRPRESCALER_DIV1: u32 = 0;
pub const TIM_ETRPRESCALER_DIV2: u32 = 4096;
pub const TIM_ETRPRESCALER_DIV4: u32 = 8192;
pub const TIM_ETRPRESCALER_DIV8: u32 = 12288;
pub const TIM_COUNTERMODE_UP: u32 = 0;
pub const TIM_COUNTERMODE_DOWN: u32 = 16;
pub const TIM_COUNTERMODE_CENTERALIGNED1: u32 = 32;
pub const TIM_COUNTERMODE_CENTERALIGNED2: u32 = 64;
pub const TIM_COUNTERMODE_CENTERALIGNED3: u32 = 96;
pub const TIM_CLOCKDIVISION_DIV1: u32 = 0;
pub const TIM_CLOCKDIVISION_DIV2: u32 = 256;
pub const TIM_CLOCKDIVISION_DIV4: u32 = 512;
pub const TIM_OUTPUTSTATE_DISABLE: u32 = 0;
pub const TIM_OUTPUTSTATE_ENABLE: u32 = 1;
pub const TIM_AUTORELOAD_PRELOAD_DISABLE: u32 = 0;
pub const TIM_AUTORELOAD_PRELOAD_ENABLE: u32 = 128;
pub const TIM_OCFAST_DISABLE: u32 = 0;
pub const TIM_OCFAST_ENABLE: u32 = 4;
pub const TIM_OUTPUTNSTATE_DISABLE: u32 = 0;
pub const TIM_OUTPUTNSTATE_ENABLE: u32 = 4;
pub const TIM_OCPOLARITY_HIGH: u32 = 0;
pub const TIM_OCPOLARITY_LOW: u32 = 2;
pub const TIM_OCNPOLARITY_HIGH: u32 = 0;
pub const TIM_OCNPOLARITY_LOW: u32 = 8;
pub const TIM_OCIDLESTATE_SET: u32 = 256;
pub const TIM_OCIDLESTATE_RESET: u32 = 0;
pub const TIM_OCNIDLESTATE_SET: u32 = 512;
pub const TIM_OCNIDLESTATE_RESET: u32 = 0;
pub const TIM_ICPOLARITY_RISING: u32 = 0;
pub const TIM_ICPOLARITY_FALLING: u32 = 2;
pub const TIM_ICPOLARITY_BOTHEDGE: u32 = 10;
pub const TIM_ENCODERINPUTPOLARITY_RISING: u32 = 0;
pub const TIM_ENCODERINPUTPOLARITY_FALLING: u32 = 2;
pub const TIM_ENCODERINPUTPOLARITY_BOTHEDGE: u32 = 10;
pub const TIM_ICSELECTION_DIRECTTI: u32 = 1;
pub const TIM_ICSELECTION_INDIRECTTI: u32 = 2;
pub const TIM_ICSELECTION_TRC: u32 = 3;
pub const TIM_ICPSC_DIV1: u32 = 0;
pub const TIM_ICPSC_DIV2: u32 = 4;
pub const TIM_ICPSC_DIV4: u32 = 8;
pub const TIM_ICPSC_DIV8: u32 = 12;
pub const TIM_OPMODE_SINGLE: u32 = 8;
pub const TIM_OPMODE_REPETITIVE: u32 = 0;
pub const TIM_ENCODERMODE_TI1: u32 = 1;
pub const TIM_ENCODERMODE_TI2: u32 = 2;
pub const TIM_ENCODERMODE_TI12: u32 = 3;
pub const TIM_IT_UPDATE: u32 = 1;
pub const TIM_IT_CC1: u32 = 2;
pub const TIM_IT_CC2: u32 = 4;
pub const TIM_IT_CC3: u32 = 8;
pub const TIM_IT_CC4: u32 = 16;
pub const TIM_IT_COM: u32 = 32;
pub const TIM_IT_TRIGGER: u32 = 64;
pub const TIM_IT_BREAK: u32 = 128;
pub const TIM_COMMUTATION_TRGI: u32 = 4;
pub const TIM_COMMUTATION_SOFTWARE: u32 = 0;
pub const TIM_DMA_UPDATE: u32 = 256;
pub const TIM_DMA_CC1: u32 = 512;
pub const TIM_DMA_CC2: u32 = 1024;
pub const TIM_DMA_CC3: u32 = 2048;
pub const TIM_DMA_CC4: u32 = 4096;
pub const TIM_DMA_COM: u32 = 8192;
pub const TIM_DMA_TRIGGER: u32 = 16384;
pub const TIM_FLAG_UPDATE: u32 = 1;
pub const TIM_FLAG_CC1: u32 = 2;
pub const TIM_FLAG_CC2: u32 = 4;
pub const TIM_FLAG_CC3: u32 = 8;
pub const TIM_FLAG_CC4: u32 = 16;
pub const TIM_FLAG_COM: u32 = 32;
pub const TIM_FLAG_TRIGGER: u32 = 64;
pub const TIM_FLAG_BREAK: u32 = 128;
pub const TIM_FLAG_CC1OF: u32 = 512;
pub const TIM_FLAG_CC2OF: u32 = 1024;
pub const TIM_FLAG_CC3OF: u32 = 2048;
pub const TIM_FLAG_CC4OF: u32 = 4096;
pub const TIM_CHANNEL_1: u32 = 0;
pub const TIM_CHANNEL_2: u32 = 4;
pub const TIM_CHANNEL_3: u32 = 8;
pub const TIM_CHANNEL_4: u32 = 12;
pub const TIM_CHANNEL_ALL: u32 = 60;
pub const TIM_CLOCKSOURCE_ETRMODE2: u32 = 8192;
pub const TIM_CLOCKSOURCE_INTERNAL: u32 = 4096;
pub const TIM_CLOCKPOLARITY_INVERTED: u32 = 32768;
pub const TIM_CLOCKPOLARITY_NONINVERTED: u32 = 0;
pub const TIM_CLOCKPOLARITY_RISING: u32 = 0;
pub const TIM_CLOCKPOLARITY_FALLING: u32 = 2;
pub const TIM_CLOCKPOLARITY_BOTHEDGE: u32 = 10;
pub const TIM_CLOCKPRESCALER_DIV1: u32 = 0;
pub const TIM_CLOCKPRESCALER_DIV2: u32 = 4096;
pub const TIM_CLOCKPRESCALER_DIV4: u32 = 8192;
pub const TIM_CLOCKPRESCALER_DIV8: u32 = 12288;
pub const TIM_CLEARINPUTPOLARITY_INVERTED: u32 = 32768;
pub const TIM_CLEARINPUTPOLARITY_NONINVERTED: u32 = 0;
pub const TIM_CLEARINPUTPRESCALER_DIV1: u32 = 0;
pub const TIM_CLEARINPUTPRESCALER_DIV2: u32 = 4096;
pub const TIM_CLEARINPUTPRESCALER_DIV4: u32 = 8192;
pub const TIM_CLEARINPUTPRESCALER_DIV8: u32 = 12288;
pub const TIM_OSSR_ENABLE: u32 = 2048;
pub const TIM_OSSR_DISABLE: u32 = 0;
pub const TIM_OSSI_ENABLE: u32 = 1024;
pub const TIM_OSSI_DISABLE: u32 = 0;
pub const TIM_LOCKLEVEL_OFF: u32 = 0;
pub const TIM_LOCKLEVEL_1: u32 = 256;
pub const TIM_LOCKLEVEL_2: u32 = 512;
pub const TIM_LOCKLEVEL_3: u32 = 768;
pub const TIM_BREAK_ENABLE: u32 = 4096;
pub const TIM_BREAK_DISABLE: u32 = 0;
pub const TIM_BREAKPOLARITY_LOW: u32 = 0;
pub const TIM_BREAKPOLARITY_HIGH: u32 = 8192;
pub const TIM_AUTOMATICOUTPUT_DISABLE: u32 = 0;
pub const TIM_AUTOMATICOUTPUT_ENABLE: u32 = 16384;
pub const TIM_TRGO_RESET: u32 = 0;
pub const TIM_TRGO_ENABLE: u32 = 16;
pub const TIM_TRGO_UPDATE: u32 = 32;
pub const TIM_TRGO_OC1: u32 = 48;
pub const TIM_TRGO_OC1REF: u32 = 64;
pub const TIM_TRGO_OC2REF: u32 = 80;
pub const TIM_TRGO_OC3REF: u32 = 96;
pub const TIM_TRGO_OC4REF: u32 = 112;
pub const TIM_MASTERSLAVEMODE_ENABLE: u32 = 128;
pub const TIM_MASTERSLAVEMODE_DISABLE: u32 = 0;
pub const TIM_SLAVEMODE_DISABLE: u32 = 0;
pub const TIM_SLAVEMODE_RESET: u32 = 4;
pub const TIM_SLAVEMODE_GATED: u32 = 5;
pub const TIM_SLAVEMODE_TRIGGER: u32 = 6;
pub const TIM_SLAVEMODE_EXTERNAL1: u32 = 7;
pub const TIM_OCMODE_TIMING: u32 = 0;
pub const TIM_OCMODE_ACTIVE: u32 = 16;
pub const TIM_OCMODE_INACTIVE: u32 = 32;
pub const TIM_OCMODE_TOGGLE: u32 = 48;
pub const TIM_OCMODE_PWM1: u32 = 96;
pub const TIM_OCMODE_PWM2: u32 = 112;
pub const TIM_OCMODE_FORCED_ACTIVE: u32 = 80;
pub const TIM_OCMODE_FORCED_INACTIVE: u32 = 64;
pub const TIM_TS_ITR0: u32 = 0;
pub const TIM_TS_ITR1: u32 = 16;
pub const TIM_TS_ITR2: u32 = 32;
pub const TIM_TS_ITR3: u32 = 48;
pub const TIM_TS_TI1F_ED: u32 = 64;
pub const TIM_TS_TI1FP1: u32 = 80;
pub const TIM_TS_TI2FP2: u32 = 96;
pub const TIM_TS_ETRF: u32 = 112;
pub const TIM_TS_NONE: u32 = 65535;
pub const TIM_TRIGGERPOLARITY_INVERTED: u32 = 32768;
pub const TIM_TRIGGERPOLARITY_NONINVERTED: u32 = 0;
pub const TIM_TRIGGERPOLARITY_RISING: u32 = 0;
pub const TIM_TRIGGERPOLARITY_FALLING: u32 = 2;
pub const TIM_TRIGGERPOLARITY_BOTHEDGE: u32 = 10;
pub const TIM_TRIGGERPRESCALER_DIV1: u32 = 0;
pub const TIM_TRIGGERPRESCALER_DIV2: u32 = 4096;
pub const TIM_TRIGGERPRESCALER_DIV4: u32 = 8192;
pub const TIM_TRIGGERPRESCALER_DIV8: u32 = 12288;
pub const TIM_TI1SELECTION_CH1: u32 = 0;
pub const TIM_TI1SELECTION_XORCOMBINATION: u32 = 128;
pub const TIM_DMABURSTLENGTH_1TRANSFER: u32 = 0;
pub const TIM_DMABURSTLENGTH_2TRANSFERS: u32 = 256;
pub const TIM_DMABURSTLENGTH_3TRANSFERS: u32 = 512;
pub const TIM_DMABURSTLENGTH_4TRANSFERS: u32 = 768;
pub const TIM_DMABURSTLENGTH_5TRANSFERS: u32 = 1024;
pub const TIM_DMABURSTLENGTH_6TRANSFERS: u32 = 1280;
pub const TIM_DMABURSTLENGTH_7TRANSFERS: u32 = 1536;
pub const TIM_DMABURSTLENGTH_8TRANSFERS: u32 = 1792;
pub const TIM_DMABURSTLENGTH_9TRANSFERS: u32 = 2048;
pub const TIM_DMABURSTLENGTH_10TRANSFERS: u32 = 2304;
pub const TIM_DMABURSTLENGTH_11TRANSFERS: u32 = 2560;
pub const TIM_DMABURSTLENGTH_12TRANSFERS: u32 = 2816;
pub const TIM_DMABURSTLENGTH_13TRANSFERS: u32 = 3072;
pub const TIM_DMABURSTLENGTH_14TRANSFERS: u32 = 3328;
pub const TIM_DMABURSTLENGTH_15TRANSFERS: u32 = 3584;
pub const TIM_DMABURSTLENGTH_16TRANSFERS: u32 = 3840;
pub const TIM_DMABURSTLENGTH_17TRANSFERS: u32 = 4096;
pub const TIM_DMABURSTLENGTH_18TRANSFERS: u32 = 4352;
pub const TIM_CCx_ENABLE: u32 = 1;
pub const TIM_CCx_DISABLE: u32 = 0;
pub const TIM_CCxN_ENABLE: u32 = 4;
pub const TIM_CCxN_DISABLE: u32 = 0;
pub const TIM_TIM14_GPIO: u32 = 0;
pub const TIM_TIM14_RTC: u32 = 1;
pub const TIM_TIM14_HSE: u32 = 2;
pub const TIM_TIM14_MCO: u32 = 3;
pub const LPTIM_PRESCALER_DIV1: u32 = 0;
pub const LPTIM_PRESCALER_DIV2: u32 = 512;
pub const LPTIM_PRESCALER_DIV4: u32 = 1024;
pub const LPTIM_PRESCALER_DIV8: u32 = 1536;
pub const LPTIM_PRESCALER_DIV16: u32 = 2048;
pub const LPTIM_PRESCALER_DIV32: u32 = 2560;
pub const LPTIM_PRESCALER_DIV64: u32 = 3072;
pub const LPTIM_PRESCALER_DIV128: u32 = 3584;
pub const LPTIM_UPDATE_IMMEDIATE: u32 = 0;
pub const LPTIM_UPDATE_ENDOFPERIOD: u32 = 4194304;
pub const LPTIM_FLAG_ARRM: u32 = 2;
pub const LPTIM_IT_ARRM: u32 = 2;
pub const HAL_UART_ERROR_NONE: u32 = 0;
pub const HAL_UART_ERROR_PE: u32 = 1;
pub const HAL_UART_ERROR_NE: u32 = 2;
pub const HAL_UART_ERROR_FE: u32 = 4;
pub const HAL_UART_ERROR_ORE: u32 = 8;
pub const HAL_UART_ERROR_DMA: u32 = 16;
pub const UART_WORDLENGTH_8B: u32 = 0;
pub const UART_STOPBITS_1: u32 = 0;
pub const UART_PARITY_NONE: u32 = 0;
pub const UART_HWCONTROL_NONE: u32 = 0;
pub const UART_STATE_DISABLE: u32 = 0;
pub const UART_OVERSAMPLING_16: u32 = 0;
pub const UART_LINBREAKDETECTLENGTH_10B: u32 = 0;
pub const UART_WAKEUPMETHOD_IDLELINE: u32 = 0;
pub const UART_ADVFEATURE_NO_INIT: u32 = 0;
pub const UART_ADVFEATURE_AUTOBAUDRATE_INIT: u32 = 64;
pub const UART_ADVFEATURE_AUTOBAUDRATE_DISABLE: u32 = 0;
pub const UART_ADVFEATURE_AUTOBAUDRATE_ENABLE: u32 = 4096;
pub const UART_ADVFEATURE_AUTOBAUDRATE_ONSTARTBIT: u32 = 0;
pub const UART_ADVFEATURE_AUTOBAUDRATE_ONFALLINGEDGE: u32 = 8192;
pub const UART_IT_MASK: u32 = 65535;
pub const UART_CR1_REG_INDEX: u32 = 1;
pub const UART_CR2_REG_INDEX: u32 = 2;
pub const UART_CR3_REG_INDEX: u32 = 3;
pub const WWDG_IT_EWI: u32 = 512;
pub const WWDG_FLAG_EWIF: u32 = 1;
pub const WWDG_PRESCALER_1: u32 = 0;
pub const WWDG_PRESCALER_2: u32 = 128;
pub const WWDG_PRESCALER_4: u32 = 256;
pub const WWDG_PRESCALER_8: u32 = 384;
pub const WWDG_EWI_DISABLE: u32 = 0;
pub const WWDG_EWI_ENABLE: u32 = 512;
pub const LED_DISP_NONE: u32 = 0;
pub const LED_DISP_FULL: u32 = 255;
pub const LED_DISP_0: u32 = 63;
pub const LED_DISP_1: u32 = 6;
pub const LED_DISP_2: u32 = 91;
pub const LED_DISP_3: u32 = 79;
pub const LED_DISP_4: u32 = 102;
pub const LED_DISP_5: u32 = 109;
pub const LED_DISP_6: u32 = 125;
pub const LED_DISP_7: u32 = 7;
pub const LED_DISP_8: u32 = 127;
pub const LED_DISP_9: u32 = 111;
pub const LED_DISP_A: u32 = 119;
pub const LED_DISP_B: u32 = 124;
pub const LED_DISP_C: u32 = 57;
pub const LED_DISP_D: u32 = 94;
pub const LED_DISP_E: u32 = 121;
pub const LED_DISP_F: u32 = 113;
pub const LED_DISP_H: u32 = 118;
pub const LED_DISP_P: u32 = 115;
pub const LED_DISP_U: u32 = 62;
pub const LED_DISP_DOT: u32 = 128;
pub const LED_COM0: u32 = 1;
pub const LED_COM1: u32 = 2;
pub const LED_COM2: u32 = 4;
pub const LED_COM3: u32 = 8;
pub const LED_COM_ALL: u32 = 15;
pub const LED_COMDRIVE_LOW: u32 = 0;
pub const LED_COMDRIVE_HIGH: u32 = 4096;
pub const SYSCFG_BOOT_MAINFLASH: u32 = 0;
pub const SYSCFG_BOOT_SYSTEMFLASH: u32 = 1;
pub const SYSCFG_BOOT_SRAM: u32 = 3;
#[doc = "< 2 Non Maskable Interrupt"]
pub const IRQn_Type_NonMaskableInt_IRQn: IRQn_Type = -14;
#[doc = "< 3 Cortex-M Hard Fault Interrupt"]
pub const IRQn_Type_HardFault_IRQn: IRQn_Type = -13;
#[doc = "< 11 Cortex-M SV Call Interrupt"]
pub const IRQn_Type_SVC_IRQn: IRQn_Type = -5;
#[doc = "< 14 Cortex-M Pend SV Interrupt"]
pub const IRQn_Type_PendSV_IRQn: IRQn_Type = -2;
#[doc = "< 15 Cortex-M System Tick Interrupt"]
pub const IRQn_Type_SysTick_IRQn: IRQn_Type = -1;
#[doc = "< Window WatchDog Interrupt"]
pub const IRQn_Type_WWDG_IRQn: IRQn_Type = 0;
#[doc = "< PVD through EXTI Line detection Interrupt(EXTI line 16)"]
pub const IRQn_Type_PVD_IRQn: IRQn_Type = 1;
#[doc = "< RTC interrupt through the EXTI line 19"]
pub const IRQn_Type_RTC_IRQn: IRQn_Type = 2;
#[doc = "< FLASH global Interrupt"]
pub const IRQn_Type_FLASH_IRQn: IRQn_Type = 3;
#[doc = "< RCC global Interrupt"]
pub const IRQn_Type_RCC_IRQn: IRQn_Type = 4;
#[doc = "< EXTI 0 and 1 Interrupts"]
pub const IRQn_Type_EXTI0_1_IRQn: IRQn_Type = 5;
#[doc = "< EXTI Line 2 and 3 Interrupts"]
pub const IRQn_Type_EXTI2_3_IRQn: IRQn_Type = 6;
#[doc = "< EXTI Line 4 to 15 Interrupts"]
pub const IRQn_Type_EXTI4_15_IRQn: IRQn_Type = 7;
#[doc = "< DMA1 Channel 1 Interrupt"]
pub const IRQn_Type_DMA1_Channel1_IRQn: IRQn_Type = 9;
#[doc = "< DMA1 Channel 2 and Channel 3 Interrupts"]
pub const IRQn_Type_DMA1_Channel2_3_IRQn: IRQn_Type = 10;
#[doc = "< ADC&COMP Interrupts"]
pub const IRQn_Type_ADC_COMP_IRQn: IRQn_Type = 12;
#[doc = "< TIM1 Break, Update, Trigger and Commutation Interrupts"]
pub const IRQn_Type_TIM1_BRK_UP_TRG_COM_IRQn: IRQn_Type = 13;
#[doc = "< TIM1 Capture Compare Interrupt"]
pub const IRQn_Type_TIM1_CC_IRQn: IRQn_Type = 14;
#[doc = "< TIM3 global Interrupt"]
pub const IRQn_Type_TIM3_IRQn: IRQn_Type = 16;
#[doc = "< LPTIM1 global Interrupts"]
pub const IRQn_Type_LPTIM1_IRQn: IRQn_Type = 17;
#[doc = "< TIM14 global Interrupt"]
pub const IRQn_Type_TIM14_IRQn: IRQn_Type = 19;
#[doc = "< TIM16 global Interrupt"]
pub const IRQn_Type_TIM16_IRQn: IRQn_Type = 21;
#[doc = "< TIM17 global Interrupt"]
pub const IRQn_Type_TIM17_IRQn: IRQn_Type = 22;
#[doc = "< I2C1 Interrupt  (combined with EXTI 23)"]
pub const IRQn_Type_I2C1_IRQn: IRQn_Type = 23;
#[doc = "< SPI1 Interrupt"]
pub const IRQn_Type_SPI1_IRQn: IRQn_Type = 25;
#[doc = "< SPI2 Interrupt"]
pub const IRQn_Type_SPI2_IRQn: IRQn_Type = 26;
#[doc = "< USART1 Interrupt"]
pub const IRQn_Type_USART1_IRQn: IRQn_Type = 27;
#[doc = "< USART2 Interrupt"]
pub const IRQn_Type_USART2_IRQn: IRQn_Type = 28;
#[doc = "< LED global Interrupt"]
pub const IRQn_Type_LED_IRQn: IRQn_Type = 30;
pub type IRQn_Type = ::core::ffi::c_int;
pub type int_least64_t = i64;
pub type uint_least64_t = u64;
pub type int_fast64_t = i64;
pub type uint_fast64_t = u64;
pub type int_least32_t = i32;
pub type uint_least32_t = u32;
pub type int_fast32_t = i32;
pub type uint_fast32_t = u32;
pub type int_least16_t = i16;
pub type uint_least16_t = u16;
pub type int_fast16_t = i16;
pub type uint_fast16_t = u16;
pub type int_least8_t = i8;
pub type uint_least8_t = u8;
pub type int_fast8_t = i8;
pub type uint_fast8_t = u8;
pub type intmax_t = ::core::ffi::c_longlong;
pub type uintmax_t = ::core::ffi::c_ulonglong;
#[doc = "\\brief  Union type to access the Application Program Status Register (APSR)."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union APSR_Type {
    #[doc = "< Structure used for bit  access"]
    pub b: APSR_Type__bindgen_ty_1,
    #[doc = "< Type      used for word access"]
    pub w: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct APSR_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_APSR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<APSR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(APSR_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<APSR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(APSR_Type__bindgen_ty_1))
    );
}
impl APSR_Type__bindgen_ty_1 {
    #[inline]
    pub fn _reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set__reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn V(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_V(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn C(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_C(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Z(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Z(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn N(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_N(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        _reserved0: u32,
        V: u32,
        C: u32,
        Z: u32,
        N: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 28u8, {
            let _reserved0: u32 = unsafe { ::core::mem::transmute(_reserved0) };
            _reserved0 as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let V: u32 = unsafe { ::core::mem::transmute(V) };
            V as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let C: u32 = unsafe { ::core::mem::transmute(C) };
            C as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let Z: u32 = unsafe { ::core::mem::transmute(Z) };
            Z as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let N: u32 = unsafe { ::core::mem::transmute(N) };
            N as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_APSR_Type() {
    const UNINIT: ::core::mem::MaybeUninit<APSR_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<APSR_Type>(),
        4usize,
        concat!("Size of: ", stringify!(APSR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<APSR_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(APSR_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).b) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(APSR_Type),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).w) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(APSR_Type),
            "::",
            stringify!(w)
        )
    );
}
#[doc = "\\brief  Union type to access the Interrupt Program Status Register (IPSR)."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union IPSR_Type {
    #[doc = "< Structure used for bit  access"]
    pub b: IPSR_Type__bindgen_ty_1,
    #[doc = "< Type      used for word access"]
    pub w: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPSR_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_IPSR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<IPSR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(IPSR_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<IPSR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(IPSR_Type__bindgen_ty_1))
    );
}
impl IPSR_Type__bindgen_ty_1 {
    #[inline]
    pub fn ISR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_ISR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn _reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 23u8) as u32) }
    }
    #[inline]
    pub fn set__reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 23u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(ISR: u32, _reserved0: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 9u8, {
            let ISR: u32 = unsafe { ::core::mem::transmute(ISR) };
            ISR as u64
        });
        __bindgen_bitfield_unit.set(9usize, 23u8, {
            let _reserved0: u32 = unsafe { ::core::mem::transmute(_reserved0) };
            _reserved0 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_IPSR_Type() {
    const UNINIT: ::core::mem::MaybeUninit<IPSR_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<IPSR_Type>(),
        4usize,
        concat!("Size of: ", stringify!(IPSR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<IPSR_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(IPSR_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).b) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IPSR_Type),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).w) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IPSR_Type),
            "::",
            stringify!(w)
        )
    );
}
#[doc = "\\brief  Union type to access the Special-Purpose Program Status Registers (xPSR)."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union xPSR_Type {
    #[doc = "< Structure used for bit  access"]
    pub b: xPSR_Type__bindgen_ty_1,
    #[doc = "< Type      used for word access"]
    pub w: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct xPSR_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_xPSR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<xPSR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(xPSR_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<xPSR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(xPSR_Type__bindgen_ty_1))
    );
}
impl xPSR_Type__bindgen_ty_1 {
    #[inline]
    pub fn ISR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_ISR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn _reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set__reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn T(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_T(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _reserved1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set__reserved1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn V(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_V(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn C(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_C(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Z(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Z(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn N(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_N(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ISR: u32,
        _reserved0: u32,
        T: u32,
        _reserved1: u32,
        V: u32,
        C: u32,
        Z: u32,
        N: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 9u8, {
            let ISR: u32 = unsafe { ::core::mem::transmute(ISR) };
            ISR as u64
        });
        __bindgen_bitfield_unit.set(9usize, 15u8, {
            let _reserved0: u32 = unsafe { ::core::mem::transmute(_reserved0) };
            _reserved0 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let T: u32 = unsafe { ::core::mem::transmute(T) };
            T as u64
        });
        __bindgen_bitfield_unit.set(25usize, 3u8, {
            let _reserved1: u32 = unsafe { ::core::mem::transmute(_reserved1) };
            _reserved1 as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let V: u32 = unsafe { ::core::mem::transmute(V) };
            V as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let C: u32 = unsafe { ::core::mem::transmute(C) };
            C as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let Z: u32 = unsafe { ::core::mem::transmute(Z) };
            Z as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let N: u32 = unsafe { ::core::mem::transmute(N) };
            N as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_xPSR_Type() {
    const UNINIT: ::core::mem::MaybeUninit<xPSR_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<xPSR_Type>(),
        4usize,
        concat!("Size of: ", stringify!(xPSR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<xPSR_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(xPSR_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).b) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xPSR_Type),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).w) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xPSR_Type),
            "::",
            stringify!(w)
        )
    );
}
#[doc = "\\brief  Union type to access the Control Registers (CONTROL)."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union CONTROL_Type {
    #[doc = "< Structure used for bit  access"]
    pub b: CONTROL_Type__bindgen_ty_1,
    #[doc = "< Type      used for word access"]
    pub w: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CONTROL_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_CONTROL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<CONTROL_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(CONTROL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<CONTROL_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(CONTROL_Type__bindgen_ty_1))
    );
}
impl CONTROL_Type__bindgen_ty_1 {
    #[inline]
    pub fn nPRIV(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_nPRIV(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SPSEL(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SPSEL(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _reserved1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set__reserved1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        nPRIV: u32,
        SPSEL: u32,
        _reserved1: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let nPRIV: u32 = unsafe { ::core::mem::transmute(nPRIV) };
            nPRIV as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let SPSEL: u32 = unsafe { ::core::mem::transmute(SPSEL) };
            SPSEL as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let _reserved1: u32 = unsafe { ::core::mem::transmute(_reserved1) };
            _reserved1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_CONTROL_Type() {
    const UNINIT: ::core::mem::MaybeUninit<CONTROL_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CONTROL_Type>(),
        4usize,
        concat!("Size of: ", stringify!(CONTROL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<CONTROL_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(CONTROL_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).b) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CONTROL_Type),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).w) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CONTROL_Type),
            "::",
            stringify!(w)
        )
    );
}
#[doc = "\\brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NVIC_Type {
    #[doc = "< Offset: 0x000 (R/W)  Interrupt Set Enable Register"]
    pub ISER: [u32; 1usize],
    pub RESERVED0: [u32; 31usize],
    #[doc = "< Offset: 0x080 (R/W)  Interrupt Clear Enable Register"]
    pub ICER: [u32; 1usize],
    pub RSERVED1: [u32; 31usize],
    #[doc = "< Offset: 0x100 (R/W)  Interrupt Set Pending Register"]
    pub ISPR: [u32; 1usize],
    pub RESERVED2: [u32; 31usize],
    #[doc = "< Offset: 0x180 (R/W)  Interrupt Clear Pending Register"]
    pub ICPR: [u32; 1usize],
    pub RESERVED3: [u32; 31usize],
    pub RESERVED4: [u32; 64usize],
    #[doc = "< Offset: 0x300 (R/W)  Interrupt Priority Register"]
    pub IP: [u32; 8usize],
}
#[test]
fn bindgen_test_layout_NVIC_Type() {
    const UNINIT: ::core::mem::MaybeUninit<NVIC_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<NVIC_Type>(),
        800usize,
        concat!("Size of: ", stringify!(NVIC_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<NVIC_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(NVIC_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ISER) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NVIC_Type),
            "::",
            stringify!(ISER)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RESERVED0) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NVIC_Type),
            "::",
            stringify!(RESERVED0)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ICER) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(NVIC_Type),
            "::",
            stringify!(ICER)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RSERVED1) as usize - ptr as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(NVIC_Type),
            "::",
            stringify!(RSERVED1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ISPR) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(NVIC_Type),
            "::",
            stringify!(ISPR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RESERVED2) as usize - ptr as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(NVIC_Type),
            "::",
            stringify!(RESERVED2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ICPR) as usize - ptr as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(NVIC_Type),
            "::",
            stringify!(ICPR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RESERVED3) as usize - ptr as usize },
        388usize,
        concat!(
            "Offset of field: ",
            stringify!(NVIC_Type),
            "::",
            stringify!(RESERVED3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RESERVED4) as usize - ptr as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(NVIC_Type),
            "::",
            stringify!(RESERVED4)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).IP) as usize - ptr as usize },
        768usize,
        concat!(
            "Offset of field: ",
            stringify!(NVIC_Type),
            "::",
            stringify!(IP)
        )
    );
}
#[doc = "\\brief  Structure type to access the System Control Block (SCB)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCB_Type {
    #[doc = "< Offset: 0x000 (R/ )  CPUID Base Register"]
    pub CPUID: u32,
    #[doc = "< Offset: 0x004 (R/W)  Interrupt Control and State Register"]
    pub ICSR: u32,
    #[doc = "< Offset: 0x008 (R/W)  Vector Table Offset Register"]
    pub VTOR: u32,
    #[doc = "< Offset: 0x00C (R/W)  Application Interrupt and Reset Control Register"]
    pub AIRCR: u32,
    #[doc = "< Offset: 0x010 (R/W)  System Control Register"]
    pub SCR: u32,
    #[doc = "< Offset: 0x014 (R/W)  Configuration Control Register"]
    pub CCR: u32,
    pub RESERVED1: u32,
    #[doc = "< Offset: 0x01C (R/W)  System Handlers Priority Registers. [0] is RESERVED"]
    pub SHP: [u32; 2usize],
    #[doc = "< Offset: 0x024 (R/W)  System Handler Control and State Register"]
    pub SHCSR: u32,
}
#[test]
fn bindgen_test_layout_SCB_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SCB_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SCB_Type>(),
        40usize,
        concat!("Size of: ", stringify!(SCB_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SCB_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SCB_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CPUID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SCB_Type),
            "::",
            stringify!(CPUID)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ICSR) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SCB_Type),
            "::",
            stringify!(ICSR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).VTOR) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SCB_Type),
            "::",
            stringify!(VTOR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AIRCR) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SCB_Type),
            "::",
            stringify!(AIRCR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SCR) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SCB_Type),
            "::",
            stringify!(SCR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CCR) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SCB_Type),
            "::",
            stringify!(CCR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RESERVED1) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SCB_Type),
            "::",
            stringify!(RESERVED1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SHP) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SCB_Type),
            "::",
            stringify!(SHP)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SHCSR) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(SCB_Type),
            "::",
            stringify!(SHCSR)
        )
    );
}
#[doc = "\\brief  Structure type to access the System Timer (SysTick)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SysTick_Type {
    #[doc = "< Offset: 0x000 (R/W)  SysTick Control and Status Register"]
    pub CTRL: u32,
    #[doc = "< Offset: 0x004 (R/W)  SysTick Reload Value Register"]
    pub LOAD: u32,
    #[doc = "< Offset: 0x008 (R/W)  SysTick Current Value Register"]
    pub VAL: u32,
    #[doc = "< Offset: 0x00C (R/ )  SysTick Calibration Register"]
    pub CALIB: u32,
}
#[test]
fn bindgen_test_layout_SysTick_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SysTick_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SysTick_Type>(),
        16usize,
        concat!("Size of: ", stringify!(SysTick_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SysTick_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SysTick_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CTRL) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SysTick_Type),
            "::",
            stringify!(CTRL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LOAD) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SysTick_Type),
            "::",
            stringify!(LOAD)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).VAL) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SysTick_Type),
            "::",
            stringify!(VAL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CALIB) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SysTick_Type),
            "::",
            stringify!(CALIB)
        )
    );
}
extern "C" {
    #[doc = "< System Clock Frequency (Core Clock)"]
    pub static mut SystemCoreClock: u32;
}
extern "C" {
    #[doc = "< AHB prescalers table values"]
    pub static AHBPrescTable: [u32; 16usize];
}
extern "C" {
    #[doc = "< APB prescalers table values"]
    pub static APBPrescTable: [u32; 8usize];
}
extern "C" {
    #[doc = "< HSI frequency table values"]
    pub static HSIFreqTable: [u32; 8usize];
}
extern "C" {
    #[doc = " @addtogroup PY32F0xx_System_Exported_Functions\n @{"]
    pub fn SystemInit();
}
extern "C" {
    pub fn SystemCoreClockUpdate();
}
#[doc = " @brief Analog to Digital Converter"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADC_TypeDef {
    #[doc = "< ADC interrupt and status register,             Address offset: 0x00"]
    pub ISR: u32,
    #[doc = "< ADC interrupt enable register,                 Address offset: 0x04"]
    pub IER: u32,
    #[doc = "< ADC control register,                          Address offset: 0x08"]
    pub CR: u32,
    #[doc = "< ADC configuration register 1,                  Address offset: 0x0C"]
    pub CFGR1: u32,
    #[doc = "< ADC configuration register 2,                  Address offset: 0x10"]
    pub CFGR2: u32,
    #[doc = "< ADC sampling time register,                    Address offset: 0x14"]
    pub SMPR: u32,
    #[doc = "< Reserved,                                                      0x18-0x1C"]
    pub RESERVED1: [u32; 2usize],
    #[doc = "< ADC analog watchdog 1 threshold register,      Address offset: 0x20"]
    pub TR: u32,
    #[doc = "< Reserved,                                                      0x24"]
    pub RESERVED2: u32,
    #[doc = "< ADC group regular sequencer register,          Address offset: 0x28"]
    pub CHSELR: u32,
    #[doc = "< Reserved,                                                      0x2C"]
    pub RESERVED3: [u32; 5usize],
    #[doc = "< ADC group regular data register,               Address offset: 0x40"]
    pub DR: u32,
    #[doc = "< ADC calibration configuration&status register  Address offset: 0x44"]
    pub CCSR: u32,
}
#[test]
fn bindgen_test_layout_ADC_TypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<ADC_TypeDef> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ADC_TypeDef>(),
        72usize,
        concat!("Size of: ", stringify!(ADC_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(ADC_TypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ISR) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_TypeDef),
            "::",
            stringify!(ISR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).IER) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_TypeDef),
            "::",
            stringify!(IER)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CR) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_TypeDef),
            "::",
            stringify!(CR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CFGR1) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_TypeDef),
            "::",
            stringify!(CFGR1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CFGR2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_TypeDef),
            "::",
            stringify!(CFGR2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SMPR) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_TypeDef),
            "::",
            stringify!(SMPR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RESERVED1) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_TypeDef),
            "::",
            stringify!(RESERVED1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TR) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_TypeDef),
            "::",
            stringify!(TR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RESERVED2) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_TypeDef),
            "::",
            stringify!(RESERVED2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CHSELR) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_TypeDef),
            "::",
            stringify!(CHSELR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RESERVED3) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_TypeDef),
            "::",
            stringify!(RESERVED3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DR) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_TypeDef),
            "::",
            stringify!(DR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CCSR) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_TypeDef),
            "::",
            stringify!(CCSR)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADC_Common_TypeDef {
    #[doc = "< ADC common configuration register,             Address offset: ADC1 base address + 0x308"]
    pub CCR: u32,
}
#[test]
fn bindgen_test_layout_ADC_Common_TypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<ADC_Common_TypeDef> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ADC_Common_TypeDef>(),
        4usize,
        concat!("Size of: ", stringify!(ADC_Common_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_Common_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(ADC_Common_TypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CCR) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_Common_TypeDef),
            "::",
            stringify!(CCR)
        )
    );
}
#[doc = " @brief CRC calculation unit"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CRC_TypeDef {
    #[doc = "< CRC Data register,                         Address offset: 0x00"]
    pub DR: u32,
    #[doc = "< CRC Independent data register,             Address offset: 0x04"]
    pub IDR: u32,
    #[doc = "< CRC Control register,                      Address offset: 0x08"]
    pub CR: u32,
}
#[test]
fn bindgen_test_layout_CRC_TypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<CRC_TypeDef> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CRC_TypeDef>(),
        12usize,
        concat!("Size of: ", stringify!(CRC_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<CRC_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(CRC_TypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DR) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CRC_TypeDef),
            "::",
            stringify!(DR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).IDR) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CRC_TypeDef),
            "::",
            stringify!(IDR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CR) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CRC_TypeDef),
            "::",
            stringify!(CR)
        )
    );
}
#[doc = " @brief Comparator"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct COMP_TypeDef {
    #[doc = "< COMP control and status register,           Address offset: 0x00"]
    pub CSR: u32,
    #[doc = "< COMP filter register,                       Address offset: 0x04"]
    pub FR: u32,
}
#[test]
fn bindgen_test_layout_COMP_TypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<COMP_TypeDef> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<COMP_TypeDef>(),
        8usize,
        concat!("Size of: ", stringify!(COMP_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<COMP_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(COMP_TypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CSR) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(COMP_TypeDef),
            "::",
            stringify!(CSR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FR) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(COMP_TypeDef),
            "::",
            stringify!(FR)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct COMP_Common_TypeDef {
    #[doc = "< COMP control and status register located in register of comparator instance odd, used for bits common to several COMP instances, Address offset: 0x00"]
    pub CSR_ODD: u32,
    pub FR_ODD: u32,
    pub RESERVED: [u32; 2usize],
    #[doc = "< COMP control and status register located in register of comparator instance even, used for bits common to several COMP instances, Address offset: 0x04"]
    pub CSR_EVEN: u32,
    pub FR_EVEN: u32,
}
#[test]
fn bindgen_test_layout_COMP_Common_TypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<COMP_Common_TypeDef> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<COMP_Common_TypeDef>(),
        24usize,
        concat!("Size of: ", stringify!(COMP_Common_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<COMP_Common_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(COMP_Common_TypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CSR_ODD) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(COMP_Common_TypeDef),
            "::",
            stringify!(CSR_ODD)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FR_ODD) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(COMP_Common_TypeDef),
            "::",
            stringify!(FR_ODD)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RESERVED) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(COMP_Common_TypeDef),
            "::",
            stringify!(RESERVED)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CSR_EVEN) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(COMP_Common_TypeDef),
            "::",
            stringify!(CSR_EVEN)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FR_EVEN) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(COMP_Common_TypeDef),
            "::",
            stringify!(FR_EVEN)
        )
    );
}
#[doc = " @brief Debug MCU"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DBGMCU_TypeDef {
    #[doc = "< MCU device ID code,              Address offset: 0x00"]
    pub IDCODE: u32,
    #[doc = "< Debug configuration register,    Address offset: 0x04"]
    pub CR: u32,
    #[doc = "< Debug APB freeze register 1,     Address offset: 0x08"]
    pub APBFZ1: u32,
    #[doc = "< Debug APB freeze register 2,     Address offset: 0x0C"]
    pub APBFZ2: u32,
}
#[test]
fn bindgen_test_layout_DBGMCU_TypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<DBGMCU_TypeDef> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<DBGMCU_TypeDef>(),
        16usize,
        concat!("Size of: ", stringify!(DBGMCU_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<DBGMCU_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(DBGMCU_TypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).IDCODE) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DBGMCU_TypeDef),
            "::",
            stringify!(IDCODE)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CR) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DBGMCU_TypeDef),
            "::",
            stringify!(CR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).APBFZ1) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DBGMCU_TypeDef),
            "::",
            stringify!(APBFZ1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).APBFZ2) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(DBGMCU_TypeDef),
            "::",
            stringify!(APBFZ2)
        )
    );
}
#[doc = " @brief DMA Controller"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DMA_TypeDef {
    #[doc = "< DMA interrupt status register,                 Address offset: 0x00"]
    pub ISR: u32,
    #[doc = "< DMA interrupt flag clear register,             Address offset: 0x04"]
    pub IFCR: u32,
}
#[test]
fn bindgen_test_layout_DMA_TypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<DMA_TypeDef> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<DMA_TypeDef>(),
        8usize,
        concat!("Size of: ", stringify!(DMA_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<DMA_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(DMA_TypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ISR) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMA_TypeDef),
            "::",
            stringify!(ISR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).IFCR) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DMA_TypeDef),
            "::",
            stringify!(IFCR)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DMA_Channel_TypeDef {
    #[doc = "< DMA channel x configuration register"]
    pub CCR: u32,
    #[doc = "< DMA channel x number of data register"]
    pub CNDTR: u32,
    #[doc = "< DMA channel x peripheral address register"]
    pub CPAR: u32,
    #[doc = "< DMA channel x memory address register"]
    pub CMAR: u32,
}
#[test]
fn bindgen_test_layout_DMA_Channel_TypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<DMA_Channel_TypeDef> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<DMA_Channel_TypeDef>(),
        16usize,
        concat!("Size of: ", stringify!(DMA_Channel_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<DMA_Channel_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(DMA_Channel_TypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CCR) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMA_Channel_TypeDef),
            "::",
            stringify!(CCR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CNDTR) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DMA_Channel_TypeDef),
            "::",
            stringify!(CNDTR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CPAR) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DMA_Channel_TypeDef),
            "::",
            stringify!(CPAR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CMAR) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(DMA_Channel_TypeDef),
            "::",
            stringify!(CMAR)
        )
    );
}
#[doc = " @brief Asynch Interrupt/Event Controller (EXTI)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EXTI_TypeDef {
    #[doc = "< EXTI Rising Trigger Selection Register 1,        Address offset:   0x00"]
    pub RTSR: u32,
    #[doc = "< EXTI Falling Trigger Selection Register 1,       Address offset:   0x04"]
    pub FTSR: u32,
    #[doc = "< EXTI Software Interrupt event Register 1,        Address offset:   0x08"]
    pub SWIER: u32,
    #[doc = "< EXTI Pending Register 1                          Address offset:   0x0C"]
    pub PR: u32,
    #[doc = "< Reserved 1,                                                0x10 -- 0x1C"]
    pub RESERVED1: [u32; 4usize],
    #[doc = "< Reserved 2,                                                0x20 -- 0x30"]
    pub RESERVED2: [u32; 5usize],
    #[doc = "< Reserved 3,                                                0x34 -- 0x5C"]
    pub RESERVED3: [u32; 11usize],
    #[doc = "< EXTI External Interrupt Configuration Register,            0x60 -- 0x68"]
    pub EXTICR: [u32; 3usize],
    #[doc = "< Reserved 5,                                                0x6C -- 0x7C"]
    pub RESERVED4: [u32; 5usize],
    #[doc = "< EXTI Interrupt Mask Register ,                   Address offset:   0x80"]
    pub IMR: u32,
    #[doc = "< EXTI Event Mask Register ,                       Address offset:   0x84"]
    pub EMR: u32,
}
#[test]
fn bindgen_test_layout_EXTI_TypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<EXTI_TypeDef> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<EXTI_TypeDef>(),
        136usize,
        concat!("Size of: ", stringify!(EXTI_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<EXTI_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(EXTI_TypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RTSR) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EXTI_TypeDef),
            "::",
            stringify!(RTSR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FTSR) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(EXTI_TypeDef),
            "::",
            stringify!(FTSR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SWIER) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(EXTI_TypeDef),
            "::",
            stringify!(SWIER)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PR) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(EXTI_TypeDef),
            "::",
            stringify!(PR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RESERVED1) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(EXTI_TypeDef),
            "::",
            stringify!(RESERVED1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RESERVED2) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(EXTI_TypeDef),
            "::",
            stringify!(RESERVED2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RESERVED3) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(EXTI_TypeDef),
            "::",
            stringify!(RESERVED3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EXTICR) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(EXTI_TypeDef),
            "::",
            stringify!(EXTICR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RESERVED4) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(EXTI_TypeDef),
            "::",
            stringify!(RESERVED4)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).IMR) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(EXTI_TypeDef),
            "::",
            stringify!(IMR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EMR) as usize - ptr as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(EXTI_TypeDef),
            "::",
            stringify!(EMR)
        )
    );
}
#[doc = " @brief FLASH Registers"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLASH_TypeDef {
    #[doc = "< FLASH Access Control register,                     Address offset: 0x00"]
    pub ACR: u32,
    #[doc = "< Reserved1,                                         Address offset: 0x04"]
    pub RESERVED1: u32,
    #[doc = "< FLASH Key register,                                Address offset: 0x08"]
    pub KEYR: u32,
    #[doc = "< FLASH Option Key register,                         Address offset: 0x0C"]
    pub OPTKEYR: u32,
    #[doc = "< FLASH Status register,                             Address offset: 0x10"]
    pub SR: u32,
    #[doc = "< FLASH Control register,                            Address offset: 0x14"]
    pub CR: u32,
    #[doc = "< Reserved2,                                         Address offset: 0x18-0x1C"]
    pub RESERVED2: [u32; 2usize],
    #[doc = "< FLASH Option register,                             Address offset: 0x20"]
    pub OPTR: u32,
    #[doc = "< FLASH SDK address register,                        Address offset: 0x24"]
    pub SDKR: u32,
    #[doc = "< Reserved2,                                         Address offset: 0x28"]
    pub RESERVED3: u32,
    #[doc = "< FLASH WRP address register,                        Address offset: 0x2C"]
    pub WRPR: u32,
    pub RESERVED4: [u32; 24usize],
    #[doc = "< FLASH sleep time config register,                  Address offset: 0x90"]
    pub STCR: u32,
    pub RESERVED5: [u32; 27usize],
    #[doc = "< FLASH TS0 register,                                Address offset: 0x100"]
    pub TS0: u32,
    #[doc = "< FLASH TS1 register,                                Address offset: 0x104"]
    pub TS1: u32,
    #[doc = "< FLASH TS2P register,                               Address offset: 0x108"]
    pub TS2P: u32,
    #[doc = "< FLASH TPS3 register,                               Address offset: 0x10C"]
    pub TPS3: u32,
    #[doc = "< FLASH TS3 register,                                Address offset: 0x110"]
    pub TS3: u32,
    #[doc = "< FLASH PERTPE register,                             Address offset: 0x114"]
    pub PERTPE: u32,
    #[doc = "< FLASH SMERTPE register,                            Address offset: 0x118"]
    pub SMERTPE: u32,
    #[doc = "< FLASH PRGTPE register,                             Address offset: 0x11C"]
    pub PRGTPE: u32,
    #[doc = "< FLASH PRETPE register,                             Address offset: 0x120"]
    pub PRETPE: u32,
}
#[test]
fn bindgen_test_layout_FLASH_TypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<FLASH_TypeDef> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<FLASH_TypeDef>(),
        292usize,
        concat!("Size of: ", stringify!(FLASH_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<FLASH_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(FLASH_TypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ACR) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FLASH_TypeDef),
            "::",
            stringify!(ACR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RESERVED1) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FLASH_TypeDef),
            "::",
            stringify!(RESERVED1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).KEYR) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FLASH_TypeDef),
            "::",
            stringify!(KEYR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OPTKEYR) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(FLASH_TypeDef),
            "::",
            stringify!(OPTKEYR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SR) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FLASH_TypeDef),
            "::",
            stringify!(SR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CR) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(FLASH_TypeDef),
            "::",
            stringify!(CR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RESERVED2) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FLASH_TypeDef),
            "::",
            stringify!(RESERVED2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OPTR) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(FLASH_TypeDef),
            "::",
            stringify!(OPTR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SDKR) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(FLASH_TypeDef),
            "::",
            stringify!(SDKR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RESERVED3) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(FLASH_TypeDef),
            "::",
            stringify!(RESERVED3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).WRPR) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(FLASH_TypeDef),
            "::",
            stringify!(WRPR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RESERVED4) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(FLASH_TypeDef),
            "::",
            stringify!(RESERVED4)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).STCR) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(FLASH_TypeDef),
            "::",
            stringify!(STCR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RESERVED5) as usize - ptr as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(FLASH_TypeDef),
            "::",
            stringify!(RESERVED5)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TS0) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(FLASH_TypeDef),
            "::",
            stringify!(TS0)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TS1) as usize - ptr as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(FLASH_TypeDef),
            "::",
            stringify!(TS1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TS2P) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(FLASH_TypeDef),
            "::",
            stringify!(TS2P)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TPS3) as usize - ptr as usize },
        268usize,
        concat!(
            "Offset of field: ",
            stringify!(FLASH_TypeDef),
            "::",
            stringify!(TPS3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TS3) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(FLASH_TypeDef),
            "::",
            stringify!(TS3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PERTPE) as usize - ptr as usize },
        276usize,
        concat!(
            "Offset of field: ",
            stringify!(FLASH_TypeDef),
            "::",
            stringify!(PERTPE)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SMERTPE) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(FLASH_TypeDef),
            "::",
            stringify!(SMERTPE)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PRGTPE) as usize - ptr as usize },
        284usize,
        concat!(
            "Offset of field: ",
            stringify!(FLASH_TypeDef),
            "::",
            stringify!(PRGTPE)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PRETPE) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(FLASH_TypeDef),
            "::",
            stringify!(PRETPE)
        )
    );
}
#[doc = " @brief Option Bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OB_TypeDef {
    #[doc = "< FLASH option byte Read protection,             Address offset: 0x00"]
    pub RDP: u8,
    #[doc = "< FLASH option byte user options,                Address offset: 0x01"]
    pub USER: u8,
    #[doc = "< Complemented FLASH option byte Read protection,Address offset: 0x02"]
    pub nRDP: u8,
    #[doc = "< Complemented FLASH option byte user options,   Address offset: 0x03"]
    pub nUSER: u8,
    #[doc = "< SDK area start address(stored in SDK[4:0]),    Address offset: 0x04"]
    pub SDK_STRT: u8,
    #[doc = "< SDK area end address(stored in SDK[12:8]),     Address offset: 0x05"]
    pub SDK_END: u8,
    #[doc = "< Complemented SDK area start address,           Address offset: 0x06"]
    pub nSDK_STRT: u8,
    #[doc = "< Complemented SDK area end address,             Address offset: 0x07"]
    pub nSDK_END: u8,
    #[doc = "< RESERVED1,                                     Address offset: 0x08"]
    pub RESERVED1: u32,
    #[doc = "< FLASH option byte write protection,            Address offset: 0x0C"]
    pub WRP: u16,
    #[doc = "< Complemented FLASH option byte write protection,Address offset: 0x0E"]
    pub nWRP: u16,
}
#[test]
fn bindgen_test_layout_OB_TypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<OB_TypeDef> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<OB_TypeDef>(),
        16usize,
        concat!("Size of: ", stringify!(OB_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<OB_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(OB_TypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RDP) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OB_TypeDef),
            "::",
            stringify!(RDP)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).USER) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(OB_TypeDef),
            "::",
            stringify!(USER)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nRDP) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(OB_TypeDef),
            "::",
            stringify!(nRDP)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nUSER) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(OB_TypeDef),
            "::",
            stringify!(nUSER)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SDK_STRT) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(OB_TypeDef),
            "::",
            stringify!(SDK_STRT)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SDK_END) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(OB_TypeDef),
            "::",
            stringify!(SDK_END)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nSDK_STRT) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(OB_TypeDef),
            "::",
            stringify!(nSDK_STRT)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nSDK_END) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(OB_TypeDef),
            "::",
            stringify!(nSDK_END)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RESERVED1) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OB_TypeDef),
            "::",
            stringify!(RESERVED1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).WRP) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(OB_TypeDef),
            "::",
            stringify!(WRP)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nWRP) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(OB_TypeDef),
            "::",
            stringify!(nWRP)
        )
    );
}
#[doc = " @brief General Purpose I/O"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GPIO_TypeDef {
    #[doc = "< GPIO port mode register,               Address offset: 0x00"]
    pub MODER: u32,
    #[doc = "< GPIO port output type register,        Address offset: 0x04"]
    pub OTYPER: u32,
    #[doc = "< GPIO port output speed register,       Address offset: 0x08"]
    pub OSPEEDR: u32,
    #[doc = "< GPIO port pull-up/pull-down register,  Address offset: 0x0C"]
    pub PUPDR: u32,
    #[doc = "< GPIO port input data register,         Address offset: 0x10"]
    pub IDR: u32,
    #[doc = "< GPIO port output data register,        Address offset: 0x14"]
    pub ODR: u32,
    #[doc = "< GPIO port bit set/reset  register,     Address offset: 0x18"]
    pub BSRR: u32,
    #[doc = "< GPIO port configuration lock register, Address offset: 0x1C"]
    pub LCKR: u32,
    #[doc = "< GPIO alternate function registers,     Address offset: 0x20-0x24"]
    pub AFR: [u32; 2usize],
    #[doc = "< GPIO Bit Reset register,               Address offset: 0x28"]
    pub BRR: u32,
}
#[test]
fn bindgen_test_layout_GPIO_TypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<GPIO_TypeDef> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<GPIO_TypeDef>(),
        44usize,
        concat!("Size of: ", stringify!(GPIO_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<GPIO_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(GPIO_TypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MODER) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GPIO_TypeDef),
            "::",
            stringify!(MODER)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OTYPER) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GPIO_TypeDef),
            "::",
            stringify!(OTYPER)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OSPEEDR) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GPIO_TypeDef),
            "::",
            stringify!(OSPEEDR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PUPDR) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(GPIO_TypeDef),
            "::",
            stringify!(PUPDR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).IDR) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GPIO_TypeDef),
            "::",
            stringify!(IDR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ODR) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(GPIO_TypeDef),
            "::",
            stringify!(ODR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BSRR) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(GPIO_TypeDef),
            "::",
            stringify!(BSRR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LCKR) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(GPIO_TypeDef),
            "::",
            stringify!(LCKR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AFR) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(GPIO_TypeDef),
            "::",
            stringify!(AFR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BRR) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(GPIO_TypeDef),
            "::",
            stringify!(BRR)
        )
    );
}
#[doc = " @brief Inter-integrated Circuit Interface"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct I2C_TypeDef {
    pub CR1: u32,
    pub CR2: u32,
    pub OAR1: u32,
    pub OAR2: u32,
    pub DR: u32,
    pub SR1: u32,
    pub SR2: u32,
    pub CCR: u32,
    pub TRISE: u32,
}
#[test]
fn bindgen_test_layout_I2C_TypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<I2C_TypeDef> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<I2C_TypeDef>(),
        36usize,
        concat!("Size of: ", stringify!(I2C_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<I2C_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(I2C_TypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CR1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(I2C_TypeDef),
            "::",
            stringify!(CR1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CR2) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(I2C_TypeDef),
            "::",
            stringify!(CR2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OAR1) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(I2C_TypeDef),
            "::",
            stringify!(OAR1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OAR2) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(I2C_TypeDef),
            "::",
            stringify!(OAR2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DR) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(I2C_TypeDef),
            "::",
            stringify!(DR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SR1) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(I2C_TypeDef),
            "::",
            stringify!(SR1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SR2) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(I2C_TypeDef),
            "::",
            stringify!(SR2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CCR) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(I2C_TypeDef),
            "::",
            stringify!(CCR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TRISE) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(I2C_TypeDef),
            "::",
            stringify!(TRISE)
        )
    );
}
#[doc = " @brief Independent WATCHDOG"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IWDG_TypeDef {
    #[doc = "< IWDG Key register,       Address offset: 0x00"]
    pub KR: u32,
    #[doc = "< IWDG Prescaler register, Address offset: 0x04"]
    pub PR: u32,
    #[doc = "< IWDG Reload register,    Address offset: 0x08"]
    pub RLR: u32,
    #[doc = "< IWDG Status register,    Address offset: 0x0C"]
    pub SR: u32,
}
#[test]
fn bindgen_test_layout_IWDG_TypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<IWDG_TypeDef> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<IWDG_TypeDef>(),
        16usize,
        concat!("Size of: ", stringify!(IWDG_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<IWDG_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(IWDG_TypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).KR) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IWDG_TypeDef),
            "::",
            stringify!(KR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PR) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IWDG_TypeDef),
            "::",
            stringify!(PR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RLR) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IWDG_TypeDef),
            "::",
            stringify!(RLR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SR) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(IWDG_TypeDef),
            "::",
            stringify!(SR)
        )
    );
}
#[doc = " @brief LPTIMER"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LPTIM_TypeDef {
    #[doc = "< LPTIM Interrupt and Status register,                Address offset: 0x00"]
    pub ISR: u32,
    #[doc = "< LPTIM Interrupt Clear register,                     Address offset: 0x04"]
    pub ICR: u32,
    #[doc = "< LPTIM Interrupt Enable register,                    Address offset: 0x08"]
    pub IER: u32,
    #[doc = "< LPTIM Configuration register,                       Address offset: 0x0C"]
    pub CFGR: u32,
    #[doc = "< LPTIM Control register,                             Address offset: 0x10"]
    pub CR: u32,
    #[doc = "< RESERVED1,                                          Address offset: 0x14"]
    pub RESERVED1: u32,
    #[doc = "< LPTIM Autoreload register,                          Address offset: 0x18"]
    pub ARR: u32,
    #[doc = "< LPTIM Counter register,                             Address offset: 0x1C"]
    pub CNT: u32,
}
#[test]
fn bindgen_test_layout_LPTIM_TypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<LPTIM_TypeDef> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<LPTIM_TypeDef>(),
        32usize,
        concat!("Size of: ", stringify!(LPTIM_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<LPTIM_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(LPTIM_TypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ISR) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LPTIM_TypeDef),
            "::",
            stringify!(ISR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ICR) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(LPTIM_TypeDef),
            "::",
            stringify!(ICR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).IER) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LPTIM_TypeDef),
            "::",
            stringify!(IER)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CFGR) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(LPTIM_TypeDef),
            "::",
            stringify!(CFGR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CR) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LPTIM_TypeDef),
            "::",
            stringify!(CR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RESERVED1) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(LPTIM_TypeDef),
            "::",
            stringify!(RESERVED1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ARR) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(LPTIM_TypeDef),
            "::",
            stringify!(ARR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CNT) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(LPTIM_TypeDef),
            "::",
            stringify!(CNT)
        )
    );
}
#[doc = " @brief Power Control"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PWR_TypeDef {
    #[doc = "< PWR Power Control Register 1,                     Address offset: 0x00"]
    pub CR1: u32,
    #[doc = "< PWR Power Control Register 2,                     Address offset: 0x04"]
    pub CR2: u32,
    #[doc = "< Reserved1,                                        Address offset: 0x08-0x10"]
    pub RESERVED1: [u32; 3usize],
    #[doc = "< PWR Power Status Register,                        Address offset: 0x14"]
    pub SR: u32,
}
#[test]
fn bindgen_test_layout_PWR_TypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<PWR_TypeDef> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<PWR_TypeDef>(),
        24usize,
        concat!("Size of: ", stringify!(PWR_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<PWR_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(PWR_TypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CR1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PWR_TypeDef),
            "::",
            stringify!(CR1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CR2) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PWR_TypeDef),
            "::",
            stringify!(CR2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RESERVED1) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PWR_TypeDef),
            "::",
            stringify!(RESERVED1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SR) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(PWR_TypeDef),
            "::",
            stringify!(SR)
        )
    );
}
#[doc = " @brief Reset and Clock Control"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RCC_TypeDef {
    #[doc = "< RCC Clock Sources Control Register,                                     Address offset: 0x00"]
    pub CR: u32,
    #[doc = "< RCC Internal Clock Sources Calibration Register,                        Address offset: 0x04"]
    pub ICSCR: u32,
    #[doc = "< RCC Regulated Domain Clocks Configuration Register,                     Address offset: 0x08"]
    pub CFGR: u32,
    #[doc = "< RCC System PLL configuration Register,                                  Address offset: 0x0C"]
    pub PLLCFGR: u32,
    #[doc = "< RCC External clock source control register,                             Address offset: 0x10"]
    pub ECSCR: u32,
    #[doc = "< Reserved,                                                               Address offset: 0x14"]
    pub RESERVED1: u32,
    #[doc = "< RCC Clock Interrupt Enable Register,                                    Address offset: 0x18"]
    pub CIER: u32,
    #[doc = "< RCC Clock Interrupt Flag Register,                                      Address offset: 0x1C"]
    pub CIFR: u32,
    #[doc = "< RCC Clock Interrupt Clear Register,                                     Address offset: 0x20"]
    pub CICR: u32,
    #[doc = "< RCC IO port reset register,                                             Address offset: 0x24"]
    pub IOPRSTR: u32,
    #[doc = "< RCC AHB peripherals reset register,                                     Address offset: 0x28"]
    pub AHBRSTR: u32,
    #[doc = "< RCC APB peripherals reset register 1,                                   Address offset: 0x2C"]
    pub APBRSTR1: u32,
    #[doc = "< RCC APB peripherals reset register 2,                                   Address offset: 0x30"]
    pub APBRSTR2: u32,
    #[doc = "< RCC IO port enable register,                                            Address offset: 0x34"]
    pub IOPENR: u32,
    #[doc = "< RCC AHB peripherals clock enable register,                              Address offset: 0x38"]
    pub AHBENR: u32,
    #[doc = "< RCC APB peripherals clock enable register1,                             Address offset: 0x3C"]
    pub APBENR1: u32,
    #[doc = "< RCC APB peripherals clock enable register2,                             Address offset: 0x40"]
    pub APBENR2: u32,
    #[doc = "< Reserved,                                                               Address offset: 0x44-0x50"]
    pub RESERVED2: [u32; 4usize],
    #[doc = "< RCC Peripherals Independent Clocks Configuration Register,              Address offset: 0x54"]
    pub CCIPR: u32,
    #[doc = "< Reserved,                                                               Address offset: 0x58"]
    pub RESERVED3: u32,
    #[doc = "< RCC Backup Domain Control Register,                                     Address offset: 0x5C"]
    pub BDCR: u32,
    #[doc = "< RCC Unregulated Domain Clock Control and Status Register,               Address offset: 0x60"]
    pub CSR: u32,
}
#[test]
fn bindgen_test_layout_RCC_TypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<RCC_TypeDef> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<RCC_TypeDef>(),
        100usize,
        concat!("Size of: ", stringify!(RCC_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<RCC_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(RCC_TypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CR) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_TypeDef),
            "::",
            stringify!(CR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ICSCR) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_TypeDef),
            "::",
            stringify!(ICSCR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CFGR) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_TypeDef),
            "::",
            stringify!(CFGR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PLLCFGR) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_TypeDef),
            "::",
            stringify!(PLLCFGR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ECSCR) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_TypeDef),
            "::",
            stringify!(ECSCR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RESERVED1) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_TypeDef),
            "::",
            stringify!(RESERVED1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CIER) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_TypeDef),
            "::",
            stringify!(CIER)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CIFR) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_TypeDef),
            "::",
            stringify!(CIFR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CICR) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_TypeDef),
            "::",
            stringify!(CICR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).IOPRSTR) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_TypeDef),
            "::",
            stringify!(IOPRSTR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AHBRSTR) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_TypeDef),
            "::",
            stringify!(AHBRSTR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).APBRSTR1) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_TypeDef),
            "::",
            stringify!(APBRSTR1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).APBRSTR2) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_TypeDef),
            "::",
            stringify!(APBRSTR2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).IOPENR) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_TypeDef),
            "::",
            stringify!(IOPENR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AHBENR) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_TypeDef),
            "::",
            stringify!(AHBENR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).APBENR1) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_TypeDef),
            "::",
            stringify!(APBENR1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).APBENR2) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_TypeDef),
            "::",
            stringify!(APBENR2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RESERVED2) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_TypeDef),
            "::",
            stringify!(RESERVED2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CCIPR) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_TypeDef),
            "::",
            stringify!(CCIPR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RESERVED3) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_TypeDef),
            "::",
            stringify!(RESERVED3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BDCR) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_TypeDef),
            "::",
            stringify!(BDCR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CSR) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_TypeDef),
            "::",
            stringify!(CSR)
        )
    );
}
#[doc = " @brief Real-Time Clock"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RTC_TypeDef {
    pub CRH: u32,
    pub CRL: u32,
    pub PRLH: u32,
    pub PRLL: u32,
    pub DIVH: u32,
    pub DIVL: u32,
    pub CNTH: u32,
    pub CNTL: u32,
    pub ALRH: u32,
    pub ALRL: u32,
    pub RESERVED1: u32,
    pub BKP_RTCCR: u32,
}
#[test]
fn bindgen_test_layout_RTC_TypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<RTC_TypeDef> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<RTC_TypeDef>(),
        48usize,
        concat!("Size of: ", stringify!(RTC_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(RTC_TypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CRH) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(CRH)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CRL) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(CRL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PRLH) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(PRLH)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PRLL) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(PRLL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DIVH) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(DIVH)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DIVL) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(DIVL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CNTH) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(CNTH)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CNTL) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(CNTL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ALRH) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(ALRH)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ALRL) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(ALRL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RESERVED1) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(RESERVED1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BKP_RTCCR) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(BKP_RTCCR)
        )
    );
}
#[doc = " @brief Serial Peripheral Interface"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SPI_TypeDef {
    #[doc = "< SPI Control register 1,                              Address offset: 0x00"]
    pub CR1: u32,
    #[doc = "< SPI Control register 2,                              Address offset: 0x04"]
    pub CR2: u32,
    #[doc = "< SPI Status register,                                 Address offset: 0x08"]
    pub SR: u32,
    #[doc = "< SPI data register,                                   Address offset: 0x0C"]
    pub DR: u32,
}
#[test]
fn bindgen_test_layout_SPI_TypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<SPI_TypeDef> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SPI_TypeDef>(),
        16usize,
        concat!("Size of: ", stringify!(SPI_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<SPI_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(SPI_TypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CR1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_TypeDef),
            "::",
            stringify!(CR1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CR2) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_TypeDef),
            "::",
            stringify!(CR2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SR) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_TypeDef),
            "::",
            stringify!(SR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DR) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_TypeDef),
            "::",
            stringify!(DR)
        )
    );
}
#[doc = " @brief System configuration controller"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SYSCFG_TypeDef {
    #[doc = "< SYSCFG configuration register 1,                   Address offset: 0x00"]
    pub CFGR1: u32,
    #[doc = "< Reserved,                                                   0x04 --0x14"]
    pub RESERVED1: [u32; 5usize],
    #[doc = "< SYSCFG configuration register 2,                   Address offset: 0x18"]
    pub CFGR2: u32,
    #[doc = "< SYSCFG configuration register 3,                   Address offset: 0x1C"]
    pub CFGR3: u32,
}
#[test]
fn bindgen_test_layout_SYSCFG_TypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<SYSCFG_TypeDef> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SYSCFG_TypeDef>(),
        32usize,
        concat!("Size of: ", stringify!(SYSCFG_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<SYSCFG_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(SYSCFG_TypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CFGR1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSCFG_TypeDef),
            "::",
            stringify!(CFGR1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RESERVED1) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSCFG_TypeDef),
            "::",
            stringify!(RESERVED1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CFGR2) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSCFG_TypeDef),
            "::",
            stringify!(CFGR2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CFGR3) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSCFG_TypeDef),
            "::",
            stringify!(CFGR3)
        )
    );
}
#[doc = " @brief TIM"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TIM_TypeDef {
    #[doc = "< TIM control register 1,                   Address offset: 0x00"]
    pub CR1: u32,
    #[doc = "< TIM control register 2,                   Address offset: 0x04"]
    pub CR2: u32,
    #[doc = "< TIM slave mode control register,          Address offset: 0x08"]
    pub SMCR: u32,
    #[doc = "< TIM DMA/interrupt enable register,        Address offset: 0x0C"]
    pub DIER: u32,
    #[doc = "< TIM status register,                      Address offset: 0x10"]
    pub SR: u32,
    #[doc = "< TIM event generation register,            Address offset: 0x14"]
    pub EGR: u32,
    #[doc = "< TIM capture/compare mode register 1,      Address offset: 0x18"]
    pub CCMR1: u32,
    #[doc = "< TIM capture/compare mode register 2,      Address offset: 0x1C"]
    pub CCMR2: u32,
    #[doc = "< TIM capture/compare enable register,      Address offset: 0x20"]
    pub CCER: u32,
    #[doc = "< TIM counter register,                     Address offset: 0x24"]
    pub CNT: u32,
    #[doc = "< TIM prescaler register,                   Address offset: 0x28"]
    pub PSC: u32,
    #[doc = "< TIM auto-reload register,                 Address offset: 0x2C"]
    pub ARR: u32,
    #[doc = "< TIM repetition counter register,          Address offset: 0x30"]
    pub RCR: u32,
    #[doc = "< TIM capture/compare register 1,           Address offset: 0x34"]
    pub CCR1: u32,
    #[doc = "< TIM capture/compare register 2,           Address offset: 0x38"]
    pub CCR2: u32,
    #[doc = "< TIM capture/compare register 3,           Address offset: 0x3C"]
    pub CCR3: u32,
    #[doc = "< TIM capture/compare register 4,           Address offset: 0x40"]
    pub CCR4: u32,
    #[doc = "< TIM break and dead-time register,         Address offset: 0x44"]
    pub BDTR: u32,
    #[doc = "< TIM DMA control register,                 Address offset: 0x48"]
    pub DCR: u32,
    #[doc = "< TIM DMA address for full transfer,        Address offset: 0x4C"]
    pub DMAR: u32,
    #[doc = "< TIM option register,                      Address offset: 0x50"]
    pub OR: u32,
}
#[test]
fn bindgen_test_layout_TIM_TypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<TIM_TypeDef> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TIM_TypeDef>(),
        84usize,
        concat!("Size of: ", stringify!(TIM_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<TIM_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(TIM_TypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CR1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(CR1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CR2) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(CR2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SMCR) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(SMCR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DIER) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(DIER)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SR) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(SR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EGR) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(EGR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CCMR1) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(CCMR1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CCMR2) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(CCMR2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CCER) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(CCER)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CNT) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(CNT)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PSC) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(PSC)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ARR) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(ARR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RCR) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(RCR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CCR1) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(CCR1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CCR2) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(CCR2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CCR3) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(CCR3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CCR4) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(CCR4)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BDTR) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(BDTR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DCR) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(DCR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DMAR) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(DMAR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OR) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(OR)
        )
    );
}
#[doc = " @brief Universal Synchronous Asynchronous Receiver Transmitter"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct USART_TypeDef {
    #[doc = "< USART     Status  register ,              Address offset: 0x00"]
    pub SR: u32,
    #[doc = "< USART Data register,                      Address offset: 0x04"]
    pub DR: u32,
    #[doc = "< USART Baud rate register,                 Address offset: 0x08"]
    pub BRR: u32,
    #[doc = "< USART     Control  register 1,            Address offset: 0x0C"]
    pub CR1: u32,
    #[doc = "< USART     Control  register 2,            Address offset: 0x10"]
    pub CR2: u32,
    #[doc = "< USART     Control  register 3,            Address offset: 0x14"]
    pub CR3: u32,
    #[doc = "< USART Guard time and prescaler register,  Address offset: 0x18"]
    pub GTPR: u32,
}
#[test]
fn bindgen_test_layout_USART_TypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<USART_TypeDef> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<USART_TypeDef>(),
        28usize,
        concat!("Size of: ", stringify!(USART_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<USART_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(USART_TypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SR) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USART_TypeDef),
            "::",
            stringify!(SR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DR) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(USART_TypeDef),
            "::",
            stringify!(DR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BRR) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(USART_TypeDef),
            "::",
            stringify!(BRR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CR1) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(USART_TypeDef),
            "::",
            stringify!(CR1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CR2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(USART_TypeDef),
            "::",
            stringify!(CR2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CR3) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(USART_TypeDef),
            "::",
            stringify!(CR3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).GTPR) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(USART_TypeDef),
            "::",
            stringify!(GTPR)
        )
    );
}
#[doc = " @brief Window WATCHDOG"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WWDG_TypeDef {
    #[doc = "< WWDG Control register,       Address offset: 0x00"]
    pub CR: u32,
    #[doc = "< WWDG Configuration register, Address offset: 0x04"]
    pub CFR: u32,
    #[doc = "< WWDG Status register,        Address offset: 0x08"]
    pub SR: u32,
}
#[test]
fn bindgen_test_layout_WWDG_TypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<WWDG_TypeDef> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<WWDG_TypeDef>(),
        12usize,
        concat!("Size of: ", stringify!(WWDG_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<WWDG_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(WWDG_TypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CR) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WWDG_TypeDef),
            "::",
            stringify!(CR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CFR) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(WWDG_TypeDef),
            "::",
            stringify!(CFR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SR) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(WWDG_TypeDef),
            "::",
            stringify!(SR)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LED_TypeDef {
    #[doc = "< LED Control register,        Address offset: 0x00"]
    pub CR: u32,
    #[doc = "< LED Prescaler register,      Address offset: 0x04"]
    pub PR: u32,
    #[doc = "< Time register,               Address offset: 0x08"]
    pub TR: u32,
    #[doc = "< Data0 register,              Address offset: 0x0C"]
    pub DR0: u32,
    #[doc = "< Data1 register,              Address offset: 0x10"]
    pub DR1: u32,
    #[doc = "< Data2 register,              Address offset: 0x14"]
    pub DR2: u32,
    #[doc = "< Data3 register,              Address offset: 0x18"]
    pub DR3: u32,
    #[doc = "< Interrupt register,          Address offset: 0x1C"]
    pub IR: u32,
}
#[test]
fn bindgen_test_layout_LED_TypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<LED_TypeDef> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<LED_TypeDef>(),
        32usize,
        concat!("Size of: ", stringify!(LED_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<LED_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(LED_TypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CR) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LED_TypeDef),
            "::",
            stringify!(CR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PR) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(LED_TypeDef),
            "::",
            stringify!(PR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TR) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LED_TypeDef),
            "::",
            stringify!(TR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DR0) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(LED_TypeDef),
            "::",
            stringify!(DR0)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DR1) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LED_TypeDef),
            "::",
            stringify!(DR1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DR2) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(LED_TypeDef),
            "::",
            stringify!(DR2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DR3) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(LED_TypeDef),
            "::",
            stringify!(DR3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).IR) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(LED_TypeDef),
            "::",
            stringify!(IR)
        )
    );
}
pub const FlagStatus_RESET: FlagStatus = 0;
pub const FlagStatus_SET: FlagStatus = 1;
#[doc = " @brief Exported_types"]
pub type FlagStatus = ::core::ffi::c_uint;
#[doc = " @brief Exported_types"]
pub use self::FlagStatus as ITStatus;
pub const FunctionalState_DISABLE: FunctionalState = 0;
pub const FunctionalState_ENABLE: FunctionalState = 1;
pub type FunctionalState = ::core::ffi::c_uint;
pub const ErrorStatus_SUCCESS: ErrorStatus = 0;
pub const ErrorStatus_ERROR: ErrorStatus = 1;
pub type ErrorStatus = ::core::ffi::c_uint;
pub const HAL_StatusTypeDef_HAL_OK: HAL_StatusTypeDef = 0;
pub const HAL_StatusTypeDef_HAL_ERROR: HAL_StatusTypeDef = 1;
pub const HAL_StatusTypeDef_HAL_BUSY: HAL_StatusTypeDef = 2;
pub const HAL_StatusTypeDef_HAL_TIMEOUT: HAL_StatusTypeDef = 3;
#[doc = " @brief  HAL Status structures definition"]
pub type HAL_StatusTypeDef = ::core::ffi::c_uint;
pub const HAL_LockTypeDef_HAL_UNLOCKED: HAL_LockTypeDef = 0;
pub const HAL_LockTypeDef_HAL_LOCKED: HAL_LockTypeDef = 1;
#[doc = " @brief  HAL Lock structures definition"]
pub type HAL_LockTypeDef = ::core::ffi::c_uint;
#[doc = " @brief  RCC PLL configuration structure definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RCC_PLLInitTypeDef {
    #[doc = "< The new state of the PLL.\nThis parameter can be a value of @ref RCC_PLL_Config"]
    pub PLLState: u32,
    #[doc = "< RCC_PLLSource: PLL entry clock source.\nThis parameter must be a value of @ref RCC_PLL_Clock_Source"]
    pub PLLSource: u32,
}
#[test]
fn bindgen_test_layout_RCC_PLLInitTypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<RCC_PLLInitTypeDef> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<RCC_PLLInitTypeDef>(),
        8usize,
        concat!("Size of: ", stringify!(RCC_PLLInitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<RCC_PLLInitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(RCC_PLLInitTypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PLLState) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_PLLInitTypeDef),
            "::",
            stringify!(PLLState)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PLLSource) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_PLLInitTypeDef),
            "::",
            stringify!(PLLSource)
        )
    );
}
#[doc = " @brief  RCC Internal/External Oscillator (HSE, HSI, LSE and LSI) configuration structure definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RCC_OscInitTypeDef {
    #[doc = "< The oscillators to be configured.\nThis parameter can be a value of @ref RCC_Oscillator_Type"]
    pub OscillatorType: u32,
    #[doc = "< The new state of the HSE.\nThis parameter can be a value of @ref RCC_HSE_Config"]
    pub HSEState: u32,
    #[doc = "< The frequency range of the HSE.\nThis parameter can be a value of @ref RCC_HSE_Freq"]
    pub HSEFreq: u32,
    #[doc = "< The new state of the LSE.\nThis parameter can be a value of @ref RCC_LSE_Config"]
    pub LSEState: u32,
    #[doc = "< The driver factor of the LSE.\nThis parameter can be a value of @ref RCC_LSE_Driver"]
    pub LSEDriver: u32,
    #[doc = "< The new state of the HSI.\nThis parameter can be a value of @ref RCC_HSI_Config"]
    pub HSIState: u32,
    #[doc = "< The division factor of the HSI.\nThis parameter can be a value of @ref RCC_HSI_Div"]
    pub HSIDiv: u32,
    #[doc = "< The calibration trimming value (default is RCC_HSICALIBRATION_8MHz).\nThis parameter can be a value of @ref RCC_HSI_Calibration"]
    pub HSICalibrationValue: u32,
    #[doc = "< The new state of the LSI.\nThis parameter can be a value of @ref RCC_LSI_Config"]
    pub LSIState: u32,
    #[doc = "< Main PLL structure parameters"]
    pub PLL: RCC_PLLInitTypeDef,
}
#[test]
fn bindgen_test_layout_RCC_OscInitTypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<RCC_OscInitTypeDef> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<RCC_OscInitTypeDef>(),
        44usize,
        concat!("Size of: ", stringify!(RCC_OscInitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<RCC_OscInitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(RCC_OscInitTypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OscillatorType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_OscInitTypeDef),
            "::",
            stringify!(OscillatorType)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).HSEState) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_OscInitTypeDef),
            "::",
            stringify!(HSEState)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).HSEFreq) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_OscInitTypeDef),
            "::",
            stringify!(HSEFreq)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LSEState) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_OscInitTypeDef),
            "::",
            stringify!(LSEState)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LSEDriver) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_OscInitTypeDef),
            "::",
            stringify!(LSEDriver)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).HSIState) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_OscInitTypeDef),
            "::",
            stringify!(HSIState)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).HSIDiv) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_OscInitTypeDef),
            "::",
            stringify!(HSIDiv)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).HSICalibrationValue) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_OscInitTypeDef),
            "::",
            stringify!(HSICalibrationValue)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LSIState) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_OscInitTypeDef),
            "::",
            stringify!(LSIState)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PLL) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_OscInitTypeDef),
            "::",
            stringify!(PLL)
        )
    );
}
#[doc = " @brief  RCC System, AHB and APB busses clock configuration structure definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RCC_ClkInitTypeDef {
    #[doc = "< The clock to be configured.\nThis parameter can be a combination of @ref RCC_System_Clock_Type"]
    pub ClockType: u32,
    #[doc = "< The clock source used as system clock (SYSCLK).\nThis parameter can be a value of @ref RCC_System_Clock_Source"]
    pub SYSCLKSource: u32,
    #[doc = "< The AHB clock (HCLK) divider. This clock is derived from the system clock (SYSCLK).\nThis parameter can be a value of @ref RCC_AHB_Clock_Source"]
    pub AHBCLKDivider: u32,
    #[doc = "< The APB1 clock (PCLK1) divider. This clock is derived from the AHB clock (HCLK).\nThis parameter can be a value of @ref RCC_APB1_Clock_Source"]
    pub APB1CLKDivider: u32,
}
#[test]
fn bindgen_test_layout_RCC_ClkInitTypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<RCC_ClkInitTypeDef> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<RCC_ClkInitTypeDef>(),
        16usize,
        concat!("Size of: ", stringify!(RCC_ClkInitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<RCC_ClkInitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(RCC_ClkInitTypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ClockType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_ClkInitTypeDef),
            "::",
            stringify!(ClockType)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SYSCLKSource) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_ClkInitTypeDef),
            "::",
            stringify!(SYSCLKSource)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AHBCLKDivider) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_ClkInitTypeDef),
            "::",
            stringify!(AHBCLKDivider)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).APB1CLKDivider) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_ClkInitTypeDef),
            "::",
            stringify!(APB1CLKDivider)
        )
    );
}
#[doc = " @brief  RCC extended clocks structure definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RCC_PeriphCLKInitTypeDef {
    #[doc = "< The Extended Clock to be configured.\nThis parameter can be a value of @ref RCCEx_Periph_Clock_Selection"]
    pub PeriphClockSelection: u32,
    #[doc = "< Specifies PVD clock source.\nThis parameter can be a value of @ref RCCEx_PVD_Clock_Source"]
    pub PvdClockSelection: u32,
    #[doc = "< Specifies COMP1 clock source.\nThis parameter can be a value of @ref RCCEx_COMP1_Clock_Source"]
    pub Comp1ClockSelection: u32,
    #[doc = "< Specifies COMP2 clock source.\nThis parameter can be a value of @ref RCCEx_COMP2_Clock_Source"]
    pub Comp2ClockSelection: u32,
    #[doc = "< Specifies LPTIM1 clock source\nThis parameter can be a value of @ref RCCEx_LPTIM1_Clock_Source"]
    pub LptimClockSelection: u32,
    #[doc = "< Specifies RTC clock source.\nThis parameter can be a value of @ref RCC_RTC_Clock_Source"]
    pub RTCClockSelection: u32,
}
#[test]
fn bindgen_test_layout_RCC_PeriphCLKInitTypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<RCC_PeriphCLKInitTypeDef> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<RCC_PeriphCLKInitTypeDef>(),
        24usize,
        concat!("Size of: ", stringify!(RCC_PeriphCLKInitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<RCC_PeriphCLKInitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(RCC_PeriphCLKInitTypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PeriphClockSelection) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_PeriphCLKInitTypeDef),
            "::",
            stringify!(PeriphClockSelection)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PvdClockSelection) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_PeriphCLKInitTypeDef),
            "::",
            stringify!(PvdClockSelection)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Comp1ClockSelection) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_PeriphCLKInitTypeDef),
            "::",
            stringify!(Comp1ClockSelection)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Comp2ClockSelection) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_PeriphCLKInitTypeDef),
            "::",
            stringify!(Comp2ClockSelection)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LptimClockSelection) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_PeriphCLKInitTypeDef),
            "::",
            stringify!(LptimClockSelection)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RTCClockSelection) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(RCC_PeriphCLKInitTypeDef),
            "::",
            stringify!(RTCClockSelection)
        )
    );
}
extern "C" {
    #[doc = " @addtogroup RCCEx_Exported_Functions_Group1\n @{"]
    pub fn HAL_RCCEx_PeriphCLKConfig(
        PeriphClkInit: *mut RCC_PeriphCLKInitTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_RCCEx_GetPeriphCLKConfig(PeriphClkInit: *mut RCC_PeriphCLKInitTypeDef);
}
extern "C" {
    pub fn HAL_RCCEx_GetPeriphCLKFreq(PeriphClk: u32) -> u32;
}
extern "C" {
    pub fn HAL_RCCEx_EnableLSCO(LSCOSource: u32);
}
extern "C" {
    pub fn HAL_RCCEx_DisableLSCO();
}
extern "C" {
    #[doc = " @addtogroup RCC_Exported_Functions_Group1\n @{"]
    pub fn HAL_RCC_DeInit() -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_RCC_OscConfig(RCC_OscInitStruct: *mut RCC_OscInitTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_RCC_ClockConfig(
        RCC_ClkInitStruct: *mut RCC_ClkInitTypeDef,
        FLatency: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    #[doc = " @addtogroup RCC_Exported_Functions_Group2\n @{"]
    pub fn HAL_RCC_MCOConfig(RCC_MCOx: u32, RCC_MCOSource: u32, RCC_MCODiv: u32);
}
extern "C" {
    pub fn HAL_RCC_EnableCSS();
}
extern "C" {
    pub fn HAL_RCC_EnableLSECSS();
}
extern "C" {
    pub fn HAL_RCC_DisableLSECSS();
}
extern "C" {
    pub fn HAL_RCC_LSECSSCallback();
}
extern "C" {
    pub fn HAL_RCC_GetSysClockFreq() -> u32;
}
extern "C" {
    pub fn HAL_RCC_GetHCLKFreq() -> u32;
}
extern "C" {
    pub fn HAL_RCC_GetPCLK1Freq() -> u32;
}
extern "C" {
    pub fn HAL_RCC_GetOscConfig(RCC_OscInitStruct: *mut RCC_OscInitTypeDef);
}
extern "C" {
    pub fn HAL_RCC_GetClockConfig(RCC_ClkInitStruct: *mut RCC_ClkInitTypeDef, pFLatency: *mut u32);
}
extern "C" {
    pub fn HAL_RCC_NMI_IRQHandler();
}
extern "C" {
    pub fn HAL_RCC_CSSCallback();
}
pub const EXTI_CallbackIDTypeDef_HAL_EXTI_COMMON_CB_ID: EXTI_CallbackIDTypeDef = 0;
#[doc = " @defgroup EXTI_Exported_Types EXTI Exported Types\n @{"]
pub type EXTI_CallbackIDTypeDef = ::core::ffi::c_uint;
#[doc = " @brief  EXTI Handle structure definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EXTI_HandleTypeDef {
    #[doc = "<  Exti line number"]
    pub Line: u32,
    #[doc = "<  Exti pending callback"]
    pub PendingCallback: ::core::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout_EXTI_HandleTypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<EXTI_HandleTypeDef> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<EXTI_HandleTypeDef>(),
        8usize,
        concat!("Size of: ", stringify!(EXTI_HandleTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<EXTI_HandleTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(EXTI_HandleTypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Line) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EXTI_HandleTypeDef),
            "::",
            stringify!(Line)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PendingCallback) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(EXTI_HandleTypeDef),
            "::",
            stringify!(PendingCallback)
        )
    );
}
#[doc = " @brief  EXTI Configuration structure definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EXTI_ConfigTypeDef {
    #[doc = "< The Exti line to be configured. This parameter\ncan be a value of @ref EXTI_Line"]
    pub Line: u32,
    #[doc = "< The Exit Mode to be configured for a core.\nThis parameter can be a combination of @ref EXTI_Mode"]
    pub Mode: u32,
    #[doc = "< The Exti Trigger to be configured. This parameter\ncan be a value of @ref EXTI_Trigger"]
    pub Trigger: u32,
    #[doc = "< The Exti GPIO multiplexer selection to be configured.\nThis parameter is only possible for line 0 to 15. It\ncan be a value of @ref EXTI_GPIOSel"]
    pub GPIOSel: u32,
}
#[test]
fn bindgen_test_layout_EXTI_ConfigTypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<EXTI_ConfigTypeDef> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<EXTI_ConfigTypeDef>(),
        16usize,
        concat!("Size of: ", stringify!(EXTI_ConfigTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<EXTI_ConfigTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(EXTI_ConfigTypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Line) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EXTI_ConfigTypeDef),
            "::",
            stringify!(Line)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Mode) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(EXTI_ConfigTypeDef),
            "::",
            stringify!(Mode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Trigger) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(EXTI_ConfigTypeDef),
            "::",
            stringify!(Trigger)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).GPIOSel) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(EXTI_ConfigTypeDef),
            "::",
            stringify!(GPIOSel)
        )
    );
}
extern "C" {
    #[doc = " @defgroup EXTI_Exported_Functions_Group1 Configuration functions\n @brief    Configuration functions\n @{"]
    pub fn HAL_EXTI_SetConfigLine(
        hexti: *mut EXTI_HandleTypeDef,
        pExtiConfig: *mut EXTI_ConfigTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_EXTI_GetConfigLine(
        hexti: *mut EXTI_HandleTypeDef,
        pExtiConfig: *mut EXTI_ConfigTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_EXTI_ClearConfigLine(hexti: *mut EXTI_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_EXTI_RegisterCallback(
        hexti: *mut EXTI_HandleTypeDef,
        CallbackID: EXTI_CallbackIDTypeDef,
        pPendingCbfn: ::core::option::Option<unsafe extern "C" fn()>,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_EXTI_GetHandle(hexti: *mut EXTI_HandleTypeDef, ExtiLine: u32) -> HAL_StatusTypeDef;
}
extern "C" {
    #[doc = " @defgroup EXTI_Exported_Functions_Group2 IO operation functions\n @brief    IO operation functions\n @{"]
    pub fn HAL_EXTI_IRQHandler(hexti: *mut EXTI_HandleTypeDef);
}
extern "C" {
    pub fn HAL_EXTI_GetPending(hexti: *mut EXTI_HandleTypeDef, Edge: u32) -> u32;
}
extern "C" {
    pub fn HAL_EXTI_ClearPending(hexti: *mut EXTI_HandleTypeDef);
}
extern "C" {
    pub fn HAL_EXTI_GenerateSWI(hexti: *mut EXTI_HandleTypeDef);
}
#[doc = " @defgroup GPIO_Exported_Types GPIO Exported Types\n @{\n/\n/**\n @brief   GPIO Init structure definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GPIO_InitTypeDef {
    #[doc = "< Specifies the GPIO pins to be configured.\nThis parameter can be any value of @ref GPIO_pins"]
    pub Pin: u32,
    #[doc = "< Specifies the operating mode for the selected pins.\nThis parameter can be a value of @ref GPIO_mode"]
    pub Mode: u32,
    #[doc = "< Specifies the Pull-Up or Pull-Down activation for the selected pins.\nThis parameter can be a value of @ref GPIO_pull"]
    pub Pull: u32,
    #[doc = "< Specifies the speed for the selected pins.\nThis parameter can be a value of @ref GPIO_speed"]
    pub Speed: u32,
    #[doc = "< Peripheral to be connected to the selected pins\nThis parameter can be a value of @ref GPIOEx_Alternate_function_selection"]
    pub Alternate: u32,
}
#[test]
fn bindgen_test_layout_GPIO_InitTypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<GPIO_InitTypeDef> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<GPIO_InitTypeDef>(),
        20usize,
        concat!("Size of: ", stringify!(GPIO_InitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<GPIO_InitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(GPIO_InitTypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Pin) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GPIO_InitTypeDef),
            "::",
            stringify!(Pin)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Mode) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GPIO_InitTypeDef),
            "::",
            stringify!(Mode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Pull) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GPIO_InitTypeDef),
            "::",
            stringify!(Pull)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Speed) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(GPIO_InitTypeDef),
            "::",
            stringify!(Speed)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Alternate) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GPIO_InitTypeDef),
            "::",
            stringify!(Alternate)
        )
    );
}
pub const GPIO_PinState_GPIO_PIN_RESET: GPIO_PinState = 0;
pub const GPIO_PinState_GPIO_PIN_SET: GPIO_PinState = 1;
#[doc = " @brief  GPIO Bit SET and Bit RESET enumeration"]
pub type GPIO_PinState = ::core::ffi::c_uint;
extern "C" {
    #[doc = " @defgroup GPIO_Exported_Functions_Group1 Initialization/de-initialization functions\n  @brief    Initialization and Configuration functions\n @{"]
    pub fn HAL_GPIO_Init(GPIOx: *mut GPIO_TypeDef, GPIO_Init: *mut GPIO_InitTypeDef);
}
extern "C" {
    pub fn HAL_GPIO_DeInit(GPIOx: *mut GPIO_TypeDef, GPIO_Pin: u32);
}
extern "C" {
    #[doc = " @defgroup GPIO_Exported_Functions_Group2 IO operation functions\n  @brief    IO operation functions\n @{"]
    pub fn HAL_GPIO_ReadPin(GPIOx: *mut GPIO_TypeDef, GPIO_Pin: u16) -> GPIO_PinState;
}
extern "C" {
    pub fn HAL_GPIO_WritePin(GPIOx: *mut GPIO_TypeDef, GPIO_Pin: u16, PinState: GPIO_PinState);
}
extern "C" {
    pub fn HAL_GPIO_TogglePin(GPIOx: *mut GPIO_TypeDef, GPIO_Pin: u16);
}
extern "C" {
    pub fn HAL_GPIO_LockPin(GPIOx: *mut GPIO_TypeDef, GPIO_Pin: u16) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_GPIO_EXTI_IRQHandler(GPIO_Pin: u16);
}
extern "C" {
    pub fn HAL_GPIO_EXTI_Callback(GPIO_Pin: u16);
}
extern "C" {
    #[doc = " @defgroup CORTEX_Exported_Functions_Group1 Initialization and Configuration functions\n  @brief    Initialization and Configuration functions\n @{"]
    pub fn HAL_NVIC_SetPriority(IRQn: IRQn_Type, PreemptPriority: u32, SubPriority: u32);
}
extern "C" {
    pub fn HAL_NVIC_EnableIRQ(IRQn: IRQn_Type);
}
extern "C" {
    pub fn HAL_NVIC_DisableIRQ(IRQn: IRQn_Type);
}
extern "C" {
    pub fn HAL_NVIC_SystemReset();
}
extern "C" {
    pub fn HAL_SYSTICK_Config(TicksNumb: u32) -> u32;
}
extern "C" {
    #[doc = " @defgroup CORTEX_Exported_Functions_Group2 Peripheral Control functions\n  @brief   Cortex control functions\n @{"]
    pub fn HAL_NVIC_GetPriority(IRQn: IRQn_Type) -> u32;
}
extern "C" {
    pub fn HAL_NVIC_GetPendingIRQ(IRQn: IRQn_Type) -> u32;
}
extern "C" {
    pub fn HAL_NVIC_SetPendingIRQ(IRQn: IRQn_Type);
}
extern "C" {
    pub fn HAL_NVIC_ClearPendingIRQ(IRQn: IRQn_Type);
}
extern "C" {
    pub fn HAL_SYSTICK_CLKSourceConfig(CLKSource: u32);
}
extern "C" {
    pub fn HAL_SYSTICK_IRQHandler();
}
extern "C" {
    pub fn HAL_SYSTICK_Callback();
}
#[doc = " @brief  DMA Configuration Structure definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DMA_InitTypeDef {
    #[doc = "< Specifies if the data will be transferred from memory to peripheral,\nfrom memory to memory or from peripheral to memory.\nThis parameter can be a value of @ref DMA_Data_transfer_direction"]
    pub Direction: u32,
    #[doc = "< Specifies whether the Peripheral address register should be incremented or not.\nThis parameter can be a value of @ref DMA_Peripheral_incremented_mode"]
    pub PeriphInc: u32,
    #[doc = "< Specifies whether the memory address register should be incremented or not.\nThis parameter can be a value of @ref DMA_Memory_incremented_mode"]
    pub MemInc: u32,
    #[doc = "< Specifies the Peripheral data width.\nThis parameter can be a value of @ref DMA_Peripheral_data_size"]
    pub PeriphDataAlignment: u32,
    #[doc = "< Specifies the Memory data width.\nThis parameter can be a value of @ref DMA_Memory_data_size"]
    pub MemDataAlignment: u32,
    #[doc = "< Specifies the operation mode of the DMAy Channelx.\nThis parameter can be a value of @ref DMA_mode\n@note The circular buffer mode cannot be used if the memory-to-memory\ndata transfer is configured on the selected Channel"]
    pub Mode: u32,
    #[doc = "< Specifies the software priority for the DMAy Channelx.\nThis parameter can be a value of @ref DMA_Priority_level"]
    pub Priority: u32,
}
#[test]
fn bindgen_test_layout_DMA_InitTypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<DMA_InitTypeDef> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<DMA_InitTypeDef>(),
        28usize,
        concat!("Size of: ", stringify!(DMA_InitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<DMA_InitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(DMA_InitTypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Direction) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMA_InitTypeDef),
            "::",
            stringify!(Direction)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PeriphInc) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DMA_InitTypeDef),
            "::",
            stringify!(PeriphInc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MemInc) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DMA_InitTypeDef),
            "::",
            stringify!(MemInc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PeriphDataAlignment) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(DMA_InitTypeDef),
            "::",
            stringify!(PeriphDataAlignment)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MemDataAlignment) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DMA_InitTypeDef),
            "::",
            stringify!(MemDataAlignment)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Mode) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(DMA_InitTypeDef),
            "::",
            stringify!(Mode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Priority) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(DMA_InitTypeDef),
            "::",
            stringify!(Priority)
        )
    );
}
#[doc = "< DMA not yet initialized or disabled"]
pub const HAL_DMA_StateTypeDef_HAL_DMA_STATE_RESET: HAL_DMA_StateTypeDef = 0;
#[doc = "< DMA initialized and ready for use"]
pub const HAL_DMA_StateTypeDef_HAL_DMA_STATE_READY: HAL_DMA_StateTypeDef = 1;
#[doc = "< DMA process is ongoing"]
pub const HAL_DMA_StateTypeDef_HAL_DMA_STATE_BUSY: HAL_DMA_StateTypeDef = 2;
#[doc = "< DMA timeout state"]
pub const HAL_DMA_StateTypeDef_HAL_DMA_STATE_TIMEOUT: HAL_DMA_StateTypeDef = 3;
#[doc = " @brief  HAL DMA State structures definition"]
pub type HAL_DMA_StateTypeDef = ::core::ffi::c_uint;
#[doc = "< Full transfer"]
pub const HAL_DMA_LevelCompleteTypeDef_HAL_DMA_FULL_TRANSFER: HAL_DMA_LevelCompleteTypeDef = 0;
#[doc = "< Half Transfer"]
pub const HAL_DMA_LevelCompleteTypeDef_HAL_DMA_HALF_TRANSFER: HAL_DMA_LevelCompleteTypeDef = 1;
#[doc = " @brief  HAL DMA Error Code structure definition"]
pub type HAL_DMA_LevelCompleteTypeDef = ::core::ffi::c_uint;
#[doc = "< Full transfer"]
pub const HAL_DMA_CallbackIDTypeDef_HAL_DMA_XFER_CPLT_CB_ID: HAL_DMA_CallbackIDTypeDef = 0;
#[doc = "< Half transfer"]
pub const HAL_DMA_CallbackIDTypeDef_HAL_DMA_XFER_HALFCPLT_CB_ID: HAL_DMA_CallbackIDTypeDef = 1;
#[doc = "< Error"]
pub const HAL_DMA_CallbackIDTypeDef_HAL_DMA_XFER_ERROR_CB_ID: HAL_DMA_CallbackIDTypeDef = 2;
#[doc = "< Abort"]
pub const HAL_DMA_CallbackIDTypeDef_HAL_DMA_XFER_ABORT_CB_ID: HAL_DMA_CallbackIDTypeDef = 3;
#[doc = "< All"]
pub const HAL_DMA_CallbackIDTypeDef_HAL_DMA_XFER_ALL_CB_ID: HAL_DMA_CallbackIDTypeDef = 4;
#[doc = " @brief  HAL DMA Callback ID structure definition"]
pub type HAL_DMA_CallbackIDTypeDef = ::core::ffi::c_uint;
#[doc = " @brief  DMA handle Structure definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __DMA_HandleTypeDef {
    #[doc = "< Register base address"]
    pub Instance: *mut DMA_Channel_TypeDef,
    #[doc = "< DMA communication parameters"]
    pub Init: DMA_InitTypeDef,
    #[doc = "< DMA locking object"]
    pub Lock: HAL_LockTypeDef,
    #[doc = "< DMA transfer state"]
    pub State: HAL_DMA_StateTypeDef,
    #[doc = "< Parent object state"]
    pub Parent: *mut ::core::ffi::c_void,
    #[doc = "< DMA transfer complete callback"]
    pub XferCpltCallback:
        ::core::option::Option<unsafe extern "C" fn(hdma: *mut __DMA_HandleTypeDef)>,
    #[doc = "< DMA Half transfer complete callback"]
    pub XferHalfCpltCallback:
        ::core::option::Option<unsafe extern "C" fn(hdma: *mut __DMA_HandleTypeDef)>,
    #[doc = "< DMA transfer error callback"]
    pub XferErrorCallback:
        ::core::option::Option<unsafe extern "C" fn(hdma: *mut __DMA_HandleTypeDef)>,
    #[doc = "< DMA transfer abort callback"]
    pub XferAbortCallback:
        ::core::option::Option<unsafe extern "C" fn(hdma: *mut __DMA_HandleTypeDef)>,
    #[doc = "< DMA Error code"]
    pub ErrorCode: u32,
    #[doc = "< DMA Channel Base Address"]
    pub DmaBaseAddress: *mut DMA_TypeDef,
    #[doc = "< DMA Channel Index"]
    pub ChannelIndex: u32,
}
#[test]
fn bindgen_test_layout___DMA_HandleTypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<__DMA_HandleTypeDef> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__DMA_HandleTypeDef>(),
        72usize,
        concat!("Size of: ", stringify!(__DMA_HandleTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<__DMA_HandleTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(__DMA_HandleTypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__DMA_HandleTypeDef),
            "::",
            stringify!(Instance)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Init) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__DMA_HandleTypeDef),
            "::",
            stringify!(Init)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Lock) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__DMA_HandleTypeDef),
            "::",
            stringify!(Lock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).State) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__DMA_HandleTypeDef),
            "::",
            stringify!(State)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Parent) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__DMA_HandleTypeDef),
            "::",
            stringify!(Parent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).XferCpltCallback) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(__DMA_HandleTypeDef),
            "::",
            stringify!(XferCpltCallback)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).XferHalfCpltCallback) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__DMA_HandleTypeDef),
            "::",
            stringify!(XferHalfCpltCallback)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).XferErrorCallback) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(__DMA_HandleTypeDef),
            "::",
            stringify!(XferErrorCallback)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).XferAbortCallback) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__DMA_HandleTypeDef),
            "::",
            stringify!(XferAbortCallback)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ErrorCode) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(__DMA_HandleTypeDef),
            "::",
            stringify!(ErrorCode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DmaBaseAddress) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__DMA_HandleTypeDef),
            "::",
            stringify!(DmaBaseAddress)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ChannelIndex) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(__DMA_HandleTypeDef),
            "::",
            stringify!(ChannelIndex)
        )
    );
}
#[doc = " @brief  DMA handle Structure definition"]
pub type DMA_HandleTypeDef = __DMA_HandleTypeDef;
extern "C" {
    #[doc = " @addtogroup DMA_Exported_Functions_Group1\n @{"]
    pub fn HAL_DMA_Init(hdma: *mut DMA_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_DMA_DeInit(hdma: *mut DMA_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    #[doc = " @addtogroup DMA_Exported_Functions_Group2\n @{"]
    pub fn HAL_DMA_Start(
        hdma: *mut DMA_HandleTypeDef,
        SrcAddress: u32,
        DstAddress: u32,
        DataLength: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_DMA_Start_IT(
        hdma: *mut DMA_HandleTypeDef,
        SrcAddress: u32,
        DstAddress: u32,
        DataLength: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_DMA_Abort(hdma: *mut DMA_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_DMA_Abort_IT(hdma: *mut DMA_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_DMA_PollForTransfer(
        hdma: *mut DMA_HandleTypeDef,
        CompleteLevel: u32,
        Timeout: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_DMA_IRQHandler(hdma: *mut DMA_HandleTypeDef);
}
extern "C" {
    pub fn HAL_DMA_RegisterCallback(
        hdma: *mut DMA_HandleTypeDef,
        CallbackID: HAL_DMA_CallbackIDTypeDef,
        pCallback: ::core::option::Option<unsafe extern "C" fn(_hdma: *mut DMA_HandleTypeDef)>,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_DMA_UnRegisterCallback(
        hdma: *mut DMA_HandleTypeDef,
        CallbackID: HAL_DMA_CallbackIDTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_DMA_ChannelMap(hdma: *mut DMA_HandleTypeDef, MapReqNum: u32);
}
extern "C" {
    #[doc = " @addtogroup DMA_Exported_Functions_Group3\n @{"]
    pub fn HAL_DMA_GetState(hdma: *mut DMA_HandleTypeDef) -> HAL_DMA_StateTypeDef;
}
extern "C" {
    pub fn HAL_DMA_GetError(hdma: *mut DMA_HandleTypeDef) -> u32;
}
#[doc = " @brief  Structure definition of ADC initialization and regular group\n @note   The setting of these parameters with function HAL_ADC_Init() is conditioned to ADC state.\n         ADC state can be either:\n          - For all parameters: ADC disabled (this is the only possible ADC state to modify parameter 'ClockPrescaler')\n          - For all parameters except 'ClockPrescaler' and 'resolution': ADC enabled without conversion on going on regular group.\n         If ADC is not in the appropriate state to modify some parameters, these parameters setting is bypassed\n         without error reporting (as it can be the expected behaviour in case of intended action to update another parameter (which fulfills the ADC state condition) on the fly)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADC_InitTypeDef {
    #[doc = "< Select ADC clock source (synchronous clock derived from APB clock or asynchronous clock derived from ADC dedicated HSI RC oscillator 14MHz) and clock prescaler.\nThis parameter can be a value of @ref ADC_ClockPrescaler\nNote: In case of usage of the ADC dedicated HSI RC oscillator, it must be preliminarily enabled at RCC top level.\nNote: This parameter can be modified only if the ADC is disabled"]
    pub ClockPrescaler: u32,
    #[doc = "< Configures the ADC resolution.\nThis parameter can be a value of @ref ADC_Resolution"]
    pub Resolution: u32,
    #[doc = "< Specifies whether the ADC data  alignment is left or right.\nThis parameter can be a value of @ref ADC_Data_align"]
    pub DataAlign: u32,
    #[doc = "< Configures the sequencer of regular group.\nThis parameter can be associated to parameter 'DiscontinuousConvMode' to have main sequence subdivided in successive parts.\nSequencer is automatically enabled if several channels are set (sequencer cannot be disabled, as it can be the case on other PY32 devices):\nIf only 1 channel is set: Conversion is performed in single mode.\nIf several channels are set:  Conversions are performed in sequence mode (ranks defined by each channel number: channel 0 fixed on rank 0, channel 1 fixed on rank1, ...).\nScan direction can be set to forward (from channel 0 to channel 12) or backward (from channel 18 to channel 0).\nThis parameter can be a value of @ref ADC_Scan_mode"]
    pub ScanConvMode: u32,
    #[doc = "< Specifies what EOC (End Of Conversion) flag is used for conversion by polling and interruption: end of conversion of each rank or complete sequence.\nThis parameter can be a value of @ref ADC_EOCSelection."]
    pub EOCSelection: u32,
    #[doc = "< Selects the dynamic low power Auto Delay: new conversion start only when the previous\nconversion (for regular group) has been treated by user software, using function HAL_ADC_GetValue().\nThis feature automatically adapts the ADC conversions trigs to the speed of the system that reads the data. Moreover, this avoids risk of overrun for low frequency applications.\nThis parameter can be set to ENABLE or DISABLE.\nNote: Do not use with interruption or DMA (HAL_ADC_Start_IT(), HAL_ADC_Start_DMA()) since they have to clear immediately the EOC flag to free the IRQ vector sequencer.\nDo use with polling: 1. Start conversion with HAL_ADC_Start(), 2. Later on, when conversion data is needed: use HAL_ADC_PollForConversion() to ensure that conversion is completed\nand use HAL_ADC_GetValue() to retrieve conversion result and trig another conversion."]
    pub LowPowerAutoWait: FunctionalState,
    #[doc = "< Specifies whether the conversion is performed in single mode (one conversion) or continuous mode for regular group,\nafter the selected trigger occurred (software start or external trigger).\nThis parameter can be set to ENABLE or DISABLE."]
    pub ContinuousConvMode: FunctionalState,
    #[doc = "< Specifies whether the conversions sequence of regular group is performed in Complete-sequence/Discontinuous-sequence (main sequence subdivided in successive parts).\nDiscontinuous mode is used only if sequencer is enabled (parameter 'ScanConvMode'). If sequencer is disabled, this parameter is discarded.\nDiscontinuous mode can be enabled only if continuous mode is disabled. If continuous mode is enabled, this parameter setting is discarded.\nThis parameter can be set to ENABLE or DISABLE\nNote: Number of discontinuous ranks increment is fixed to one-by-one."]
    pub DiscontinuousConvMode: FunctionalState,
    #[doc = "< Selects the external event used to trigger the conversion start of regular group.\nIf set to ADC_SOFTWARE_START, external triggers are disabled.\nThis parameter can be a value of @ref ADC_External_trigger_source_Regular"]
    pub ExternalTrigConv: u32,
    #[doc = "< Selects the external trigger edge of regular group.\nIf trigger is set to ADC_SOFTWARE_START, this parameter is discarded.\nThis parameter can be a value of @ref ADC_External_trigger_edge_Regular"]
    pub ExternalTrigConvEdge: u32,
    #[doc = "< Specifies whether the DMA requests are performed in one shot mode (DMA transfer stop when number of conversions is reached)\nor in Continuous mode (DMA transfer unlimited, whatever number of conversions).\nNote: In continuous mode, DMA must be configured in circular mode. Otherwise an overrun will be triggered when DMA buffer maximum pointer is reached.\nThis parameter can be set to ENABLE or DISABLE."]
    pub DMAContinuousRequests: FunctionalState,
    #[doc = "< Select the behaviour in case of overrun: data preserved or overwritten\nThis parameter has an effect on regular group only, including in DMA mode.\nThis parameter can be a value of @ref ADC_Overrun"]
    pub Overrun: u32,
    #[doc = "< Sampling time value to be set for the selected channel.\nUnit: ADC clock cycles\nConversion time is the addition of sampling time and processing time (12.5 ADC clock cycles at ADC resolution 12 bits, 10.5 cycles at 10 bits, 8.5 cycles at 8 bits, 6.5 cycles at 6 bits).\nNote: On PY32F0 devices, the sampling time setting is common to all channels. On some other PY32 devices, this parameter in channel wise and is located into ADC channel initialization structure.\nThis parameter can be a value of @ref ADC_sampling_times\nNote: In case of usage of internal measurement channels (VrefInt/TempSensor),\nsampling time constraints must be respected (sampling time can be adjusted in function of ADC clock frequency and sampling time setting)\nRefer to device datasheet for timings values, parameters TS_vrefint, TS_temp (values rough order: 5us to 17us)."]
    pub SamplingTimeCommon: u32,
}
#[test]
fn bindgen_test_layout_ADC_InitTypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<ADC_InitTypeDef> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ADC_InitTypeDef>(),
        52usize,
        concat!("Size of: ", stringify!(ADC_InitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_InitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(ADC_InitTypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ClockPrescaler) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_InitTypeDef),
            "::",
            stringify!(ClockPrescaler)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Resolution) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_InitTypeDef),
            "::",
            stringify!(Resolution)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DataAlign) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_InitTypeDef),
            "::",
            stringify!(DataAlign)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ScanConvMode) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_InitTypeDef),
            "::",
            stringify!(ScanConvMode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EOCSelection) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_InitTypeDef),
            "::",
            stringify!(EOCSelection)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LowPowerAutoWait) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_InitTypeDef),
            "::",
            stringify!(LowPowerAutoWait)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ContinuousConvMode) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_InitTypeDef),
            "::",
            stringify!(ContinuousConvMode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DiscontinuousConvMode) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_InitTypeDef),
            "::",
            stringify!(DiscontinuousConvMode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ExternalTrigConv) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_InitTypeDef),
            "::",
            stringify!(ExternalTrigConv)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ExternalTrigConvEdge) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_InitTypeDef),
            "::",
            stringify!(ExternalTrigConvEdge)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DMAContinuousRequests) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_InitTypeDef),
            "::",
            stringify!(DMAContinuousRequests)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Overrun) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_InitTypeDef),
            "::",
            stringify!(Overrun)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SamplingTimeCommon) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_InitTypeDef),
            "::",
            stringify!(SamplingTimeCommon)
        )
    );
}
#[doc = " @brief  Structure definition of ADC channel for regular group\n @note   The setting of these parameters with function HAL_ADC_ConfigChannel() is conditioned to ADC state.\n         ADC state can be either:\n          - For all parameters: ADC disabled or enabled without conversion on going on regular group.\n         If ADC is not in the appropriate state to modify some parameters, these parameters setting is bypassed\n         without error reporting (as it can be the expected behaviour in case of intended action to update another parameter (which fulfills the ADC state condition) on the fly)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADC_ChannelConfTypeDef {
    #[doc = "< Specifies the channel to configure into ADC regular group.\nThis parameter can be a value of @ref ADC_channels\nNote: Depending on devices, some channels may not be available on package pins. Refer to device datasheet for channels availability."]
    pub Channel: u32,
    #[doc = "< Add or remove the channel from ADC regular group sequencer.\nOn PY32F0 devices,  number of ranks in the sequence is defined by number of channels enabled, rank of each channel is defined by channel number (channel 0 fixed on rank 0, channel 1 fixed on rank1, ...)..\nDespite the channel rank is fixed, this parameter allow an additional possibility: to remove the selected rank (selected channel) from sequencer.\nThis parameter can be a value of @ref ADC_rank"]
    pub Rank: u32,
    #[doc = "< Sampling time value to be set for the selected channel.\nUnit: ADC clock cycles\nConversion time is the addition of sampling time and processing time (12.5 ADC clock cycles at ADC resolution 12 bits, 10.5 cycles at 10 bits, 8.5 cycles at 8 bits, 6.5 cycles at 6 bits).\nThis parameter can be a value of @ref ADC_sampling_times\nCaution: this setting impacts the entire regular group. Therefore, call of HAL_ADC_ConfigChannel() to configure a channel can impact the configuration of other channels previously set.\nCaution: Obsolete parameter. Use parameter \"SamplingTimeCommon\" in ADC initialization structure.\nIf parameter \"SamplingTimeCommon\" is set to a valid sampling time, parameter \"SamplingTime\" is discarded.\nNote: In case of usage of internal measurement channels (VrefInt/TempSensor),\nsampling time constraints must be respected (sampling time can be adjusted in function of ADC clock frequency and sampling time setting)\nRefer to device datasheet for timings values, parameters TS_vrefint, TS_temp (values rough order: 5us to 17us)."]
    pub SamplingTime: u32,
}
#[test]
fn bindgen_test_layout_ADC_ChannelConfTypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<ADC_ChannelConfTypeDef> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ADC_ChannelConfTypeDef>(),
        12usize,
        concat!("Size of: ", stringify!(ADC_ChannelConfTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_ChannelConfTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(ADC_ChannelConfTypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Channel) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_ChannelConfTypeDef),
            "::",
            stringify!(Channel)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Rank) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_ChannelConfTypeDef),
            "::",
            stringify!(Rank)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SamplingTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_ChannelConfTypeDef),
            "::",
            stringify!(SamplingTime)
        )
    );
}
#[doc = " @brief  Structure definition of ADC analog watchdog\n @note   The setting of these parameters with function HAL_ADC_AnalogWDGConfig() is conditioned to ADC state.\n         ADC state can be either: ADC disabled or ADC enabled without conversion on going on regular group."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADC_AnalogWDGConfTypeDef {
    #[doc = "< Configures the ADC analog watchdog mode: single/all/none channels.\nThis parameter can be a value of @ref ADC_analog_watchdog_mode."]
    pub WatchdogMode: u32,
    #[doc = "< Selects which ADC channel to monitor by analog watchdog.\nThis parameter has an effect only if parameter 'WatchdogMode' is configured on single channel. Only 1 channel can be monitored.\nThis parameter can be a value of @ref ADC_channels."]
    pub Channel: u32,
    #[doc = "< Specifies whether the analog watchdog is configured in interrupt or polling mode.\nThis parameter can be set to ENABLE or DISABLE"]
    pub ITMode: FunctionalState,
    #[doc = "< Configures the ADC analog watchdog High threshold value.\nDepending of ADC resolution selected (12, 10, 8 or 6 bits), this parameter must be a number between Min_Data = 0x000 and Max_Data = 0xFFF, 0x3FF, 0xFF or 0x3F respectively."]
    pub HighThreshold: u32,
    #[doc = "< Configures the ADC analog watchdog High threshold value.\nDepending of ADC resolution selected (12, 10, 8 or 6 bits), this parameter must be a number between Min_Data = 0x000 and Max_Data = 0xFFF, 0x3FF, 0xFF or 0x3F respectively."]
    pub LowThreshold: u32,
}
#[test]
fn bindgen_test_layout_ADC_AnalogWDGConfTypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<ADC_AnalogWDGConfTypeDef> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ADC_AnalogWDGConfTypeDef>(),
        20usize,
        concat!("Size of: ", stringify!(ADC_AnalogWDGConfTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_AnalogWDGConfTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(ADC_AnalogWDGConfTypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).WatchdogMode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_AnalogWDGConfTypeDef),
            "::",
            stringify!(WatchdogMode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Channel) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_AnalogWDGConfTypeDef),
            "::",
            stringify!(Channel)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ITMode) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_AnalogWDGConfTypeDef),
            "::",
            stringify!(ITMode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).HighThreshold) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_AnalogWDGConfTypeDef),
            "::",
            stringify!(HighThreshold)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LowThreshold) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_AnalogWDGConfTypeDef),
            "::",
            stringify!(LowThreshold)
        )
    );
}
#[doc = " @brief  ADC handle Structure definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __ADC_HandleTypeDef {
    #[doc = "< Register base address"]
    pub Instance: *mut ADC_TypeDef,
    #[doc = "< ADC required parameters"]
    pub Init: ADC_InitTypeDef,
    #[doc = "< Pointer DMA Handler"]
    pub DMA_Handle: *mut DMA_HandleTypeDef,
    #[doc = "< ADC locking object"]
    pub Lock: HAL_LockTypeDef,
    #[doc = "< ADC communication state (bitmap of ADC states)"]
    pub State: u32,
    #[doc = "< ADC Error code"]
    pub ErrorCode: u32,
}
#[test]
fn bindgen_test_layout___ADC_HandleTypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<__ADC_HandleTypeDef> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__ADC_HandleTypeDef>(),
        72usize,
        concat!("Size of: ", stringify!(__ADC_HandleTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<__ADC_HandleTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(__ADC_HandleTypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__ADC_HandleTypeDef),
            "::",
            stringify!(Instance)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Init) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__ADC_HandleTypeDef),
            "::",
            stringify!(Init)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DMA_Handle) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__ADC_HandleTypeDef),
            "::",
            stringify!(DMA_Handle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Lock) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(__ADC_HandleTypeDef),
            "::",
            stringify!(Lock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).State) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__ADC_HandleTypeDef),
            "::",
            stringify!(State)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ErrorCode) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(__ADC_HandleTypeDef),
            "::",
            stringify!(ErrorCode)
        )
    );
}
#[doc = " @brief  ADC handle Structure definition"]
pub type ADC_HandleTypeDef = __ADC_HandleTypeDef;
extern "C" {
    #[doc = " @addtogroup ADC_Exported_Functions_Group1\n @{"]
    pub fn HAL_ADC_Init(hadc: *mut ADC_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_ADC_DeInit(hadc: *mut ADC_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_ADC_MspInit(hadc: *mut ADC_HandleTypeDef);
}
extern "C" {
    pub fn HAL_ADC_MspDeInit(hadc: *mut ADC_HandleTypeDef);
}
extern "C" {
    #[doc = " @addtogroup ADC_Exported_Functions_Group2\n @{"]
    pub fn HAL_ADC_Start(hadc: *mut ADC_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_ADC_Stop(hadc: *mut ADC_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_ADC_PollForConversion(
        hadc: *mut ADC_HandleTypeDef,
        Timeout: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_ADC_PollForEvent(
        hadc: *mut ADC_HandleTypeDef,
        EventType: u32,
        Timeout: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_ADC_Start_IT(hadc: *mut ADC_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_ADC_Stop_IT(hadc: *mut ADC_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_ADC_Start_DMA(
        hadc: *mut ADC_HandleTypeDef,
        pData: *mut u32,
        Length: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_ADC_Stop_DMA(hadc: *mut ADC_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_ADC_GetValue(hadc: *mut ADC_HandleTypeDef) -> u32;
}
extern "C" {
    pub fn HAL_ADC_IRQHandler(hadc: *mut ADC_HandleTypeDef);
}
extern "C" {
    pub fn HAL_ADC_ConvCpltCallback(hadc: *mut ADC_HandleTypeDef);
}
extern "C" {
    pub fn HAL_ADC_ConvHalfCpltCallback(hadc: *mut ADC_HandleTypeDef);
}
extern "C" {
    pub fn HAL_ADC_LevelOutOfWindowCallback(hadc: *mut ADC_HandleTypeDef);
}
extern "C" {
    pub fn HAL_ADC_ErrorCallback(hadc: *mut ADC_HandleTypeDef);
}
extern "C" {
    pub fn HAL_ADC_SetCalibration(
        hadc: *mut ADC_HandleTypeDef,
        CalibSamplingTime: u32,
        CalibSelection: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_ADC_Calibration_Start(hadc: *mut ADC_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_ADC_GetCalibStatus(hadc: *mut ADC_HandleTypeDef) -> u32;
}
extern "C" {
    #[doc = " @addtogroup ADC_Exported_Functions_Group3\n @{"]
    pub fn HAL_ADC_ConfigChannel(
        hadc: *mut ADC_HandleTypeDef,
        sConfig: *mut ADC_ChannelConfTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_ADC_AnalogWDGConfig(
        hadc: *mut ADC_HandleTypeDef,
        AnalogWDGConfig: *mut ADC_AnalogWDGConfTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    #[doc = " @addtogroup ADC_Exported_Functions_Group4\n @{"]
    pub fn HAL_ADC_GetState(hadc: *mut ADC_HandleTypeDef) -> u32;
}
extern "C" {
    pub fn HAL_ADC_GetError(hadc: *mut ADC_HandleTypeDef) -> u32;
}
#[doc = "< CRC not yet initialized or disabled"]
pub const HAL_CRC_StateTypeDef_HAL_CRC_STATE_RESET: HAL_CRC_StateTypeDef = 0;
#[doc = "< CRC initialized and ready for use"]
pub const HAL_CRC_StateTypeDef_HAL_CRC_STATE_READY: HAL_CRC_StateTypeDef = 1;
#[doc = "< CRC internal process is ongoing"]
pub const HAL_CRC_StateTypeDef_HAL_CRC_STATE_BUSY: HAL_CRC_StateTypeDef = 2;
#[doc = "< CRC timeout state"]
pub const HAL_CRC_StateTypeDef_HAL_CRC_STATE_TIMEOUT: HAL_CRC_StateTypeDef = 3;
#[doc = "< CRC error state"]
pub const HAL_CRC_StateTypeDef_HAL_CRC_STATE_ERROR: HAL_CRC_StateTypeDef = 4;
#[doc = " @brief  CRC HAL State Structure definition"]
pub type HAL_CRC_StateTypeDef = ::core::ffi::c_uint;
#[doc = " @brief  CRC Handle Structure definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CRC_HandleTypeDef {
    #[doc = "< Register base address"]
    pub Instance: *mut CRC_TypeDef,
    #[doc = "< CRC Locking object"]
    pub Lock: HAL_LockTypeDef,
    #[doc = "< CRC communication state"]
    pub State: HAL_CRC_StateTypeDef,
}
#[test]
fn bindgen_test_layout_CRC_HandleTypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<CRC_HandleTypeDef> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CRC_HandleTypeDef>(),
        12usize,
        concat!("Size of: ", stringify!(CRC_HandleTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<CRC_HandleTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(CRC_HandleTypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CRC_HandleTypeDef),
            "::",
            stringify!(Instance)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Lock) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CRC_HandleTypeDef),
            "::",
            stringify!(Lock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).State) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CRC_HandleTypeDef),
            "::",
            stringify!(State)
        )
    );
}
extern "C" {
    #[doc = " @defgroup CRC_Exported_Functions_Group1 Initialization and de-initialization functions\n @{"]
    pub fn HAL_CRC_Init(hcrc: *mut CRC_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_CRC_DeInit(hcrc: *mut CRC_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_CRC_MspInit(hcrc: *mut CRC_HandleTypeDef);
}
extern "C" {
    pub fn HAL_CRC_MspDeInit(hcrc: *mut CRC_HandleTypeDef);
}
extern "C" {
    #[doc = " @defgroup CRC_Exported_Functions_Group2 Peripheral Control functions\n @{"]
    pub fn HAL_CRC_Accumulate(
        hcrc: *mut CRC_HandleTypeDef,
        pBuffer: *mut u32,
        BufferLength: u32,
    ) -> u32;
}
extern "C" {
    pub fn HAL_CRC_Calculate(
        hcrc: *mut CRC_HandleTypeDef,
        pBuffer: *mut u32,
        BufferLength: u32,
    ) -> u32;
}
extern "C" {
    #[doc = " @defgroup CRC_Exported_Functions_Group3 Peripheral State functions\n @{"]
    pub fn HAL_CRC_GetState(hcrc: *mut CRC_HandleTypeDef) -> HAL_CRC_StateTypeDef;
}
#[doc = " @brief  FLASH Erase structure definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLASH_EraseInitTypeDef {
    #[doc = "< Mass erase or page erase.\nThis parameter can be a value of @ref FLASH_Type_Erase"]
    pub TypeErase: u32,
    #[doc = "< PageAdress: Initial FLASH page address to erase when mass erase and sector erase is disabled\nThis parameter must be a number between Min_Data = FLASH_BASE and Max_Data = FLASH_END"]
    pub PageAddress: u32,
    #[doc = "< Number of pages to be erased.\nThis parameter must be a value between 1 and (FLASH_PAGE_NB - value of initial page)"]
    pub NbPages: u32,
    #[doc = "< PageAdress: Initial FLASH page address to erase when mass erase and page erase is disabled\nThis parameter must be a number between Min_Data = FLASH_BASE and Max_Data = FLASH_BANK1_END"]
    pub SectorAddress: u32,
    #[doc = "< Number of sectors to be erased.\nThis parameter must be a value between 1 and (FLASH_SECTOR_NB - value of initial sector)"]
    pub NbSectors: u32,
}
#[test]
fn bindgen_test_layout_FLASH_EraseInitTypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<FLASH_EraseInitTypeDef> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<FLASH_EraseInitTypeDef>(),
        20usize,
        concat!("Size of: ", stringify!(FLASH_EraseInitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<FLASH_EraseInitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(FLASH_EraseInitTypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TypeErase) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FLASH_EraseInitTypeDef),
            "::",
            stringify!(TypeErase)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PageAddress) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FLASH_EraseInitTypeDef),
            "::",
            stringify!(PageAddress)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NbPages) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FLASH_EraseInitTypeDef),
            "::",
            stringify!(NbPages)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SectorAddress) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(FLASH_EraseInitTypeDef),
            "::",
            stringify!(SectorAddress)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NbSectors) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FLASH_EraseInitTypeDef),
            "::",
            stringify!(NbSectors)
        )
    );
}
#[doc = " @brief  FLASH Option Bytes PROGRAM structure definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLASH_OBProgramInitTypeDef {
    #[doc = "< OptionType: Option byte to be configured.\nThis parameter can be a value of @ref FLASH_Option_Type"]
    pub OptionType: u32,
    #[doc = "< WRPSector: This bitfield specifies the sector (s) which are write protected.\nThis parameter can be a combination of @ref FLASH_Option_Bytes_Write_Protection"]
    pub WRPSector: u32,
    #[doc = "< SDK Start address (used for FLASH_SDKR). It represents first address of start block\nto protect. Make sure this parameter is multiple of SDK granularity: 2048 Bytes."]
    pub SDKStartAddr: u32,
    #[doc = "< SDK End address (used for FLASH_SDKR). It represents first address of end block\nto protect. Make sure this parameter is multiple of SDK granularity: 2048 Bytes."]
    pub SDKEndAddr: u32,
    #[doc = "< RDPLevel: Set the read protection level.\nThis parameter can be a value of @ref FLASH_OB_Read_Protection"]
    pub RDPLevel: u32,
    #[doc = "< User option byte(s) to be configured (used for OPTIONBYTE_USER).\nThis parameter can be a combination of @ref FLASH_OB_USER_Type"]
    pub USERType: u32,
    #[doc = "< Value of the user option byte (used for OPTIONBYTE_USER).\nThis parameter can be a combination of\n@ref FLASH_OB_USER_BOR_ENABLE,\n@ref FLASH_OB_USER_BOR_LEVEL,\n@ref FLASH_OB_USER_RESET_CONFIG,\n@ref FLASH_OB_USER_IWDG_SW,\n@ref FLASH_OB_USER_WWDG_SW,\n@ref FLASH_OB_USER_nBOOT1"]
    pub USERConfig: u32,
}
#[test]
fn bindgen_test_layout_FLASH_OBProgramInitTypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<FLASH_OBProgramInitTypeDef> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<FLASH_OBProgramInitTypeDef>(),
        28usize,
        concat!("Size of: ", stringify!(FLASH_OBProgramInitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<FLASH_OBProgramInitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(FLASH_OBProgramInitTypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OptionType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FLASH_OBProgramInitTypeDef),
            "::",
            stringify!(OptionType)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).WRPSector) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FLASH_OBProgramInitTypeDef),
            "::",
            stringify!(WRPSector)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SDKStartAddr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FLASH_OBProgramInitTypeDef),
            "::",
            stringify!(SDKStartAddr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SDKEndAddr) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(FLASH_OBProgramInitTypeDef),
            "::",
            stringify!(SDKEndAddr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RDPLevel) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FLASH_OBProgramInitTypeDef),
            "::",
            stringify!(RDPLevel)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).USERType) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(FLASH_OBProgramInitTypeDef),
            "::",
            stringify!(USERType)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).USERConfig) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FLASH_OBProgramInitTypeDef),
            "::",
            stringify!(USERConfig)
        )
    );
}
#[doc = " @brief  FLASH handle Structure definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLASH_ProcessTypeDef {
    pub Lock: HAL_LockTypeDef,
    pub ErrorCode: u32,
    pub ProcedureOnGoing: u32,
    pub Address: u32,
    pub PageOrSector: u32,
    pub NbPagesSectorsToErase: u32,
}
#[test]
fn bindgen_test_layout_FLASH_ProcessTypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<FLASH_ProcessTypeDef> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<FLASH_ProcessTypeDef>(),
        24usize,
        concat!("Size of: ", stringify!(FLASH_ProcessTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<FLASH_ProcessTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(FLASH_ProcessTypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Lock) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FLASH_ProcessTypeDef),
            "::",
            stringify!(Lock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ErrorCode) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FLASH_ProcessTypeDef),
            "::",
            stringify!(ErrorCode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ProcedureOnGoing) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FLASH_ProcessTypeDef),
            "::",
            stringify!(ProcedureOnGoing)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Address) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(FLASH_ProcessTypeDef),
            "::",
            stringify!(Address)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PageOrSector) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FLASH_ProcessTypeDef),
            "::",
            stringify!(PageOrSector)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NbPagesSectorsToErase) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(FLASH_ProcessTypeDef),
            "::",
            stringify!(NbPagesSectorsToErase)
        )
    );
}
extern "C" {
    #[doc = " @defgroup FLASH_Exported_Variables FLASH Exported Variables\n @{"]
    pub static mut pFlash: FLASH_ProcessTypeDef;
}
extern "C" {
    #[doc = " @addtogroup FLASH_Exported_Functions_Group1\n @{"]
    pub fn HAL_FLASH_Program(
        TypeProgram: u32,
        Address: u32,
        DataAddr: *mut u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_FLASH_Program_IT(
        TypeProgram: u32,
        Address: u32,
        DataAddr: *mut u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_FLASH_PageProgram(Address: u32, DataAddr: *mut u32) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_FLASH_PageProgram_IT(Address: u32, DataAddr: *mut u32) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_FLASH_IRQHandler();
}
extern "C" {
    pub fn HAL_FLASH_EndOfOperationCallback(ReturnValue: u32);
}
extern "C" {
    pub fn HAL_FLASH_OperationErrorCallback(ReturnValue: u32);
}
extern "C" {
    pub fn HAL_FLASH_Erase(
        pEraseInit: *mut FLASH_EraseInitTypeDef,
        PageError: *mut u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_FLASH_Erase_IT(pEraseInit: *mut FLASH_EraseInitTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    #[doc = " @addtogroup FLASH_Exported_Functions_Group2\n @{"]
    pub fn HAL_FLASH_Unlock() -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_FLASH_Lock() -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_FLASH_OB_Unlock() -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_FLASH_OB_Lock() -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_FLASH_OB_Launch() -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_FLASH_OBProgram(pOBInit: *mut FLASH_OBProgramInitTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_FLASH_OBGetConfig(pOBInit: *mut FLASH_OBProgramInitTypeDef);
}
extern "C" {
    pub fn HAL_FLASH_OB_RDP_LevelConfig(ReadProtectLevel: u8) -> HAL_StatusTypeDef;
}
extern "C" {
    #[doc = " @addtogroup FLASH_Exported_Functions_Group3\n @{"]
    pub fn HAL_FLASH_GetError() -> u32;
}
extern "C" {
    #[doc = " @defgroup FLASH_Private_types FLASH Private Types\n @{"]
    pub fn FLASH_WaitForLastOperation(Timeout: u32) -> HAL_StatusTypeDef;
}
#[doc = " @defgroup I2C_Configuration_Structure_definition I2C Configuration Structure definition\n @brief  I2C Configuration Structure definition\n @{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct I2C_InitTypeDef {
    #[doc = "< Specifies the clock frequency.\nThis parameter must be set to a value lower than 400kHz"]
    pub ClockSpeed: u32,
    #[doc = "< Specifies the I2C fast mode duty cycle.\nThis parameter can be a value of @ref I2C_duty_cycle_in_fast_mode"]
    pub DutyCycle: u32,
    #[doc = "< Specifies the first device own address.\nThis parameter can be a 7-bit or 10-bit address."]
    pub OwnAddress1: u32,
    #[doc = "< Specifies if general call mode is selected.\nThis parameter can be a value of @ref I2C_general_call_addressing_mode"]
    pub GeneralCallMode: u32,
    #[doc = "< Specifies if nostretch mode is selected.\nThis parameter can be a value of @ref I2C_nostretch_mode"]
    pub NoStretchMode: u32,
}
#[test]
fn bindgen_test_layout_I2C_InitTypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<I2C_InitTypeDef> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<I2C_InitTypeDef>(),
        20usize,
        concat!("Size of: ", stringify!(I2C_InitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<I2C_InitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(I2C_InitTypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ClockSpeed) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(I2C_InitTypeDef),
            "::",
            stringify!(ClockSpeed)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DutyCycle) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(I2C_InitTypeDef),
            "::",
            stringify!(DutyCycle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OwnAddress1) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(I2C_InitTypeDef),
            "::",
            stringify!(OwnAddress1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).GeneralCallMode) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(I2C_InitTypeDef),
            "::",
            stringify!(GeneralCallMode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NoStretchMode) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(I2C_InitTypeDef),
            "::",
            stringify!(NoStretchMode)
        )
    );
}
#[doc = "< Peripheral is not yet Initialized"]
pub const HAL_I2C_StateTypeDef_HAL_I2C_STATE_RESET: HAL_I2C_StateTypeDef = 0;
#[doc = "< Peripheral Initialized and ready for use"]
pub const HAL_I2C_StateTypeDef_HAL_I2C_STATE_READY: HAL_I2C_StateTypeDef = 32;
#[doc = "< An internal process is ongoing"]
pub const HAL_I2C_StateTypeDef_HAL_I2C_STATE_BUSY: HAL_I2C_StateTypeDef = 36;
#[doc = "< Data Transmission process is ongoing"]
pub const HAL_I2C_StateTypeDef_HAL_I2C_STATE_BUSY_TX: HAL_I2C_StateTypeDef = 33;
#[doc = "< Data Reception process is ongoing"]
pub const HAL_I2C_StateTypeDef_HAL_I2C_STATE_BUSY_RX: HAL_I2C_StateTypeDef = 34;
#[doc = "< Address Listen Mode is ongoing"]
pub const HAL_I2C_StateTypeDef_HAL_I2C_STATE_LISTEN: HAL_I2C_StateTypeDef = 40;
#[doc = "< Address Listen Mode and Data Transmission\nprocess is ongoing"]
pub const HAL_I2C_StateTypeDef_HAL_I2C_STATE_BUSY_TX_LISTEN: HAL_I2C_StateTypeDef = 41;
#[doc = "< Address Listen Mode and Data Reception\nprocess is ongoing"]
pub const HAL_I2C_StateTypeDef_HAL_I2C_STATE_BUSY_RX_LISTEN: HAL_I2C_StateTypeDef = 42;
#[doc = "< Abort user request ongoing"]
pub const HAL_I2C_StateTypeDef_HAL_I2C_STATE_ABORT: HAL_I2C_StateTypeDef = 96;
#[doc = "< Timeout state"]
pub const HAL_I2C_StateTypeDef_HAL_I2C_STATE_TIMEOUT: HAL_I2C_StateTypeDef = 160;
#[doc = "< Error"]
pub const HAL_I2C_StateTypeDef_HAL_I2C_STATE_ERROR: HAL_I2C_StateTypeDef = 224;
#[doc = " @defgroup HAL_state_structure_definition HAL state structure definition\n @brief  HAL State structure definition\n @note  HAL I2C State value coding follow below described bitmap :\n          b7-b6  Error information\n             00 : No Error\n             01 : Abort (Abort user request on going)\n             10 : Timeout\n             11 : Error\n          b5     Peripheral initilisation status\n             0  : Reset (Peripheral not initialized)\n             1  : Init done (Peripheral initialized and ready to use. HAL I2C Init function called)\n          b4     (not used)\n             x  : Should be set to 0\n          b3\n             0  : Ready or Busy (No Listen mode ongoing)\n             1  : Listen (Peripheral in Address Listen Mode)\n          b2     Intrinsic process state\n             0  : Ready\n             1  : Busy (Peripheral busy with some configuration or internal operations)\n          b1     Rx state\n             0  : Ready (no Rx operation ongoing)\n             1  : Busy (Rx operation ongoing)\n          b0     Tx state\n             0  : Ready (no Tx operation ongoing)\n             1  : Busy (Tx operation ongoing)\n @{"]
pub type HAL_I2C_StateTypeDef = ::core::ffi::c_uint;
#[doc = "< No I2C communication on going"]
pub const HAL_I2C_ModeTypeDef_HAL_I2C_MODE_NONE: HAL_I2C_ModeTypeDef = 0;
#[doc = "< I2C communication is in Master Mode"]
pub const HAL_I2C_ModeTypeDef_HAL_I2C_MODE_MASTER: HAL_I2C_ModeTypeDef = 16;
#[doc = "< I2C communication is in Slave Mode"]
pub const HAL_I2C_ModeTypeDef_HAL_I2C_MODE_SLAVE: HAL_I2C_ModeTypeDef = 32;
#[doc = "< I2C communication is in Memory Mode"]
pub const HAL_I2C_ModeTypeDef_HAL_I2C_MODE_MEM: HAL_I2C_ModeTypeDef = 64;
#[doc = " @defgroup HAL_mode_structure_definition HAL mode structure definition\n @brief  HAL Mode structure definition\n @note  HAL I2C Mode value coding follow below described bitmap :\\n\n          b7     (not used)\\n\n             x  : Should be set to 0\\n\n          b6\\n\n             0  : None\\n\n             1  : Memory (HAL I2C communication is in Memory Mode)\\n\n          b5\\n\n             0  : None\\n\n             1  : Slave (HAL I2C communication is in Slave Mode)\\n\n          b4\\n\n             0  : None\\n\n             1  : Master (HAL I2C communication is in Master Mode)\\n\n          b3-b2-b1-b0  (not used)\\n\n             xxxx : Should be set to 0000\n @{"]
pub type HAL_I2C_ModeTypeDef = ::core::ffi::c_uint;
#[doc = " @defgroup I2C_handle_Structure_definition I2C handle Structure definition\n @brief  I2C handle Structure definition\n @{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __I2C_HandleTypeDef {
    #[doc = "< I2C registers base address"]
    pub Instance: *mut I2C_TypeDef,
    #[doc = "< I2C communication parameters"]
    pub Init: I2C_InitTypeDef,
    #[doc = "< Pointer to I2C transfer buffer"]
    pub pBuffPtr: *mut u8,
    #[doc = "< I2C transfer size"]
    pub XferSize: u16,
    #[doc = "< I2C transfer counter"]
    pub XferCount: u16,
    #[doc = "< I2C transfer options"]
    pub XferOptions: u32,
    #[doc = "< I2C communication Previous state and mode\ncontext for internal usage"]
    pub PreviousState: u32,
    #[doc = "< I2C Tx DMA handle parameters"]
    pub hdmatx: *mut DMA_HandleTypeDef,
    #[doc = "< I2C Rx DMA handle parameters"]
    pub hdmarx: *mut DMA_HandleTypeDef,
    #[doc = "< I2C locking object"]
    pub Lock: HAL_LockTypeDef,
    #[doc = "< I2C communication state"]
    pub State: HAL_I2C_StateTypeDef,
    #[doc = "< I2C communication mode"]
    pub Mode: HAL_I2C_ModeTypeDef,
    #[doc = "< I2C Error code"]
    pub ErrorCode: u32,
    #[doc = "< I2C Target device address"]
    pub Devaddress: u32,
    #[doc = "< I2C Target memory address"]
    pub Memaddress: u32,
    #[doc = "< I2C Target memory address  size"]
    pub MemaddSize: u32,
    #[doc = "< I2C Event counter"]
    pub EventCount: u32,
}
#[test]
fn bindgen_test_layout___I2C_HandleTypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<__I2C_HandleTypeDef> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__I2C_HandleTypeDef>(),
        80usize,
        concat!("Size of: ", stringify!(__I2C_HandleTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<__I2C_HandleTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(__I2C_HandleTypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__I2C_HandleTypeDef),
            "::",
            stringify!(Instance)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Init) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__I2C_HandleTypeDef),
            "::",
            stringify!(Init)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pBuffPtr) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__I2C_HandleTypeDef),
            "::",
            stringify!(pBuffPtr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).XferSize) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__I2C_HandleTypeDef),
            "::",
            stringify!(XferSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).XferCount) as usize - ptr as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(__I2C_HandleTypeDef),
            "::",
            stringify!(XferCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).XferOptions) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__I2C_HandleTypeDef),
            "::",
            stringify!(XferOptions)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PreviousState) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__I2C_HandleTypeDef),
            "::",
            stringify!(PreviousState)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hdmatx) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__I2C_HandleTypeDef),
            "::",
            stringify!(hdmatx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hdmarx) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(__I2C_HandleTypeDef),
            "::",
            stringify!(hdmarx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Lock) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__I2C_HandleTypeDef),
            "::",
            stringify!(Lock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).State) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(__I2C_HandleTypeDef),
            "::",
            stringify!(State)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Mode) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__I2C_HandleTypeDef),
            "::",
            stringify!(Mode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ErrorCode) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(__I2C_HandleTypeDef),
            "::",
            stringify!(ErrorCode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Devaddress) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__I2C_HandleTypeDef),
            "::",
            stringify!(Devaddress)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Memaddress) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(__I2C_HandleTypeDef),
            "::",
            stringify!(Memaddress)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MemaddSize) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__I2C_HandleTypeDef),
            "::",
            stringify!(MemaddSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EventCount) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(__I2C_HandleTypeDef),
            "::",
            stringify!(EventCount)
        )
    );
}
#[doc = " @defgroup I2C_handle_Structure_definition I2C handle Structure definition\n @brief  I2C handle Structure definition\n @{"]
pub type I2C_HandleTypeDef = __I2C_HandleTypeDef;
extern "C" {
    #[doc = " @addtogroup I2C_Exported_Functions_Group1 Initialization and de-initialization functions\n @{"]
    pub fn HAL_I2C_Init(hi2c: *mut I2C_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_I2C_DeInit(hi2c: *mut I2C_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_I2C_MspInit(hi2c: *mut I2C_HandleTypeDef);
}
extern "C" {
    pub fn HAL_I2C_MspDeInit(hi2c: *mut I2C_HandleTypeDef);
}
extern "C" {
    #[doc = " Blocking mode: Polling"]
    pub fn HAL_I2C_Master_Transmit(
        hi2c: *mut I2C_HandleTypeDef,
        DevAddress: u16,
        pData: *mut u8,
        Size: u16,
        Timeout: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_I2C_Master_Receive(
        hi2c: *mut I2C_HandleTypeDef,
        DevAddress: u16,
        pData: *mut u8,
        Size: u16,
        Timeout: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_I2C_Slave_Transmit(
        hi2c: *mut I2C_HandleTypeDef,
        pData: *mut u8,
        Size: u16,
        Timeout: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_I2C_Slave_Receive(
        hi2c: *mut I2C_HandleTypeDef,
        pData: *mut u8,
        Size: u16,
        Timeout: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_I2C_Mem_Write(
        hi2c: *mut I2C_HandleTypeDef,
        DevAddress: u16,
        MemAddress: u16,
        MemAddSize: u16,
        pData: *mut u8,
        Size: u16,
        Timeout: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_I2C_Mem_Read(
        hi2c: *mut I2C_HandleTypeDef,
        DevAddress: u16,
        MemAddress: u16,
        MemAddSize: u16,
        pData: *mut u8,
        Size: u16,
        Timeout: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_I2C_IsDeviceReady(
        hi2c: *mut I2C_HandleTypeDef,
        DevAddress: u16,
        Trials: u32,
        Timeout: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    #[doc = " Non-Blocking mode: Interrupt"]
    pub fn HAL_I2C_Master_Transmit_IT(
        hi2c: *mut I2C_HandleTypeDef,
        DevAddress: u16,
        pData: *mut u8,
        Size: u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_I2C_Master_Receive_IT(
        hi2c: *mut I2C_HandleTypeDef,
        DevAddress: u16,
        pData: *mut u8,
        Size: u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_I2C_Slave_Transmit_IT(
        hi2c: *mut I2C_HandleTypeDef,
        pData: *mut u8,
        Size: u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_I2C_Slave_Receive_IT(
        hi2c: *mut I2C_HandleTypeDef,
        pData: *mut u8,
        Size: u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_I2C_Mem_Write_IT(
        hi2c: *mut I2C_HandleTypeDef,
        DevAddress: u16,
        MemAddress: u16,
        MemAddSize: u16,
        pData: *mut u8,
        Size: u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_I2C_Mem_Read_IT(
        hi2c: *mut I2C_HandleTypeDef,
        DevAddress: u16,
        MemAddress: u16,
        MemAddSize: u16,
        pData: *mut u8,
        Size: u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_I2C_Master_Seq_Transmit_IT(
        hi2c: *mut I2C_HandleTypeDef,
        DevAddress: u16,
        pData: *mut u8,
        Size: u16,
        XferOptions: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_I2C_Master_Seq_Receive_IT(
        hi2c: *mut I2C_HandleTypeDef,
        DevAddress: u16,
        pData: *mut u8,
        Size: u16,
        XferOptions: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_I2C_Slave_Seq_Transmit_IT(
        hi2c: *mut I2C_HandleTypeDef,
        pData: *mut u8,
        Size: u16,
        XferOptions: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_I2C_Slave_Seq_Receive_IT(
        hi2c: *mut I2C_HandleTypeDef,
        pData: *mut u8,
        Size: u16,
        XferOptions: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_I2C_EnableListen_IT(hi2c: *mut I2C_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_I2C_DisableListen_IT(hi2c: *mut I2C_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_I2C_Master_Abort_IT(
        hi2c: *mut I2C_HandleTypeDef,
        DevAddress: u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    #[doc = " Non-Blocking mode: DMA"]
    pub fn HAL_I2C_Master_Transmit_DMA(
        hi2c: *mut I2C_HandleTypeDef,
        DevAddress: u16,
        pData: *mut u8,
        Size: u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_I2C_Master_Receive_DMA(
        hi2c: *mut I2C_HandleTypeDef,
        DevAddress: u16,
        pData: *mut u8,
        Size: u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_I2C_Slave_Transmit_DMA(
        hi2c: *mut I2C_HandleTypeDef,
        pData: *mut u8,
        Size: u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_I2C_Slave_Receive_DMA(
        hi2c: *mut I2C_HandleTypeDef,
        pData: *mut u8,
        Size: u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_I2C_Mem_Write_DMA(
        hi2c: *mut I2C_HandleTypeDef,
        DevAddress: u16,
        MemAddress: u16,
        MemAddSize: u16,
        pData: *mut u8,
        Size: u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_I2C_Mem_Read_DMA(
        hi2c: *mut I2C_HandleTypeDef,
        DevAddress: u16,
        MemAddress: u16,
        MemAddSize: u16,
        pData: *mut u8,
        Size: u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_I2C_Master_Seq_Transmit_DMA(
        hi2c: *mut I2C_HandleTypeDef,
        DevAddress: u16,
        pData: *mut u8,
        Size: u16,
        XferOptions: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_I2C_Master_Seq_Receive_DMA(
        hi2c: *mut I2C_HandleTypeDef,
        DevAddress: u16,
        pData: *mut u8,
        Size: u16,
        XferOptions: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_I2C_Slave_Seq_Transmit_DMA(
        hi2c: *mut I2C_HandleTypeDef,
        pData: *mut u8,
        Size: u16,
        XferOptions: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_I2C_Slave_Seq_Receive_DMA(
        hi2c: *mut I2C_HandleTypeDef,
        pData: *mut u8,
        Size: u16,
        XferOptions: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    #[doc = " @addtogroup I2C_IRQ_Handler_and_Callbacks IRQ Handler and Callbacks\n @{\n/\n/******* I2C IRQHandler and Callbacks used in non blocking modes (Interrupt and DMA)"]
    pub fn HAL_I2C_EV_IRQHandler(hi2c: *mut I2C_HandleTypeDef);
}
extern "C" {
    pub fn HAL_I2C_ER_IRQHandler(hi2c: *mut I2C_HandleTypeDef);
}
extern "C" {
    pub fn HAL_I2C_MasterTxCpltCallback(hi2c: *mut I2C_HandleTypeDef);
}
extern "C" {
    pub fn HAL_I2C_MasterRxCpltCallback(hi2c: *mut I2C_HandleTypeDef);
}
extern "C" {
    pub fn HAL_I2C_SlaveTxCpltCallback(hi2c: *mut I2C_HandleTypeDef);
}
extern "C" {
    pub fn HAL_I2C_SlaveRxCpltCallback(hi2c: *mut I2C_HandleTypeDef);
}
extern "C" {
    pub fn HAL_I2C_AddrCallback(
        hi2c: *mut I2C_HandleTypeDef,
        TransferDirection: u8,
        AddrMatchCode: u16,
    );
}
extern "C" {
    pub fn HAL_I2C_ListenCpltCallback(hi2c: *mut I2C_HandleTypeDef);
}
extern "C" {
    pub fn HAL_I2C_MemTxCpltCallback(hi2c: *mut I2C_HandleTypeDef);
}
extern "C" {
    pub fn HAL_I2C_MemRxCpltCallback(hi2c: *mut I2C_HandleTypeDef);
}
extern "C" {
    pub fn HAL_I2C_ErrorCallback(hi2c: *mut I2C_HandleTypeDef);
}
extern "C" {
    pub fn HAL_I2C_AbortCpltCallback(hi2c: *mut I2C_HandleTypeDef);
}
extern "C" {
    #[doc = " @addtogroup I2C_Exported_Functions_Group3 Peripheral State, Mode and Error functions\n @{"]
    pub fn HAL_I2C_GetState(hi2c: *mut I2C_HandleTypeDef) -> HAL_I2C_StateTypeDef;
}
extern "C" {
    pub fn HAL_I2C_GetMode(hi2c: *mut I2C_HandleTypeDef) -> HAL_I2C_ModeTypeDef;
}
extern "C" {
    pub fn HAL_I2C_GetError(hi2c: *mut I2C_HandleTypeDef) -> u32;
}
#[doc = " @brief  IWDG Init structure definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IWDG_InitTypeDef {
    #[doc = "< Select the prescaler of the IWDG.\nThis parameter can be a value of @ref IWDG_Prescaler"]
    pub Prescaler: u32,
    #[doc = "< Specifies the IWDG down-counter reload value.\nThis parameter must be a number between Min_Data = 0 and Max_Data = 0x0FFF"]
    pub Reload: u32,
}
#[test]
fn bindgen_test_layout_IWDG_InitTypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<IWDG_InitTypeDef> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<IWDG_InitTypeDef>(),
        8usize,
        concat!("Size of: ", stringify!(IWDG_InitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<IWDG_InitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(IWDG_InitTypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Prescaler) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IWDG_InitTypeDef),
            "::",
            stringify!(Prescaler)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reload) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IWDG_InitTypeDef),
            "::",
            stringify!(Reload)
        )
    );
}
#[doc = " @brief  IWDG Handle Structure definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IWDG_HandleTypeDef {
    #[doc = "< Register base address"]
    pub Instance: *mut IWDG_TypeDef,
    #[doc = "< IWDG required parameters"]
    pub Init: IWDG_InitTypeDef,
}
#[test]
fn bindgen_test_layout_IWDG_HandleTypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<IWDG_HandleTypeDef> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<IWDG_HandleTypeDef>(),
        12usize,
        concat!("Size of: ", stringify!(IWDG_HandleTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<IWDG_HandleTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(IWDG_HandleTypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IWDG_HandleTypeDef),
            "::",
            stringify!(Instance)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Init) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IWDG_HandleTypeDef),
            "::",
            stringify!(Init)
        )
    );
}
extern "C" {
    #[doc = " @defgroup IWDG_Exported_Functions_Group1 Initialization and Start functions\n @{"]
    pub fn HAL_IWDG_Init(hiwdg: *mut IWDG_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    #[doc = " @defgroup IWDG_Exported_Functions_Group2 IO operation functions\n @{"]
    pub fn HAL_IWDG_Refresh(hiwdg: *mut IWDG_HandleTypeDef) -> HAL_StatusTypeDef;
}
#[doc = " @brief  PWR PVD configuration structure definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PWR_PVDTypeDef {
    #[doc = "< PVDSource: Specifies the PVD detection source.\nThis parameter can be a value of @ref PWR_PVD_Source."]
    pub PVDSource: u32,
    #[doc = "< PVDFilter: Specifies the PVD input filter.\nThis parameter can be a value of @ref PWR_PVD_Filter."]
    pub PVDFilter: u32,
    #[doc = "< PVDLevel: Specifies the PVD detection level.\nThis parameter can be a value or a combination of\n@ref PWR_PVD_detection_level."]
    pub PVDLevel: u32,
    #[doc = "< Mode: Specifies the operating mode for the selected pins.\nThis parameter can be a value of @ref PWR_PVD_Mode."]
    pub Mode: u32,
}
#[test]
fn bindgen_test_layout_PWR_PVDTypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<PWR_PVDTypeDef> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<PWR_PVDTypeDef>(),
        16usize,
        concat!("Size of: ", stringify!(PWR_PVDTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<PWR_PVDTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(PWR_PVDTypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PVDSource) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PWR_PVDTypeDef),
            "::",
            stringify!(PVDSource)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PVDFilter) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PWR_PVDTypeDef),
            "::",
            stringify!(PVDFilter)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PVDLevel) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PWR_PVDTypeDef),
            "::",
            stringify!(PVDLevel)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Mode) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(PWR_PVDTypeDef),
            "::",
            stringify!(Mode)
        )
    );
}
#[doc = " @brief  PWR Stop configuration structure definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PWR_StopModeConfigTypeDef {
    #[doc = "< LPVoltSelection: Set the low power internal regulator output voltage.\nThis parameter can be a value of @ref PWR_STOP_LPR_Voltage."]
    pub LPVoltSelection: u32,
    #[doc = "< RegulatorSwitchDelay: Set VDD voltage from LP to MR ready time after wake up.\nThis parameter can be a value of @ref PWR_STOP_WakeUp_Regulator_Switch_Delay."]
    pub RegulatorSwitchDelay: u32,
    #[doc = "< WakeUpHsiEnableTime: Set the flash delay time after wake up.\nThis parameter can be a value of @ref PWR_STOP_WakeUp_HSIEN_Timing."]
    pub WakeUpHsiEnableTime: u32,
    #[doc = "< SramRetentionVolt: Set the SRAM retention voltage in stop mode.\nThis parameter can be a value of @ref PWR_STOP_mode_Sram_Retention_Voltage."]
    pub SramRetentionVolt: u32,
    #[doc = "< FlsahDelay: Set the flash delay time after wake up.\nThis parameter can be a value of @ref PWR_STOP_WakeUp_Flash_Dealy."]
    pub FlashDelay: u32,
}
#[test]
fn bindgen_test_layout_PWR_StopModeConfigTypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<PWR_StopModeConfigTypeDef> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<PWR_StopModeConfigTypeDef>(),
        20usize,
        concat!("Size of: ", stringify!(PWR_StopModeConfigTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<PWR_StopModeConfigTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(PWR_StopModeConfigTypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LPVoltSelection) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PWR_StopModeConfigTypeDef),
            "::",
            stringify!(LPVoltSelection)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RegulatorSwitchDelay) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PWR_StopModeConfigTypeDef),
            "::",
            stringify!(RegulatorSwitchDelay)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).WakeUpHsiEnableTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PWR_StopModeConfigTypeDef),
            "::",
            stringify!(WakeUpHsiEnableTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SramRetentionVolt) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(PWR_StopModeConfigTypeDef),
            "::",
            stringify!(SramRetentionVolt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FlashDelay) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PWR_StopModeConfigTypeDef),
            "::",
            stringify!(FlashDelay)
        )
    );
}
#[doc = " @brief  PWR BIAS configuration structure definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PWR_BIASConfigTypeDef {
    #[doc = "< BiasCurrentSource: Set the bias currents load source.\nThis parameter can be a value of @ref PWR_MR_BiasCurrent_Source."]
    pub BiasCurrentSource: u32,
    #[doc = "< BiasCurrentValue: Set the bias currents config value.\nThis parameter can be a number between Min_Data = 0x0000 and Max_Data = 0xFFFF."]
    pub BiasCurrentValue: u32,
}
#[test]
fn bindgen_test_layout_PWR_BIASConfigTypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<PWR_BIASConfigTypeDef> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<PWR_BIASConfigTypeDef>(),
        8usize,
        concat!("Size of: ", stringify!(PWR_BIASConfigTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<PWR_BIASConfigTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(PWR_BIASConfigTypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BiasCurrentSource) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PWR_BIASConfigTypeDef),
            "::",
            stringify!(BiasCurrentSource)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BiasCurrentValue) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PWR_BIASConfigTypeDef),
            "::",
            stringify!(BiasCurrentValue)
        )
    );
}
extern "C" {
    #[doc = " @defgroup PWR_Exported_Functions_Group1  Initialization and de-initialization functions\n @{"]
    pub fn HAL_PWR_DeInit();
}
extern "C" {
    #[doc = " @defgroup PWR_Exported_Functions_Group2  Peripheral Control functions\n @{"]
    pub fn HAL_PWR_EnableBkUpAccess();
}
extern "C" {
    pub fn HAL_PWR_DisableBkUpAccess();
}
extern "C" {
    pub fn HAL_PWR_ConfigPVD(sConfigPVD: *mut PWR_PVDTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_PWR_EnablePVD();
}
extern "C" {
    pub fn HAL_PWR_DisablePVD();
}
extern "C" {
    pub fn HAL_PWR_ConfigStopMode(
        sStopModeConfig: *mut PWR_StopModeConfigTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_PWR_ConfigBIAS(sBIASConfig: *mut PWR_BIASConfigTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_PWR_EnterSLEEPMode(SLEEPEntry: u8);
}
extern "C" {
    pub fn HAL_PWR_EnterSTOPMode(Regulator: u32, STOPEntry: u8);
}
extern "C" {
    pub fn HAL_PWR_EnableSleepOnExit();
}
extern "C" {
    pub fn HAL_PWR_DisableSleepOnExit();
}
extern "C" {
    pub fn HAL_PWR_EnableSEVOnPend();
}
extern "C" {
    pub fn HAL_PWR_DisableSEVOnPend();
}
extern "C" {
    pub fn HAL_PWR_PVD_IRQHandler();
}
extern "C" {
    pub fn HAL_PWR_PVD_Callback();
}
#[doc = " @defgroup RTC_Exported_Types RTC Exported Types\n @{\n/\n/**\n @brief  RTC Time structure definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RTC_TimeTypeDef {
    #[doc = "< Specifies the RTC Time Hour.\nThis parameter must be a number between Min_Data = 0 and Max_Data = 23"]
    pub Hours: u8,
    #[doc = "< Specifies the RTC Time Minutes.\nThis parameter must be a number between Min_Data = 0 and Max_Data = 59"]
    pub Minutes: u8,
    #[doc = "< Specifies the RTC Time Seconds.\nThis parameter must be a number between Min_Data = 0 and Max_Data = 59"]
    pub Seconds: u8,
}
#[test]
fn bindgen_test_layout_RTC_TimeTypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<RTC_TimeTypeDef> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<RTC_TimeTypeDef>(),
        3usize,
        concat!("Size of: ", stringify!(RTC_TimeTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_TimeTypeDef>(),
        1usize,
        concat!("Alignment of ", stringify!(RTC_TimeTypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Hours) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TimeTypeDef),
            "::",
            stringify!(Hours)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Minutes) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TimeTypeDef),
            "::",
            stringify!(Minutes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Seconds) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TimeTypeDef),
            "::",
            stringify!(Seconds)
        )
    );
}
#[doc = " @brief  RTC Alarm structure definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RTC_AlarmTypeDef {
    #[doc = "< Specifies the RTC Alarm Time members"]
    pub AlarmTime: RTC_TimeTypeDef,
}
#[test]
fn bindgen_test_layout_RTC_AlarmTypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<RTC_AlarmTypeDef> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<RTC_AlarmTypeDef>(),
        3usize,
        concat!("Size of: ", stringify!(RTC_AlarmTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_AlarmTypeDef>(),
        1usize,
        concat!("Alignment of ", stringify!(RTC_AlarmTypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AlarmTime) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_AlarmTypeDef),
            "::",
            stringify!(AlarmTime)
        )
    );
}
#[doc = "< RTC not yet initialized or disabled"]
pub const HAL_RTCStateTypeDef_HAL_RTC_STATE_RESET: HAL_RTCStateTypeDef = 0;
#[doc = "< RTC initialized and ready for use"]
pub const HAL_RTCStateTypeDef_HAL_RTC_STATE_READY: HAL_RTCStateTypeDef = 1;
#[doc = "< RTC process is ongoing"]
pub const HAL_RTCStateTypeDef_HAL_RTC_STATE_BUSY: HAL_RTCStateTypeDef = 2;
#[doc = "< RTC timeout state"]
pub const HAL_RTCStateTypeDef_HAL_RTC_STATE_TIMEOUT: HAL_RTCStateTypeDef = 3;
#[doc = "< RTC error state"]
pub const HAL_RTCStateTypeDef_HAL_RTC_STATE_ERROR: HAL_RTCStateTypeDef = 4;
#[doc = " @brief  HAL State structures definition"]
pub type HAL_RTCStateTypeDef = ::core::ffi::c_uint;
#[doc = " @brief  RTC Configuration Structure definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RTC_InitTypeDef {
    #[doc = "< Specifies the RTC Asynchronous Predivider value.\nThis parameter must be a number between Min_Data = 0x00 and Max_Data = 0xFFFFF  or RTC_AUTO_1_SECOND\nIf RTC_AUTO_1_SECOND is selected, AsynchPrediv will be set automatically to get 1sec timebase"]
    pub AsynchPrediv: u32,
    #[doc = "< Specifies which signal will be routed to the RTC Tamper pin.\nThis parameter can be a value of @ref RTC_output_source_to_output_pin"]
    pub OutPut: u32,
}
#[test]
fn bindgen_test_layout_RTC_InitTypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<RTC_InitTypeDef> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<RTC_InitTypeDef>(),
        8usize,
        concat!("Size of: ", stringify!(RTC_InitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_InitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(RTC_InitTypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AsynchPrediv) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_InitTypeDef),
            "::",
            stringify!(AsynchPrediv)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OutPut) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_InitTypeDef),
            "::",
            stringify!(OutPut)
        )
    );
}
#[doc = " @brief  RTC Date structure definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RTC_DateTypeDef {
    #[doc = "< Specifies the RTC Date WeekDay (not necessary for HAL_RTC_SetDate).\nThis parameter can be a value of @ref RTC_WeekDay_Definitions"]
    pub WeekDay: u8,
    #[doc = "< Specifies the RTC Date Month (in BCD format).\nThis parameter can be a value of @ref RTC_Month_Date_Definitions"]
    pub Month: u8,
    #[doc = "< Specifies the RTC Date.\nThis parameter must be a number between Min_Data = 1 and Max_Data = 31"]
    pub Date: u8,
    #[doc = "< Specifies the RTC Date Year.\nThis parameter must be a number between Min_Data = 0 and Max_Data = 99"]
    pub Year: u8,
}
#[test]
fn bindgen_test_layout_RTC_DateTypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<RTC_DateTypeDef> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<RTC_DateTypeDef>(),
        4usize,
        concat!("Size of: ", stringify!(RTC_DateTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_DateTypeDef>(),
        1usize,
        concat!("Alignment of ", stringify!(RTC_DateTypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).WeekDay) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_DateTypeDef),
            "::",
            stringify!(WeekDay)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Month) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_DateTypeDef),
            "::",
            stringify!(Month)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Date) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_DateTypeDef),
            "::",
            stringify!(Date)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Year) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_DateTypeDef),
            "::",
            stringify!(Year)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RTC_HandleTypeDef {
    #[doc = "< Register base address"]
    pub Instance: *mut RTC_TypeDef,
    #[doc = "< RTC required parameters"]
    pub Init: RTC_InitTypeDef,
    #[doc = "< Current date set by user and updated automatically"]
    pub DateToUpdate: RTC_DateTypeDef,
    #[doc = "< RTC locking object"]
    pub Lock: HAL_LockTypeDef,
    #[doc = "< Time communication state"]
    pub State: HAL_RTCStateTypeDef,
}
#[test]
fn bindgen_test_layout_RTC_HandleTypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<RTC_HandleTypeDef> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<RTC_HandleTypeDef>(),
        24usize,
        concat!("Size of: ", stringify!(RTC_HandleTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_HandleTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(RTC_HandleTypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_HandleTypeDef),
            "::",
            stringify!(Instance)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Init) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_HandleTypeDef),
            "::",
            stringify!(Init)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DateToUpdate) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_HandleTypeDef),
            "::",
            stringify!(DateToUpdate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Lock) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_HandleTypeDef),
            "::",
            stringify!(Lock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).State) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_HandleTypeDef),
            "::",
            stringify!(State)
        )
    );
}
extern "C" {
    #[doc = " @addtogroup RTCEx_Exported_Functions_Group2\n @{"]
    pub fn HAL_RTCEx_SetSecond_IT(hrtc: *mut RTC_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_RTCEx_DeactivateSecond(hrtc: *mut RTC_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_RTCEx_RTCIRQHandler(hrtc: *mut RTC_HandleTypeDef);
}
extern "C" {
    pub fn HAL_RTCEx_RTCEventCallback(hrtc: *mut RTC_HandleTypeDef);
}
extern "C" {
    pub fn HAL_RTCEx_RTCEventErrorCallback(hrtc: *mut RTC_HandleTypeDef);
}
extern "C" {
    #[doc = " @addtogroup RTCEx_Exported_Functions_Group3\n @{"]
    pub fn HAL_RTCEx_SetSmoothCalib(
        hrtc: *mut RTC_HandleTypeDef,
        SmoothCalibPeriod: u32,
        SmoothCalibPlusPulses: u32,
        SmouthCalibMinusPulsesValue: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    #[doc = " @addtogroup RTC_Exported_Functions_Group1\n @{"]
    pub fn HAL_RTC_Init(hrtc: *mut RTC_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_RTC_DeInit(hrtc: *mut RTC_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_RTC_MspInit(hrtc: *mut RTC_HandleTypeDef);
}
extern "C" {
    pub fn HAL_RTC_MspDeInit(hrtc: *mut RTC_HandleTypeDef);
}
extern "C" {
    #[doc = " @addtogroup RTC_Exported_Functions_Group2\n @{"]
    pub fn HAL_RTC_SetTime(
        hrtc: *mut RTC_HandleTypeDef,
        sTime: *mut RTC_TimeTypeDef,
        Format: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_RTC_GetTime(
        hrtc: *mut RTC_HandleTypeDef,
        sTime: *mut RTC_TimeTypeDef,
        Format: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_RTC_SetDate(
        hrtc: *mut RTC_HandleTypeDef,
        sDate: *mut RTC_DateTypeDef,
        Format: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_RTC_GetDate(
        hrtc: *mut RTC_HandleTypeDef,
        sDate: *mut RTC_DateTypeDef,
        Format: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    #[doc = " @addtogroup RTC_Exported_Functions_Group3\n @{"]
    pub fn HAL_RTC_SetAlarm(
        hrtc: *mut RTC_HandleTypeDef,
        sAlarm: *mut RTC_AlarmTypeDef,
        Format: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_RTC_SetAlarm_IT(
        hrtc: *mut RTC_HandleTypeDef,
        sAlarm: *mut RTC_AlarmTypeDef,
        Format: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_RTC_DeactivateAlarm(hrtc: *mut RTC_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_RTC_GetAlarm(
        hrtc: *mut RTC_HandleTypeDef,
        sAlarm: *mut RTC_AlarmTypeDef,
        Format: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_RTC_AlarmIRQHandler(hrtc: *mut RTC_HandleTypeDef);
}
extern "C" {
    pub fn HAL_RTC_PollForAlarmAEvent(
        hrtc: *mut RTC_HandleTypeDef,
        Timeout: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_RTC_AlarmAEventCallback(hrtc: *mut RTC_HandleTypeDef);
}
extern "C" {
    #[doc = " @addtogroup RTC_Exported_Functions_Group4\n @{"]
    pub fn HAL_RTC_GetState(hrtc: *mut RTC_HandleTypeDef) -> HAL_RTCStateTypeDef;
}
extern "C" {
    #[doc = " @addtogroup RTC_Exported_Functions_Group5\n @{"]
    pub fn HAL_RTC_WaitForSynchro(hrtc: *mut RTC_HandleTypeDef) -> HAL_StatusTypeDef;
}
#[doc = " @brief  SPI Configuration Structure definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SPI_InitTypeDef {
    #[doc = "< Specifies the SPI operating mode.\nThis parameter can be a value of @ref SPI_Mode"]
    pub Mode: u32,
    #[doc = "< Specifies the SPI bidirectional mode state.\nThis parameter can be a value of @ref SPI_Direction"]
    pub Direction: u32,
    #[doc = "< Specifies the SPI data size.\nThis parameter can be a value of @ref SPI_Data_Size"]
    pub DataSize: u32,
    #[doc = "< Specifies the serial clock steady state.\nThis parameter can be a value of @ref SPI_Clock_Polarity"]
    pub CLKPolarity: u32,
    #[doc = "< Specifies the clock active edge for the bit capture.\nThis parameter can be a value of @ref SPI_Clock_Phase"]
    pub CLKPhase: u32,
    #[doc = "< Specifies whether the NSS signal is managed by\nhardware (NSS pin) or by software using the SSI bit.\nThis parameter can be a value of @ref SPI_Slave_Select_management"]
    pub NSS: u32,
    #[doc = "< Specifies the Baud Rate prescaler value which will be\nused to configure the transmit and receive SCK clock.\nThis parameter can be a value of @ref SPI_BaudRate_Prescaler\n@note The communication clock is derived from the master\nclock. The slave clock does not need to be set."]
    pub BaudRatePrescaler: u32,
    #[doc = "< Specifies whether data transfers start from MSB or LSB bit.\nThis parameter can be a value of @ref SPI_MSB_LSB_transmission"]
    pub FirstBit: u32,
    #[doc = "< Specifies the Slave fast mode is enabled or not.\nThis parameter can be a value of @ref SPI_Slave_Fast_mode"]
    pub SlaveFastMode: u32,
}
#[test]
fn bindgen_test_layout_SPI_InitTypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<SPI_InitTypeDef> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SPI_InitTypeDef>(),
        36usize,
        concat!("Size of: ", stringify!(SPI_InitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<SPI_InitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(SPI_InitTypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Mode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_InitTypeDef),
            "::",
            stringify!(Mode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Direction) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_InitTypeDef),
            "::",
            stringify!(Direction)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DataSize) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_InitTypeDef),
            "::",
            stringify!(DataSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CLKPolarity) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_InitTypeDef),
            "::",
            stringify!(CLKPolarity)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CLKPhase) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_InitTypeDef),
            "::",
            stringify!(CLKPhase)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NSS) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_InitTypeDef),
            "::",
            stringify!(NSS)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BaudRatePrescaler) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_InitTypeDef),
            "::",
            stringify!(BaudRatePrescaler)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FirstBit) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_InitTypeDef),
            "::",
            stringify!(FirstBit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SlaveFastMode) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_InitTypeDef),
            "::",
            stringify!(SlaveFastMode)
        )
    );
}
#[doc = "< Peripheral not Initialized"]
pub const HAL_SPI_StateTypeDef_HAL_SPI_STATE_RESET: HAL_SPI_StateTypeDef = 0;
#[doc = "< Peripheral Initialized and ready for use"]
pub const HAL_SPI_StateTypeDef_HAL_SPI_STATE_READY: HAL_SPI_StateTypeDef = 1;
#[doc = "< an internal process is ongoing"]
pub const HAL_SPI_StateTypeDef_HAL_SPI_STATE_BUSY: HAL_SPI_StateTypeDef = 2;
#[doc = "< Data Transmission process is ongoing"]
pub const HAL_SPI_StateTypeDef_HAL_SPI_STATE_BUSY_TX: HAL_SPI_StateTypeDef = 3;
#[doc = "< Data Reception process is ongoing"]
pub const HAL_SPI_StateTypeDef_HAL_SPI_STATE_BUSY_RX: HAL_SPI_StateTypeDef = 4;
#[doc = "< Data Transmission and Reception process is ongoing"]
pub const HAL_SPI_StateTypeDef_HAL_SPI_STATE_BUSY_TX_RX: HAL_SPI_StateTypeDef = 5;
#[doc = "< SPI error state"]
pub const HAL_SPI_StateTypeDef_HAL_SPI_STATE_ERROR: HAL_SPI_StateTypeDef = 6;
#[doc = "< SPI abort is ongoing"]
pub const HAL_SPI_StateTypeDef_HAL_SPI_STATE_ABORT: HAL_SPI_StateTypeDef = 7;
#[doc = " @brief  HAL SPI State structure definition"]
pub type HAL_SPI_StateTypeDef = ::core::ffi::c_uint;
#[doc = " @brief  SPI handle Structure definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __SPI_HandleTypeDef {
    #[doc = "< SPI registers base address"]
    pub Instance: *mut SPI_TypeDef,
    #[doc = "< SPI communication parameters"]
    pub Init: SPI_InitTypeDef,
    #[doc = "< Pointer to SPI Tx transfer Buffer"]
    pub pTxBuffPtr: *mut u8,
    #[doc = "< SPI Tx Transfer size"]
    pub TxXferSize: u16,
    #[doc = "< SPI Tx Transfer Counter"]
    pub TxXferCount: u16,
    #[doc = "< Pointer to SPI Rx transfer Buffer"]
    pub pRxBuffPtr: *mut u8,
    #[doc = "< SPI Rx Transfer size"]
    pub RxXferSize: u16,
    #[doc = "< SPI Rx Transfer Counter"]
    pub RxXferCount: u16,
    #[doc = "< function pointer on Rx ISR"]
    pub RxISR: ::core::option::Option<unsafe extern "C" fn(hspi: *mut __SPI_HandleTypeDef)>,
    #[doc = "< function pointer on Tx ISR"]
    pub TxISR: ::core::option::Option<unsafe extern "C" fn(hspi: *mut __SPI_HandleTypeDef)>,
    #[doc = "< SPI Tx DMA Handle parameters"]
    pub hdmatx: *mut DMA_HandleTypeDef,
    #[doc = "< SPI Rx DMA Handle parameters"]
    pub hdmarx: *mut DMA_HandleTypeDef,
    #[doc = "< Locking object"]
    pub Lock: HAL_LockTypeDef,
    #[doc = "< SPI communication state"]
    pub State: HAL_SPI_StateTypeDef,
    #[doc = "< SPI Error code"]
    pub ErrorCode: u32,
}
#[test]
fn bindgen_test_layout___SPI_HandleTypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<__SPI_HandleTypeDef> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__SPI_HandleTypeDef>(),
        84usize,
        concat!("Size of: ", stringify!(__SPI_HandleTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<__SPI_HandleTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(__SPI_HandleTypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__SPI_HandleTypeDef),
            "::",
            stringify!(Instance)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Init) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__SPI_HandleTypeDef),
            "::",
            stringify!(Init)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pTxBuffPtr) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__SPI_HandleTypeDef),
            "::",
            stringify!(pTxBuffPtr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TxXferSize) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(__SPI_HandleTypeDef),
            "::",
            stringify!(TxXferSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TxXferCount) as usize - ptr as usize },
        46usize,
        concat!(
            "Offset of field: ",
            stringify!(__SPI_HandleTypeDef),
            "::",
            stringify!(TxXferCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pRxBuffPtr) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__SPI_HandleTypeDef),
            "::",
            stringify!(pRxBuffPtr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RxXferSize) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(__SPI_HandleTypeDef),
            "::",
            stringify!(RxXferSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RxXferCount) as usize - ptr as usize },
        54usize,
        concat!(
            "Offset of field: ",
            stringify!(__SPI_HandleTypeDef),
            "::",
            stringify!(RxXferCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RxISR) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__SPI_HandleTypeDef),
            "::",
            stringify!(RxISR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TxISR) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(__SPI_HandleTypeDef),
            "::",
            stringify!(TxISR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hdmatx) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__SPI_HandleTypeDef),
            "::",
            stringify!(hdmatx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hdmarx) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(__SPI_HandleTypeDef),
            "::",
            stringify!(hdmarx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Lock) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__SPI_HandleTypeDef),
            "::",
            stringify!(Lock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).State) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(__SPI_HandleTypeDef),
            "::",
            stringify!(State)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ErrorCode) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(__SPI_HandleTypeDef),
            "::",
            stringify!(ErrorCode)
        )
    );
}
#[doc = " @brief  SPI handle Structure definition"]
pub type SPI_HandleTypeDef = __SPI_HandleTypeDef;
extern "C" {
    #[doc = " @addtogroup SPI_Exported_Functions_Group1\n @{"]
    pub fn HAL_SPI_Init(hspi: *mut SPI_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SPI_DeInit(hspi: *mut SPI_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SPI_MspInit(hspi: *mut SPI_HandleTypeDef);
}
extern "C" {
    pub fn HAL_SPI_MspDeInit(hspi: *mut SPI_HandleTypeDef);
}
extern "C" {
    #[doc = " @addtogroup SPI_Exported_Functions_Group2\n @{"]
    pub fn HAL_SPI_Transmit(
        hspi: *mut SPI_HandleTypeDef,
        pData: *mut u8,
        Size: u16,
        Timeout: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SPI_Receive(
        hspi: *mut SPI_HandleTypeDef,
        pData: *mut u8,
        Size: u16,
        Timeout: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SPI_TransmitReceive(
        hspi: *mut SPI_HandleTypeDef,
        pTxData: *mut u8,
        pRxData: *mut u8,
        Size: u16,
        Timeout: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SPI_Transmit_IT(
        hspi: *mut SPI_HandleTypeDef,
        pData: *mut u8,
        Size: u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SPI_Receive_IT(
        hspi: *mut SPI_HandleTypeDef,
        pData: *mut u8,
        Size: u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SPI_TransmitReceive_IT(
        hspi: *mut SPI_HandleTypeDef,
        pTxData: *mut u8,
        pRxData: *mut u8,
        Size: u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SPI_Transmit_DMA(
        hspi: *mut SPI_HandleTypeDef,
        pData: *mut u8,
        Size: u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SPI_Receive_DMA(
        hspi: *mut SPI_HandleTypeDef,
        pData: *mut u8,
        Size: u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SPI_TransmitReceive_DMA(
        hspi: *mut SPI_HandleTypeDef,
        pTxData: *mut u8,
        pRxData: *mut u8,
        Size: u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SPI_DMAPause(hspi: *mut SPI_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SPI_DMAResume(hspi: *mut SPI_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SPI_DMAStop(hspi: *mut SPI_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SPI_Abort(hspi: *mut SPI_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SPI_Abort_IT(hspi: *mut SPI_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_SPI_IRQHandler(hspi: *mut SPI_HandleTypeDef);
}
extern "C" {
    pub fn HAL_SPI_TxCpltCallback(hspi: *mut SPI_HandleTypeDef);
}
extern "C" {
    pub fn HAL_SPI_RxCpltCallback(hspi: *mut SPI_HandleTypeDef);
}
extern "C" {
    pub fn HAL_SPI_TxRxCpltCallback(hspi: *mut SPI_HandleTypeDef);
}
extern "C" {
    pub fn HAL_SPI_TxHalfCpltCallback(hspi: *mut SPI_HandleTypeDef);
}
extern "C" {
    pub fn HAL_SPI_RxHalfCpltCallback(hspi: *mut SPI_HandleTypeDef);
}
extern "C" {
    pub fn HAL_SPI_TxRxHalfCpltCallback(hspi: *mut SPI_HandleTypeDef);
}
extern "C" {
    pub fn HAL_SPI_ErrorCallback(hspi: *mut SPI_HandleTypeDef);
}
extern "C" {
    pub fn HAL_SPI_AbortCpltCallback(hspi: *mut SPI_HandleTypeDef);
}
extern "C" {
    #[doc = " @addtogroup SPI_Exported_Functions_Group3\n @{"]
    pub fn HAL_SPI_GetState(hspi: *mut SPI_HandleTypeDef) -> HAL_SPI_StateTypeDef;
}
extern "C" {
    pub fn HAL_SPI_GetError(hspi: *mut SPI_HandleTypeDef) -> u32;
}
#[doc = " @brief  TIM Time base Configuration Structure definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TIM_Base_InitTypeDef {
    #[doc = "< Specifies the prescaler value used to divide the TIM clock.\nThis parameter can be a number between Min_Data = 0x0000 and Max_Data = 0xFFFF"]
    pub Prescaler: u32,
    #[doc = "< Specifies the counter mode.\nThis parameter can be a value of @ref TIM_Counter_Mode"]
    pub CounterMode: u32,
    #[doc = "< Specifies the period value to be loaded into the active\nAuto-Reload Register at the next update event.\nThis parameter can be a number between Min_Data = 0x0000 and Max_Data = 0xFFFF."]
    pub Period: u32,
    #[doc = "< Specifies the clock division.\nThis parameter can be a value of @ref TIM_ClockDivision"]
    pub ClockDivision: u32,
    #[doc = "< Specifies the repetition counter value. Each time the RCR downcounter\nreaches zero, an update event is generated and counting restarts\nfrom the RCR value (N).\nThis means in PWM mode that (N+1) corresponds to:\n- the number of PWM periods in edge-aligned mode\n- the number of half PWM period in center-aligned mode\nGP timers: this parameter must be a number between Min_Data = 0x00 and Max_Data = 0xFF.\nAdvanced timers: this parameter must be a number between Min_Data = 0x0000 and Max_Data = 0xFFFF."]
    pub RepetitionCounter: u32,
    #[doc = "< Specifies the auto-reload preload.\nThis parameter can be a value of @ref TIM_AutoReloadPreload"]
    pub AutoReloadPreload: u32,
}
#[test]
fn bindgen_test_layout_TIM_Base_InitTypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<TIM_Base_InitTypeDef> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TIM_Base_InitTypeDef>(),
        24usize,
        concat!("Size of: ", stringify!(TIM_Base_InitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<TIM_Base_InitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(TIM_Base_InitTypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Prescaler) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_Base_InitTypeDef),
            "::",
            stringify!(Prescaler)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CounterMode) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_Base_InitTypeDef),
            "::",
            stringify!(CounterMode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Period) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_Base_InitTypeDef),
            "::",
            stringify!(Period)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ClockDivision) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_Base_InitTypeDef),
            "::",
            stringify!(ClockDivision)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RepetitionCounter) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_Base_InitTypeDef),
            "::",
            stringify!(RepetitionCounter)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AutoReloadPreload) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_Base_InitTypeDef),
            "::",
            stringify!(AutoReloadPreload)
        )
    );
}
#[doc = " @brief  TIM Output Compare Configuration Structure definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TIM_OC_InitTypeDef {
    #[doc = "< Specifies the TIM mode.\nThis parameter can be a value of @ref TIM_Output_Compare_and_PWM_modes"]
    pub OCMode: u32,
    #[doc = "< Specifies the pulse value to be loaded into the Capture Compare Register.\nThis parameter can be a number between Min_Data = 0x0000 and Max_Data = 0xFFFF"]
    pub Pulse: u32,
    #[doc = "< Specifies the output polarity.\nThis parameter can be a value of @ref TIM_Output_Compare_Polarity"]
    pub OCPolarity: u32,
    #[doc = "< Specifies the complementary output polarity.\nThis parameter can be a value of @ref TIM_Output_Compare_N_Polarity\n@note This parameter is valid only for timer instances supporting break feature."]
    pub OCNPolarity: u32,
    #[doc = "< Specifies the Fast mode state.\nThis parameter can be a value of @ref TIM_Output_Fast_State\n@note This parameter is valid only in PWM1 and PWM2 mode."]
    pub OCFastMode: u32,
    #[doc = "< Specifies the TIM Output Compare pin state during Idle state.\nThis parameter can be a value of @ref TIM_Output_Compare_Idle_State\n@note This parameter is valid only for timer instances supporting break feature."]
    pub OCIdleState: u32,
    #[doc = "< Specifies the TIM Output Compare pin state during Idle state.\nThis parameter can be a value of @ref TIM_Output_Compare_N_Idle_State\n@note This parameter is valid only for timer instances supporting break feature."]
    pub OCNIdleState: u32,
}
#[test]
fn bindgen_test_layout_TIM_OC_InitTypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<TIM_OC_InitTypeDef> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TIM_OC_InitTypeDef>(),
        28usize,
        concat!("Size of: ", stringify!(TIM_OC_InitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<TIM_OC_InitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(TIM_OC_InitTypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OCMode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_OC_InitTypeDef),
            "::",
            stringify!(OCMode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Pulse) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_OC_InitTypeDef),
            "::",
            stringify!(Pulse)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OCPolarity) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_OC_InitTypeDef),
            "::",
            stringify!(OCPolarity)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OCNPolarity) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_OC_InitTypeDef),
            "::",
            stringify!(OCNPolarity)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OCFastMode) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_OC_InitTypeDef),
            "::",
            stringify!(OCFastMode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OCIdleState) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_OC_InitTypeDef),
            "::",
            stringify!(OCIdleState)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OCNIdleState) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_OC_InitTypeDef),
            "::",
            stringify!(OCNIdleState)
        )
    );
}
#[doc = " @brief  TIM One Pulse Mode Configuration Structure definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TIM_OnePulse_InitTypeDef {
    #[doc = "< Specifies the TIM mode.\nThis parameter can be a value of @ref TIM_Output_Compare_and_PWM_modes"]
    pub OCMode: u32,
    #[doc = "< Specifies the pulse value to be loaded into the Capture Compare Register.\nThis parameter can be a number between Min_Data = 0x0000 and Max_Data = 0xFFFF"]
    pub Pulse: u32,
    #[doc = "< Specifies the output polarity.\nThis parameter can be a value of @ref TIM_Output_Compare_Polarity"]
    pub OCPolarity: u32,
    #[doc = "< Specifies the complementary output polarity.\nThis parameter can be a value of @ref TIM_Output_Compare_N_Polarity\n@note This parameter is valid only for timer instances supporting break feature."]
    pub OCNPolarity: u32,
    #[doc = "< Specifies the TIM Output Compare pin state during Idle state.\nThis parameter can be a value of @ref TIM_Output_Compare_Idle_State\n@note This parameter is valid only for timer instances supporting break feature."]
    pub OCIdleState: u32,
    #[doc = "< Specifies the TIM Output Compare pin state during Idle state.\nThis parameter can be a value of @ref TIM_Output_Compare_N_Idle_State\n@note This parameter is valid only for timer instances supporting break feature."]
    pub OCNIdleState: u32,
    #[doc = "< Specifies the active edge of the input signal.\nThis parameter can be a value of @ref TIM_Input_Capture_Polarity"]
    pub ICPolarity: u32,
    #[doc = "< Specifies the input.\nThis parameter can be a value of @ref TIM_Input_Capture_Selection"]
    pub ICSelection: u32,
    #[doc = "< Specifies the input capture filter.\nThis parameter can be a number between Min_Data = 0x0 and Max_Data = 0xF"]
    pub ICFilter: u32,
}
#[test]
fn bindgen_test_layout_TIM_OnePulse_InitTypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<TIM_OnePulse_InitTypeDef> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TIM_OnePulse_InitTypeDef>(),
        36usize,
        concat!("Size of: ", stringify!(TIM_OnePulse_InitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<TIM_OnePulse_InitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(TIM_OnePulse_InitTypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OCMode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_OnePulse_InitTypeDef),
            "::",
            stringify!(OCMode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Pulse) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_OnePulse_InitTypeDef),
            "::",
            stringify!(Pulse)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OCPolarity) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_OnePulse_InitTypeDef),
            "::",
            stringify!(OCPolarity)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OCNPolarity) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_OnePulse_InitTypeDef),
            "::",
            stringify!(OCNPolarity)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OCIdleState) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_OnePulse_InitTypeDef),
            "::",
            stringify!(OCIdleState)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OCNIdleState) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_OnePulse_InitTypeDef),
            "::",
            stringify!(OCNIdleState)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ICPolarity) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_OnePulse_InitTypeDef),
            "::",
            stringify!(ICPolarity)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ICSelection) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_OnePulse_InitTypeDef),
            "::",
            stringify!(ICSelection)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ICFilter) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_OnePulse_InitTypeDef),
            "::",
            stringify!(ICFilter)
        )
    );
}
#[doc = " @brief  TIM Input Capture Configuration Structure definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TIM_IC_InitTypeDef {
    #[doc = "< Specifies the active edge of the input signal.\nThis parameter can be a value of @ref TIM_Input_Capture_Polarity"]
    pub ICPolarity: u32,
    #[doc = "< Specifies the input.\nThis parameter can be a value of @ref TIM_Input_Capture_Selection"]
    pub ICSelection: u32,
    #[doc = "< Specifies the Input Capture Prescaler.\nThis parameter can be a value of @ref TIM_Input_Capture_Prescaler"]
    pub ICPrescaler: u32,
    #[doc = "< Specifies the input capture filter.\nThis parameter can be a number between Min_Data = 0x0 and Max_Data = 0xF"]
    pub ICFilter: u32,
}
#[test]
fn bindgen_test_layout_TIM_IC_InitTypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<TIM_IC_InitTypeDef> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TIM_IC_InitTypeDef>(),
        16usize,
        concat!("Size of: ", stringify!(TIM_IC_InitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<TIM_IC_InitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(TIM_IC_InitTypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ICPolarity) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_IC_InitTypeDef),
            "::",
            stringify!(ICPolarity)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ICSelection) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_IC_InitTypeDef),
            "::",
            stringify!(ICSelection)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ICPrescaler) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_IC_InitTypeDef),
            "::",
            stringify!(ICPrescaler)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ICFilter) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_IC_InitTypeDef),
            "::",
            stringify!(ICFilter)
        )
    );
}
#[doc = " @brief  TIM Encoder Configuration Structure definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TIM_Encoder_InitTypeDef {
    #[doc = "< Specifies the active edge of the input signal.\nThis parameter can be a value of @ref TIM_Encoder_Mode"]
    pub EncoderMode: u32,
    #[doc = "< Specifies the active edge of the input signal.\nThis parameter can be a value of @ref TIM_Encoder_Input_Polarity"]
    pub IC1Polarity: u32,
    #[doc = "< Specifies the input.\nThis parameter can be a value of @ref TIM_Input_Capture_Selection"]
    pub IC1Selection: u32,
    #[doc = "< Specifies the Input Capture Prescaler.\nThis parameter can be a value of @ref TIM_Input_Capture_Prescaler"]
    pub IC1Prescaler: u32,
    #[doc = "< Specifies the input capture filter.\nThis parameter can be a number between Min_Data = 0x0 and Max_Data = 0xF"]
    pub IC1Filter: u32,
    #[doc = "< Specifies the active edge of the input signal.\nThis parameter can be a value of @ref TIM_Encoder_Input_Polarity"]
    pub IC2Polarity: u32,
    #[doc = "< Specifies the input.\nThis parameter can be a value of @ref TIM_Input_Capture_Selection"]
    pub IC2Selection: u32,
    #[doc = "< Specifies the Input Capture Prescaler.\nThis parameter can be a value of @ref TIM_Input_Capture_Prescaler"]
    pub IC2Prescaler: u32,
    #[doc = "< Specifies the input capture filter.\nThis parameter can be a number between Min_Data = 0x0 and Max_Data = 0xF"]
    pub IC2Filter: u32,
}
#[test]
fn bindgen_test_layout_TIM_Encoder_InitTypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<TIM_Encoder_InitTypeDef> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TIM_Encoder_InitTypeDef>(),
        36usize,
        concat!("Size of: ", stringify!(TIM_Encoder_InitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<TIM_Encoder_InitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(TIM_Encoder_InitTypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EncoderMode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_Encoder_InitTypeDef),
            "::",
            stringify!(EncoderMode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).IC1Polarity) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_Encoder_InitTypeDef),
            "::",
            stringify!(IC1Polarity)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).IC1Selection) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_Encoder_InitTypeDef),
            "::",
            stringify!(IC1Selection)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).IC1Prescaler) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_Encoder_InitTypeDef),
            "::",
            stringify!(IC1Prescaler)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).IC1Filter) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_Encoder_InitTypeDef),
            "::",
            stringify!(IC1Filter)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).IC2Polarity) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_Encoder_InitTypeDef),
            "::",
            stringify!(IC2Polarity)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).IC2Selection) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_Encoder_InitTypeDef),
            "::",
            stringify!(IC2Selection)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).IC2Prescaler) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_Encoder_InitTypeDef),
            "::",
            stringify!(IC2Prescaler)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).IC2Filter) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_Encoder_InitTypeDef),
            "::",
            stringify!(IC2Filter)
        )
    );
}
#[doc = " @brief  Clock Configuration Handle Structure definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TIM_ClockConfigTypeDef {
    #[doc = "< TIM clock sources\nThis parameter can be a value of @ref TIM_Clock_Source"]
    pub ClockSource: u32,
    #[doc = "< TIM clock polarity\nThis parameter can be a value of @ref TIM_Clock_Polarity"]
    pub ClockPolarity: u32,
    #[doc = "< TIM clock prescaler\nThis parameter can be a value of @ref TIM_Clock_Prescaler"]
    pub ClockPrescaler: u32,
    #[doc = "< TIM clock filter\nThis parameter can be a number between Min_Data = 0x0 and Max_Data = 0xF"]
    pub ClockFilter: u32,
}
#[test]
fn bindgen_test_layout_TIM_ClockConfigTypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<TIM_ClockConfigTypeDef> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TIM_ClockConfigTypeDef>(),
        16usize,
        concat!("Size of: ", stringify!(TIM_ClockConfigTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<TIM_ClockConfigTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(TIM_ClockConfigTypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ClockSource) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_ClockConfigTypeDef),
            "::",
            stringify!(ClockSource)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ClockPolarity) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_ClockConfigTypeDef),
            "::",
            stringify!(ClockPolarity)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ClockPrescaler) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_ClockConfigTypeDef),
            "::",
            stringify!(ClockPrescaler)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ClockFilter) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_ClockConfigTypeDef),
            "::",
            stringify!(ClockFilter)
        )
    );
}
#[doc = " @brief  TIM Clear Input Configuration Handle Structure definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TIM_ClearInputConfigTypeDef {
    #[doc = "< TIM clear Input state\nThis parameter can be ENABLE or DISABLE"]
    pub ClearInputState: u32,
    #[doc = "< TIM clear Input sources\nThis parameter can be a value of @ref TIM_ClearInput_Source"]
    pub ClearInputSource: u32,
    #[doc = "< TIM Clear Input polarity\nThis parameter can be a value of @ref TIM_ClearInput_Polarity"]
    pub ClearInputPolarity: u32,
    #[doc = "< TIM Clear Input prescaler\nThis parameter must be 0: When OCRef clear feature is used with ETR source, ETR prescaler must be off"]
    pub ClearInputPrescaler: u32,
    #[doc = "< TIM Clear Input filter\nThis parameter can be a number between Min_Data = 0x0 and Max_Data = 0xF"]
    pub ClearInputFilter: u32,
}
#[test]
fn bindgen_test_layout_TIM_ClearInputConfigTypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<TIM_ClearInputConfigTypeDef> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TIM_ClearInputConfigTypeDef>(),
        20usize,
        concat!("Size of: ", stringify!(TIM_ClearInputConfigTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<TIM_ClearInputConfigTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(TIM_ClearInputConfigTypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ClearInputState) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_ClearInputConfigTypeDef),
            "::",
            stringify!(ClearInputState)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ClearInputSource) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_ClearInputConfigTypeDef),
            "::",
            stringify!(ClearInputSource)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ClearInputPolarity) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_ClearInputConfigTypeDef),
            "::",
            stringify!(ClearInputPolarity)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ClearInputPrescaler) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_ClearInputConfigTypeDef),
            "::",
            stringify!(ClearInputPrescaler)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ClearInputFilter) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_ClearInputConfigTypeDef),
            "::",
            stringify!(ClearInputFilter)
        )
    );
}
#[doc = " @brief  TIM Master configuration Structure definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TIM_MasterConfigTypeDef {
    #[doc = "< Trigger output (TRGO) selection\nThis parameter can be a value of @ref TIM_Master_Mode_Selection"]
    pub MasterOutputTrigger: u32,
    #[doc = "< Master/slave mode selection\nThis parameter can be a value of @ref TIM_Master_Slave_Mode\n@note When the Master/slave mode is enabled, the effect of\nan event on the trigger input (TRGI) is delayed to allow a\nperfect synchronization between the current timer and its\nslaves (through TRGO). It is not mandatory in case of timer\nsynchronization mode."]
    pub MasterSlaveMode: u32,
}
#[test]
fn bindgen_test_layout_TIM_MasterConfigTypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<TIM_MasterConfigTypeDef> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TIM_MasterConfigTypeDef>(),
        8usize,
        concat!("Size of: ", stringify!(TIM_MasterConfigTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<TIM_MasterConfigTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(TIM_MasterConfigTypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MasterOutputTrigger) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_MasterConfigTypeDef),
            "::",
            stringify!(MasterOutputTrigger)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MasterSlaveMode) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_MasterConfigTypeDef),
            "::",
            stringify!(MasterSlaveMode)
        )
    );
}
#[doc = " @brief  TIM Slave configuration Structure definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TIM_SlaveConfigTypeDef {
    #[doc = "< Slave mode selection\nThis parameter can be a value of @ref TIM_Slave_Mode"]
    pub SlaveMode: u32,
    #[doc = "< Input Trigger source\nThis parameter can be a value of @ref TIM_Trigger_Selection"]
    pub InputTrigger: u32,
    #[doc = "< Input Trigger polarity\nThis parameter can be a value of @ref TIM_Trigger_Polarity"]
    pub TriggerPolarity: u32,
    #[doc = "< Input trigger prescaler\nThis parameter can be a value of @ref TIM_Trigger_Prescaler"]
    pub TriggerPrescaler: u32,
    #[doc = "< Input trigger filter\nThis parameter can be a number between Min_Data = 0x0 and Max_Data = 0xF"]
    pub TriggerFilter: u32,
}
#[test]
fn bindgen_test_layout_TIM_SlaveConfigTypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<TIM_SlaveConfigTypeDef> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TIM_SlaveConfigTypeDef>(),
        20usize,
        concat!("Size of: ", stringify!(TIM_SlaveConfigTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<TIM_SlaveConfigTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(TIM_SlaveConfigTypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SlaveMode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_SlaveConfigTypeDef),
            "::",
            stringify!(SlaveMode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).InputTrigger) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_SlaveConfigTypeDef),
            "::",
            stringify!(InputTrigger)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TriggerPolarity) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_SlaveConfigTypeDef),
            "::",
            stringify!(TriggerPolarity)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TriggerPrescaler) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_SlaveConfigTypeDef),
            "::",
            stringify!(TriggerPrescaler)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TriggerFilter) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_SlaveConfigTypeDef),
            "::",
            stringify!(TriggerFilter)
        )
    );
}
#[doc = " @brief  TIM Break input(s) and Dead time configuration Structure definition\n @note   2 break inputs can be configured (BKIN and BKIN2) with configurable\n        filter and polarity."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TIM_BreakDeadTimeConfigTypeDef {
    #[doc = "< TIM off state in run mode\nThis parameter can be a value of @ref TIM_OSSR_Off_State_Selection_for_Run_mode_state"]
    pub OffStateRunMode: u32,
    #[doc = "< TIM off state in IDLE mode\nThis parameter can be a value of @ref TIM_OSSI_Off_State_Selection_for_Idle_mode_state"]
    pub OffStateIDLEMode: u32,
    #[doc = "< TIM Lock level\nThis parameter can be a value of @ref TIM_Lock_level"]
    pub LockLevel: u32,
    #[doc = "< TIM dead Time\nThis parameter can be a number between Min_Data = 0x00 and Max_Data = 0xFF"]
    pub DeadTime: u32,
    #[doc = "< TIM Break State\nThis parameter can be a value of @ref TIM_Break_Input_enable_disable"]
    pub BreakState: u32,
    #[doc = "< TIM Break input polarity\nThis parameter can be a value of @ref TIM_Break_Polarity"]
    pub BreakPolarity: u32,
    #[doc = "< Specifies the break input filter.\nThis parameter can be a number between Min_Data = 0x0 and Max_Data = 0xF"]
    pub BreakFilter: u32,
    #[doc = "< TIM Automatic Output Enable state\nThis parameter can be a value of @ref TIM_AOE_Bit_Set_Reset"]
    pub AutomaticOutput: u32,
}
#[test]
fn bindgen_test_layout_TIM_BreakDeadTimeConfigTypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<TIM_BreakDeadTimeConfigTypeDef> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TIM_BreakDeadTimeConfigTypeDef>(),
        32usize,
        concat!("Size of: ", stringify!(TIM_BreakDeadTimeConfigTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<TIM_BreakDeadTimeConfigTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(TIM_BreakDeadTimeConfigTypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OffStateRunMode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_BreakDeadTimeConfigTypeDef),
            "::",
            stringify!(OffStateRunMode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OffStateIDLEMode) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_BreakDeadTimeConfigTypeDef),
            "::",
            stringify!(OffStateIDLEMode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LockLevel) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_BreakDeadTimeConfigTypeDef),
            "::",
            stringify!(LockLevel)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DeadTime) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_BreakDeadTimeConfigTypeDef),
            "::",
            stringify!(DeadTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BreakState) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_BreakDeadTimeConfigTypeDef),
            "::",
            stringify!(BreakState)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BreakPolarity) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_BreakDeadTimeConfigTypeDef),
            "::",
            stringify!(BreakPolarity)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BreakFilter) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_BreakDeadTimeConfigTypeDef),
            "::",
            stringify!(BreakFilter)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AutomaticOutput) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_BreakDeadTimeConfigTypeDef),
            "::",
            stringify!(AutomaticOutput)
        )
    );
}
#[doc = "< Peripheral not yet initialized or disabled"]
pub const HAL_TIM_StateTypeDef_HAL_TIM_STATE_RESET: HAL_TIM_StateTypeDef = 0;
#[doc = "< Peripheral Initialized and ready for use"]
pub const HAL_TIM_StateTypeDef_HAL_TIM_STATE_READY: HAL_TIM_StateTypeDef = 1;
#[doc = "< An internal process is ongoing"]
pub const HAL_TIM_StateTypeDef_HAL_TIM_STATE_BUSY: HAL_TIM_StateTypeDef = 2;
#[doc = "< Timeout state"]
pub const HAL_TIM_StateTypeDef_HAL_TIM_STATE_TIMEOUT: HAL_TIM_StateTypeDef = 3;
#[doc = "< Reception process is ongoing"]
pub const HAL_TIM_StateTypeDef_HAL_TIM_STATE_ERROR: HAL_TIM_StateTypeDef = 4;
#[doc = " @brief  HAL State structures definition"]
pub type HAL_TIM_StateTypeDef = ::core::ffi::c_uint;
#[doc = "< The active channel is 1"]
pub const HAL_TIM_ActiveChannel_HAL_TIM_ACTIVE_CHANNEL_1: HAL_TIM_ActiveChannel = 1;
#[doc = "< The active channel is 2"]
pub const HAL_TIM_ActiveChannel_HAL_TIM_ACTIVE_CHANNEL_2: HAL_TIM_ActiveChannel = 2;
#[doc = "< The active channel is 3"]
pub const HAL_TIM_ActiveChannel_HAL_TIM_ACTIVE_CHANNEL_3: HAL_TIM_ActiveChannel = 4;
#[doc = "< The active channel is 4"]
pub const HAL_TIM_ActiveChannel_HAL_TIM_ACTIVE_CHANNEL_4: HAL_TIM_ActiveChannel = 8;
#[doc = "< All active channels cleared"]
pub const HAL_TIM_ActiveChannel_HAL_TIM_ACTIVE_CHANNEL_CLEARED: HAL_TIM_ActiveChannel = 0;
#[doc = " @brief  HAL Active channel structures definition"]
pub type HAL_TIM_ActiveChannel = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TIM_HandleTypeDef {
    #[doc = "< Register base address"]
    pub Instance: *mut TIM_TypeDef,
    #[doc = "< TIM Time Base required parameters"]
    pub Init: TIM_Base_InitTypeDef,
    #[doc = "< Active channel"]
    pub Channel: HAL_TIM_ActiveChannel,
    #[doc = "< DMA Handlers array\nThis array is accessed by a @ref DMA_Handle_index"]
    pub hdma: [*mut DMA_HandleTypeDef; 7usize],
    #[doc = "< Locking object"]
    pub Lock: HAL_LockTypeDef,
    #[doc = "< TIM operation state"]
    pub State: HAL_TIM_StateTypeDef,
}
#[test]
fn bindgen_test_layout_TIM_HandleTypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<TIM_HandleTypeDef> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TIM_HandleTypeDef>(),
        68usize,
        concat!("Size of: ", stringify!(TIM_HandleTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<TIM_HandleTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(TIM_HandleTypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_HandleTypeDef),
            "::",
            stringify!(Instance)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Init) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_HandleTypeDef),
            "::",
            stringify!(Init)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Channel) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_HandleTypeDef),
            "::",
            stringify!(Channel)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hdma) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_HandleTypeDef),
            "::",
            stringify!(hdma)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Lock) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_HandleTypeDef),
            "::",
            stringify!(Lock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).State) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_HandleTypeDef),
            "::",
            stringify!(State)
        )
    );
}
#[doc = " @brief  TIM Hall sensor Configuration Structure definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TIM_HallSensor_InitTypeDef {
    #[doc = "< Specifies the active edge of the input signal.\nThis parameter can be a value of @ref TIM_Input_Capture_Polarity"]
    pub IC1Polarity: u32,
    #[doc = "< Specifies the Input Capture Prescaler.\nThis parameter can be a value of @ref TIM_Input_Capture_Prescaler"]
    pub IC1Prescaler: u32,
    #[doc = "< Specifies the input capture filter.\nThis parameter can be a number between Min_Data = 0x0 and Max_Data = 0xF"]
    pub IC1Filter: u32,
    #[doc = "< Specifies the pulse value to be loaded into the Capture Compare Register.\nThis parameter can be a number between Min_Data = 0x0000 and Max_Data = 0xFFFF"]
    pub Commutation_Delay: u32,
}
#[test]
fn bindgen_test_layout_TIM_HallSensor_InitTypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<TIM_HallSensor_InitTypeDef> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TIM_HallSensor_InitTypeDef>(),
        16usize,
        concat!("Size of: ", stringify!(TIM_HallSensor_InitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<TIM_HallSensor_InitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(TIM_HallSensor_InitTypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).IC1Polarity) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_HallSensor_InitTypeDef),
            "::",
            stringify!(IC1Polarity)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).IC1Prescaler) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_HallSensor_InitTypeDef),
            "::",
            stringify!(IC1Prescaler)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).IC1Filter) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_HallSensor_InitTypeDef),
            "::",
            stringify!(IC1Filter)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Commutation_Delay) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_HallSensor_InitTypeDef),
            "::",
            stringify!(Commutation_Delay)
        )
    );
}
extern "C" {
    #[doc = " @addtogroup TIMEx_Exported_Functions_Group1 Extended Timer Hall Sensor functions\n  @brief    Timer Hall Sensor functions\n @{"]
    pub fn HAL_TIMEx_HallSensor_Init(
        htim: *mut TIM_HandleTypeDef,
        sConfig: *mut TIM_HallSensor_InitTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIMEx_HallSensor_DeInit(htim: *mut TIM_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIMEx_HallSensor_MspInit(htim: *mut TIM_HandleTypeDef);
}
extern "C" {
    pub fn HAL_TIMEx_HallSensor_MspDeInit(htim: *mut TIM_HandleTypeDef);
}
extern "C" {
    pub fn HAL_TIMEx_HallSensor_Start(htim: *mut TIM_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIMEx_HallSensor_Stop(htim: *mut TIM_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIMEx_HallSensor_Start_IT(htim: *mut TIM_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIMEx_HallSensor_Stop_IT(htim: *mut TIM_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIMEx_HallSensor_Start_DMA(
        htim: *mut TIM_HandleTypeDef,
        pData: *mut u32,
        Length: u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIMEx_HallSensor_Stop_DMA(htim: *mut TIM_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    #[doc = " @addtogroup TIMEx_Exported_Functions_Group2 Extended Timer Complementary Output Compare functions\n  @brief   Timer Complementary Output Compare functions\n @{"]
    pub fn HAL_TIMEx_OCN_Start(htim: *mut TIM_HandleTypeDef, Channel: u32) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIMEx_OCN_Stop(htim: *mut TIM_HandleTypeDef, Channel: u32) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIMEx_OCN_Start_IT(htim: *mut TIM_HandleTypeDef, Channel: u32) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIMEx_OCN_Stop_IT(htim: *mut TIM_HandleTypeDef, Channel: u32) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIMEx_OCN_Start_DMA(
        htim: *mut TIM_HandleTypeDef,
        Channel: u32,
        pData: *mut u32,
        Length: u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIMEx_OCN_Stop_DMA(htim: *mut TIM_HandleTypeDef, Channel: u32) -> HAL_StatusTypeDef;
}
extern "C" {
    #[doc = " @addtogroup TIMEx_Exported_Functions_Group3 Extended Timer Complementary PWM functions\n  @brief    Timer Complementary PWM functions\n @{"]
    pub fn HAL_TIMEx_PWMN_Start(htim: *mut TIM_HandleTypeDef, Channel: u32) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIMEx_PWMN_Stop(htim: *mut TIM_HandleTypeDef, Channel: u32) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIMEx_PWMN_Start_IT(htim: *mut TIM_HandleTypeDef, Channel: u32)
        -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIMEx_PWMN_Stop_IT(htim: *mut TIM_HandleTypeDef, Channel: u32) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIMEx_PWMN_Start_DMA(
        htim: *mut TIM_HandleTypeDef,
        Channel: u32,
        pData: *mut u32,
        Length: u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIMEx_PWMN_Stop_DMA(htim: *mut TIM_HandleTypeDef, Channel: u32)
        -> HAL_StatusTypeDef;
}
extern "C" {
    #[doc = " @addtogroup TIMEx_Exported_Functions_Group4 Extended Timer Complementary One Pulse functions\n  @brief    Timer Complementary One Pulse functions\n @{"]
    pub fn HAL_TIMEx_OnePulseN_Start(
        htim: *mut TIM_HandleTypeDef,
        OutputChannel: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIMEx_OnePulseN_Stop(
        htim: *mut TIM_HandleTypeDef,
        OutputChannel: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIMEx_OnePulseN_Start_IT(
        htim: *mut TIM_HandleTypeDef,
        OutputChannel: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIMEx_OnePulseN_Stop_IT(
        htim: *mut TIM_HandleTypeDef,
        OutputChannel: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    #[doc = " @addtogroup TIMEx_Exported_Functions_Group5 Extended Peripheral Control functions\n  @brief    Peripheral Control functions\n @{"]
    pub fn HAL_TIMEx_ConfigCommutEvent(
        htim: *mut TIM_HandleTypeDef,
        InputTrigger: u32,
        CommutationSource: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIMEx_ConfigCommutEvent_IT(
        htim: *mut TIM_HandleTypeDef,
        InputTrigger: u32,
        CommutationSource: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIMEx_ConfigCommutEvent_DMA(
        htim: *mut TIM_HandleTypeDef,
        InputTrigger: u32,
        CommutationSource: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIMEx_MasterConfigSynchronization(
        htim: *mut TIM_HandleTypeDef,
        sMasterConfig: *mut TIM_MasterConfigTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIMEx_ConfigBreakDeadTime(
        htim: *mut TIM_HandleTypeDef,
        sBreakDeadTimeConfig: *mut TIM_BreakDeadTimeConfigTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIMEx_RemapConfig(htim: *mut TIM_HandleTypeDef, Remap: u32) -> HAL_StatusTypeDef;
}
extern "C" {
    #[doc = " @addtogroup TIMEx_Exported_Functions_Group6 Extended Callbacks functions\n @brief    Extended Callbacks functions\n @{"]
    pub fn HAL_TIMEx_CommutCallback(htim: *mut TIM_HandleTypeDef);
}
extern "C" {
    pub fn HAL_TIMEx_CommutHalfCpltCallback(htim: *mut TIM_HandleTypeDef);
}
extern "C" {
    pub fn HAL_TIMEx_BreakCallback(htim: *mut TIM_HandleTypeDef);
}
extern "C" {
    #[doc = " @addtogroup TIMEx_Exported_Functions_Group7 Extended Peripheral State functions\n @brief    Extended Peripheral State functions\n @{"]
    pub fn HAL_TIMEx_HallSensor_GetState(htim: *mut TIM_HandleTypeDef) -> HAL_TIM_StateTypeDef;
}
extern "C" {
    pub fn TIMEx_DMACommutationCplt(hdma: *mut DMA_HandleTypeDef);
}
extern "C" {
    pub fn TIMEx_DMACommutationHalfCplt(hdma: *mut DMA_HandleTypeDef);
}
extern "C" {
    #[doc = " @addtogroup TIM_Exported_Functions_Group1 TIM Time Base functions\n  @brief   Time Base functions\n @{"]
    pub fn HAL_TIM_Base_Init(htim: *mut TIM_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_Base_DeInit(htim: *mut TIM_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_Base_MspInit(htim: *mut TIM_HandleTypeDef);
}
extern "C" {
    pub fn HAL_TIM_Base_MspDeInit(htim: *mut TIM_HandleTypeDef);
}
extern "C" {
    pub fn HAL_TIM_Base_Start(htim: *mut TIM_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_Base_Stop(htim: *mut TIM_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_Base_Start_IT(htim: *mut TIM_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_Base_Stop_IT(htim: *mut TIM_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_Base_Start_DMA(
        htim: *mut TIM_HandleTypeDef,
        pData: *mut u32,
        Length: u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_Base_Stop_DMA(htim: *mut TIM_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    #[doc = " @addtogroup TIM_Exported_Functions_Group2 TIM Output Compare functions\n  @brief   TIM Output Compare functions\n @{"]
    pub fn HAL_TIM_OC_Init(htim: *mut TIM_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_OC_DeInit(htim: *mut TIM_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_OC_MspInit(htim: *mut TIM_HandleTypeDef);
}
extern "C" {
    pub fn HAL_TIM_OC_MspDeInit(htim: *mut TIM_HandleTypeDef);
}
extern "C" {
    pub fn HAL_TIM_OC_Start(htim: *mut TIM_HandleTypeDef, Channel: u32) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_OC_Stop(htim: *mut TIM_HandleTypeDef, Channel: u32) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_OC_Start_IT(htim: *mut TIM_HandleTypeDef, Channel: u32) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_OC_Stop_IT(htim: *mut TIM_HandleTypeDef, Channel: u32) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_OC_Start_DMA(
        htim: *mut TIM_HandleTypeDef,
        Channel: u32,
        pData: *mut u32,
        Length: u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_OC_Stop_DMA(htim: *mut TIM_HandleTypeDef, Channel: u32) -> HAL_StatusTypeDef;
}
extern "C" {
    #[doc = " @addtogroup TIM_Exported_Functions_Group3 TIM PWM functions\n  @brief   TIM PWM functions\n @{"]
    pub fn HAL_TIM_PWM_Init(htim: *mut TIM_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_PWM_DeInit(htim: *mut TIM_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_PWM_MspInit(htim: *mut TIM_HandleTypeDef);
}
extern "C" {
    pub fn HAL_TIM_PWM_MspDeInit(htim: *mut TIM_HandleTypeDef);
}
extern "C" {
    pub fn HAL_TIM_PWM_Start(htim: *mut TIM_HandleTypeDef, Channel: u32) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_PWM_Stop(htim: *mut TIM_HandleTypeDef, Channel: u32) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_PWM_Start_IT(htim: *mut TIM_HandleTypeDef, Channel: u32) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_PWM_Stop_IT(htim: *mut TIM_HandleTypeDef, Channel: u32) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_PWM_Start_DMA(
        htim: *mut TIM_HandleTypeDef,
        Channel: u32,
        pData: *mut u32,
        Length: u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_PWM_Stop_DMA(htim: *mut TIM_HandleTypeDef, Channel: u32) -> HAL_StatusTypeDef;
}
extern "C" {
    #[doc = " @addtogroup TIM_Exported_Functions_Group4 TIM Input Capture functions\n  @brief   TIM Input Capture functions\n @{"]
    pub fn HAL_TIM_IC_Init(htim: *mut TIM_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_IC_DeInit(htim: *mut TIM_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_IC_MspInit(htim: *mut TIM_HandleTypeDef);
}
extern "C" {
    pub fn HAL_TIM_IC_MspDeInit(htim: *mut TIM_HandleTypeDef);
}
extern "C" {
    pub fn HAL_TIM_IC_Start(htim: *mut TIM_HandleTypeDef, Channel: u32) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_IC_Stop(htim: *mut TIM_HandleTypeDef, Channel: u32) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_IC_Start_IT(htim: *mut TIM_HandleTypeDef, Channel: u32) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_IC_Stop_IT(htim: *mut TIM_HandleTypeDef, Channel: u32) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_IC_Start_DMA(
        htim: *mut TIM_HandleTypeDef,
        Channel: u32,
        pData: *mut u32,
        Length: u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_IC_Stop_DMA(htim: *mut TIM_HandleTypeDef, Channel: u32) -> HAL_StatusTypeDef;
}
extern "C" {
    #[doc = " @addtogroup TIM_Exported_Functions_Group5 TIM One Pulse functions\n  @brief   TIM One Pulse functions\n @{"]
    pub fn HAL_TIM_OnePulse_Init(
        htim: *mut TIM_HandleTypeDef,
        OnePulseMode: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_OnePulse_DeInit(htim: *mut TIM_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_OnePulse_MspInit(htim: *mut TIM_HandleTypeDef);
}
extern "C" {
    pub fn HAL_TIM_OnePulse_MspDeInit(htim: *mut TIM_HandleTypeDef);
}
extern "C" {
    pub fn HAL_TIM_OnePulse_Start(
        htim: *mut TIM_HandleTypeDef,
        OutputChannel: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_OnePulse_Stop(
        htim: *mut TIM_HandleTypeDef,
        OutputChannel: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_OnePulse_Start_IT(
        htim: *mut TIM_HandleTypeDef,
        OutputChannel: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_OnePulse_Stop_IT(
        htim: *mut TIM_HandleTypeDef,
        OutputChannel: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    #[doc = " @addtogroup TIM_Exported_Functions_Group6 TIM Encoder functions\n  @brief   TIM Encoder functions\n @{"]
    pub fn HAL_TIM_Encoder_Init(
        htim: *mut TIM_HandleTypeDef,
        sConfig: *mut TIM_Encoder_InitTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_Encoder_DeInit(htim: *mut TIM_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_Encoder_MspInit(htim: *mut TIM_HandleTypeDef);
}
extern "C" {
    pub fn HAL_TIM_Encoder_MspDeInit(htim: *mut TIM_HandleTypeDef);
}
extern "C" {
    pub fn HAL_TIM_Encoder_Start(htim: *mut TIM_HandleTypeDef, Channel: u32) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_Encoder_Stop(htim: *mut TIM_HandleTypeDef, Channel: u32) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_Encoder_Start_IT(
        htim: *mut TIM_HandleTypeDef,
        Channel: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_Encoder_Stop_IT(htim: *mut TIM_HandleTypeDef, Channel: u32)
        -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_Encoder_Start_DMA(
        htim: *mut TIM_HandleTypeDef,
        Channel: u32,
        pData1: *mut u32,
        pData2: *mut u32,
        Length: u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_Encoder_Stop_DMA(
        htim: *mut TIM_HandleTypeDef,
        Channel: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    #[doc = " @addtogroup TIM_Exported_Functions_Group7 TIM IRQ handler management\n  @brief   IRQ handler management\n @{"]
    pub fn HAL_TIM_IRQHandler(htim: *mut TIM_HandleTypeDef);
}
extern "C" {
    #[doc = " @defgroup TIM_Exported_Functions_Group8 TIM Peripheral Control functions\n  @brief   Peripheral Control functions\n @{"]
    pub fn HAL_TIM_OC_ConfigChannel(
        htim: *mut TIM_HandleTypeDef,
        sConfig: *mut TIM_OC_InitTypeDef,
        Channel: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_PWM_ConfigChannel(
        htim: *mut TIM_HandleTypeDef,
        sConfig: *mut TIM_OC_InitTypeDef,
        Channel: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_IC_ConfigChannel(
        htim: *mut TIM_HandleTypeDef,
        sConfig: *mut TIM_IC_InitTypeDef,
        Channel: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_OnePulse_ConfigChannel(
        htim: *mut TIM_HandleTypeDef,
        sConfig: *mut TIM_OnePulse_InitTypeDef,
        OutputChannel: u32,
        InputChannel: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_ConfigOCrefClear(
        htim: *mut TIM_HandleTypeDef,
        sClearInputConfig: *mut TIM_ClearInputConfigTypeDef,
        Channel: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_ConfigClockSource(
        htim: *mut TIM_HandleTypeDef,
        sClockSourceConfig: *mut TIM_ClockConfigTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_ConfigTI1Input(
        htim: *mut TIM_HandleTypeDef,
        TI1_Selection: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_SlaveConfigSynchro(
        htim: *mut TIM_HandleTypeDef,
        sSlaveConfig: *mut TIM_SlaveConfigTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_SlaveConfigSynchro_IT(
        htim: *mut TIM_HandleTypeDef,
        sSlaveConfig: *mut TIM_SlaveConfigTypeDef,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_DMABurst_WriteStart(
        htim: *mut TIM_HandleTypeDef,
        BurstBaseAddress: u32,
        BurstRequestSrc: u32,
        BurstBuffer: *mut u32,
        BurstLength: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_DMABurst_MultiWriteStart(
        htim: *mut TIM_HandleTypeDef,
        BurstBaseAddress: u32,
        BurstRequestSrc: u32,
        BurstBuffer: *mut u32,
        BurstLength: u32,
        DataLength: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_DMABurst_WriteStop(
        htim: *mut TIM_HandleTypeDef,
        BurstRequestSrc: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_DMABurst_ReadStart(
        htim: *mut TIM_HandleTypeDef,
        BurstBaseAddress: u32,
        BurstRequestSrc: u32,
        BurstBuffer: *mut u32,
        BurstLength: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_DMABurst_MultiReadStart(
        htim: *mut TIM_HandleTypeDef,
        BurstBaseAddress: u32,
        BurstRequestSrc: u32,
        BurstBuffer: *mut u32,
        BurstLength: u32,
        DataLength: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_DMABurst_ReadStop(
        htim: *mut TIM_HandleTypeDef,
        BurstRequestSrc: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_GenerateEvent(
        htim: *mut TIM_HandleTypeDef,
        EventSource: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_TIM_ReadCapturedValue(htim: *mut TIM_HandleTypeDef, Channel: u32) -> u32;
}
extern "C" {
    #[doc = " @defgroup TIM_Exported_Functions_Group9 TIM Callbacks functions\n  @brief   TIM Callbacks functions\n @{"]
    pub fn HAL_TIM_PeriodElapsedCallback(htim: *mut TIM_HandleTypeDef);
}
extern "C" {
    pub fn HAL_TIM_PeriodElapsedHalfCpltCallback(htim: *mut TIM_HandleTypeDef);
}
extern "C" {
    pub fn HAL_TIM_OC_DelayElapsedCallback(htim: *mut TIM_HandleTypeDef);
}
extern "C" {
    pub fn HAL_TIM_IC_CaptureCallback(htim: *mut TIM_HandleTypeDef);
}
extern "C" {
    pub fn HAL_TIM_IC_CaptureHalfCpltCallback(htim: *mut TIM_HandleTypeDef);
}
extern "C" {
    pub fn HAL_TIM_PWM_PulseFinishedCallback(htim: *mut TIM_HandleTypeDef);
}
extern "C" {
    pub fn HAL_TIM_PWM_PulseFinishedHalfCpltCallback(htim: *mut TIM_HandleTypeDef);
}
extern "C" {
    pub fn HAL_TIM_TriggerCallback(htim: *mut TIM_HandleTypeDef);
}
extern "C" {
    pub fn HAL_TIM_TriggerHalfCpltCallback(htim: *mut TIM_HandleTypeDef);
}
extern "C" {
    pub fn HAL_TIM_ErrorCallback(htim: *mut TIM_HandleTypeDef);
}
extern "C" {
    #[doc = " @defgroup TIM_Exported_Functions_Group10 TIM Peripheral State functions\n  @brief  Peripheral State functions\n @{"]
    pub fn HAL_TIM_Base_GetState(htim: *mut TIM_HandleTypeDef) -> HAL_TIM_StateTypeDef;
}
extern "C" {
    pub fn HAL_TIM_OC_GetState(htim: *mut TIM_HandleTypeDef) -> HAL_TIM_StateTypeDef;
}
extern "C" {
    pub fn HAL_TIM_PWM_GetState(htim: *mut TIM_HandleTypeDef) -> HAL_TIM_StateTypeDef;
}
extern "C" {
    pub fn HAL_TIM_IC_GetState(htim: *mut TIM_HandleTypeDef) -> HAL_TIM_StateTypeDef;
}
extern "C" {
    pub fn HAL_TIM_OnePulse_GetState(htim: *mut TIM_HandleTypeDef) -> HAL_TIM_StateTypeDef;
}
extern "C" {
    pub fn HAL_TIM_Encoder_GetState(htim: *mut TIM_HandleTypeDef) -> HAL_TIM_StateTypeDef;
}
extern "C" {
    #[doc = " @defgroup TIM_Private_Functions TIM Private Functions\n @{"]
    pub fn TIM_Base_SetConfig(TIMx: *mut TIM_TypeDef, Structure: *mut TIM_Base_InitTypeDef);
}
extern "C" {
    pub fn TIM_TI1_SetConfig(
        TIMx: *mut TIM_TypeDef,
        TIM_ICPolarity: u32,
        TIM_ICSelection: u32,
        TIM_ICFilter: u32,
    );
}
extern "C" {
    pub fn TIM_OC2_SetConfig(TIMx: *mut TIM_TypeDef, OC_Config: *mut TIM_OC_InitTypeDef);
}
extern "C" {
    pub fn TIM_ETR_SetConfig(
        TIMx: *mut TIM_TypeDef,
        TIM_ExtTRGPrescaler: u32,
        TIM_ExtTRGPolarity: u32,
        ExtTRGFilter: u32,
    );
}
extern "C" {
    pub fn TIM_DMADelayPulseCplt(hdma: *mut DMA_HandleTypeDef);
}
extern "C" {
    pub fn TIM_DMADelayPulseHalfCplt(hdma: *mut DMA_HandleTypeDef);
}
extern "C" {
    pub fn TIM_DMAError(hdma: *mut DMA_HandleTypeDef);
}
extern "C" {
    pub fn TIM_DMACaptureCplt(hdma: *mut DMA_HandleTypeDef);
}
extern "C" {
    pub fn TIM_DMACaptureHalfCplt(hdma: *mut DMA_HandleTypeDef);
}
extern "C" {
    pub fn TIM_CCxChannelCmd(TIMx: *mut TIM_TypeDef, Channel: u32, ChannelState: u32);
}
#[doc = " @brief  LPTIM Initialization Structure definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LPTIM_InitTypeDef {
    #[doc = "< Specifies the counter clock Prescaler.\nThis parameter can be a value of @ref LPTIM_Clock_Prescaler"]
    pub Prescaler: u32,
    #[doc = "< Specifies whether to update immediately or after the end\nof current period.\nThis parameter can be a value of @ref LPTIM_Updating_Mode"]
    pub UpdateMode: u32,
}
#[test]
fn bindgen_test_layout_LPTIM_InitTypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<LPTIM_InitTypeDef> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<LPTIM_InitTypeDef>(),
        8usize,
        concat!("Size of: ", stringify!(LPTIM_InitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<LPTIM_InitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(LPTIM_InitTypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Prescaler) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LPTIM_InitTypeDef),
            "::",
            stringify!(Prescaler)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).UpdateMode) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(LPTIM_InitTypeDef),
            "::",
            stringify!(UpdateMode)
        )
    );
}
#[doc = "< Peripheral not yet initialized or disabled"]
pub const HAL_LPTIM_StateTypeDef_HAL_LPTIM_STATE_RESET: HAL_LPTIM_StateTypeDef = 0;
#[doc = "< Peripheral Initialized and ready for use"]
pub const HAL_LPTIM_StateTypeDef_HAL_LPTIM_STATE_READY: HAL_LPTIM_StateTypeDef = 1;
#[doc = "< An internal process is ongoing"]
pub const HAL_LPTIM_StateTypeDef_HAL_LPTIM_STATE_BUSY: HAL_LPTIM_StateTypeDef = 2;
#[doc = "< Timeout state"]
pub const HAL_LPTIM_StateTypeDef_HAL_LPTIM_STATE_TIMEOUT: HAL_LPTIM_StateTypeDef = 3;
#[doc = "< Internal Process is ongoing"]
pub const HAL_LPTIM_StateTypeDef_HAL_LPTIM_STATE_ERROR: HAL_LPTIM_StateTypeDef = 4;
#[doc = " @brief  HAL LPTIM State structure definition"]
pub type HAL_LPTIM_StateTypeDef = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LPTIM_HandleTypeDef {
    #[doc = "< Register base address"]
    pub Instance: *mut LPTIM_TypeDef,
    #[doc = "< LPTIM required parameters"]
    pub Init: LPTIM_InitTypeDef,
    #[doc = "< LPTIM locking object"]
    pub Lock: HAL_LockTypeDef,
    #[doc = "< LPTIM peripheral state"]
    pub State: HAL_LPTIM_StateTypeDef,
}
#[test]
fn bindgen_test_layout_LPTIM_HandleTypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<LPTIM_HandleTypeDef> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<LPTIM_HandleTypeDef>(),
        20usize,
        concat!("Size of: ", stringify!(LPTIM_HandleTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<LPTIM_HandleTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(LPTIM_HandleTypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LPTIM_HandleTypeDef),
            "::",
            stringify!(Instance)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Init) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(LPTIM_HandleTypeDef),
            "::",
            stringify!(Init)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Lock) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(LPTIM_HandleTypeDef),
            "::",
            stringify!(Lock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).State) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LPTIM_HandleTypeDef),
            "::",
            stringify!(State)
        )
    );
}
extern "C" {
    #[doc = " @defgroup LPTIM_Exported_Functions LPTIM Exported Functions\n @{"]
    pub fn HAL_LPTIM_Init(hlptim: *mut LPTIM_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_LPTIM_DeInit(hlptim: *mut LPTIM_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_LPTIM_MspInit(hlptim: *mut LPTIM_HandleTypeDef);
}
extern "C" {
    pub fn HAL_LPTIM_MspDeInit(hlptim: *mut LPTIM_HandleTypeDef);
}
extern "C" {
    pub fn HAL_LPTIM_SetOnce_Start(
        hlptim: *mut LPTIM_HandleTypeDef,
        Period: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_LPTIM_SetOnce_Stop(hlptim: *mut LPTIM_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_LPTIM_SetOnce_Start_IT(
        hlptim: *mut LPTIM_HandleTypeDef,
        Period: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_LPTIM_SetOnce_Stop_IT(hlptim: *mut LPTIM_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_LPTIM_ReadCounter(hlptim: *mut LPTIM_HandleTypeDef) -> u32;
}
extern "C" {
    pub fn HAL_LPTIM_ReadAutoReload(hlptim: *mut LPTIM_HandleTypeDef) -> u32;
}
extern "C" {
    pub fn HAL_LPTIM_IRQHandler(hlptim: *mut LPTIM_HandleTypeDef);
}
extern "C" {
    pub fn HAL_LPTIM_AutoReloadMatchCallback(hlptim: *mut LPTIM_HandleTypeDef);
}
extern "C" {
    pub fn HAL_LPTIM_GetState(hlptim: *mut LPTIM_HandleTypeDef) -> HAL_LPTIM_StateTypeDef;
}
#[doc = " @brief UART Init Structure definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UART_InitTypeDef {
    #[doc = "< This member configures the UART communication baud rate.\nThe baud rate is computed using the following formula:\n- IntegerDivider = ((PCLKx) / (16 * (huart->Init.BaudRate)))\n- FractionalDivider = ((IntegerDivider - ((uint32_t) IntegerDivider)) * 16) + 0.5"]
    pub BaudRate: u32,
    #[doc = "< Specifies the number of data bits transmitted or received in a frame.\nThis parameter can be a value of @ref UART_Word_Length"]
    pub WordLength: u32,
    #[doc = "< Specifies the number of stop bits transmitted.\nThis parameter can be a value of @ref UART_Stop_Bits"]
    pub StopBits: u32,
    #[doc = "< Specifies the parity mode.\nThis parameter can be a value of @ref UART_Parity\n@note When parity is enabled, the computed parity is inserted\nat the MSB position of the transmitted data (9th bit when\nthe word length is set to 9 data bits; 8th bit when the\nword length is set to 8 data bits)."]
    pub Parity: u32,
    #[doc = "< Specifies whether the Receive or Transmit mode is enabled or disabled.\nThis parameter can be a value of @ref UART_Mode"]
    pub Mode: u32,
    #[doc = "< Specifies whether the hardware flow control mode is enabled or disabled.\nThis parameter can be a value of @ref UART_Hardware_Flow_Control"]
    pub HwFlowCtl: u32,
    #[doc = "< Specifies whether the Over sampling 8 or Over sampling 16.\nThis parameter can be a value of @ref UART_Over_Sampling."]
    pub OverSampling: u32,
}
#[test]
fn bindgen_test_layout_UART_InitTypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<UART_InitTypeDef> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<UART_InitTypeDef>(),
        28usize,
        concat!("Size of: ", stringify!(UART_InitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<UART_InitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(UART_InitTypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BaudRate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UART_InitTypeDef),
            "::",
            stringify!(BaudRate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).WordLength) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(UART_InitTypeDef),
            "::",
            stringify!(WordLength)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StopBits) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(UART_InitTypeDef),
            "::",
            stringify!(StopBits)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Parity) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(UART_InitTypeDef),
            "::",
            stringify!(Parity)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Mode) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(UART_InitTypeDef),
            "::",
            stringify!(Mode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).HwFlowCtl) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(UART_InitTypeDef),
            "::",
            stringify!(HwFlowCtl)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OverSampling) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(UART_InitTypeDef),
            "::",
            stringify!(OverSampling)
        )
    );
}
#[doc = "< Peripheral is not yet Initialized\nValue is allowed for gState and RxState"]
pub const HAL_UART_StateTypeDef_HAL_UART_STATE_RESET: HAL_UART_StateTypeDef = 0;
#[doc = "< Peripheral Initialized and ready for use\nValue is allowed for gState and RxState"]
pub const HAL_UART_StateTypeDef_HAL_UART_STATE_READY: HAL_UART_StateTypeDef = 32;
#[doc = "< an internal process is ongoing\nValue is allowed for gState only"]
pub const HAL_UART_StateTypeDef_HAL_UART_STATE_BUSY: HAL_UART_StateTypeDef = 36;
#[doc = "< Data Transmission process is ongoing\nValue is allowed for gState only"]
pub const HAL_UART_StateTypeDef_HAL_UART_STATE_BUSY_TX: HAL_UART_StateTypeDef = 33;
#[doc = "< Data Reception process is ongoing\nValue is allowed for RxState only"]
pub const HAL_UART_StateTypeDef_HAL_UART_STATE_BUSY_RX: HAL_UART_StateTypeDef = 34;
#[doc = "< Data Transmission and Reception process is ongoing\nNot to be used for neither gState nor RxState.\nValue is result of combination (Or) between gState and RxState values"]
pub const HAL_UART_StateTypeDef_HAL_UART_STATE_BUSY_TX_RX: HAL_UART_StateTypeDef = 35;
#[doc = "< Timeout state\nValue is allowed for gState only"]
pub const HAL_UART_StateTypeDef_HAL_UART_STATE_TIMEOUT: HAL_UART_StateTypeDef = 160;
#[doc = "< Error\nValue is allowed for gState only"]
pub const HAL_UART_StateTypeDef_HAL_UART_STATE_ERROR: HAL_UART_StateTypeDef = 224;
#[doc = " @brief HAL UART State structures definition\n @note  HAL UART State value is a combination of 2 different substates: gState and RxState.\n        - gState contains UART state information related to global Handle management\n          and also information related to Tx operations.\n          gState value coding follow below described bitmap :\n          b7-b6  Error information\n             00 : No Error\n             01 : (Not Used)\n             10 : Timeout\n             11 : Error\n          b5     Peripheral initialization status\n             0  : Reset (Peripheral not initialized)\n             1  : Init done (Peripheral not initialized. HAL UART Init function already called)\n          b4-b3  (not used)\n             xx : Should be set to 00\n          b2     Intrinsic process state\n             0  : Ready\n             1  : Busy (Peripheral busy with some configuration or internal operations)\n          b1     (not used)\n             x  : Should be set to 0\n          b0     Tx state\n             0  : Ready (no Tx operation ongoing)\n             1  : Busy (Tx operation ongoing)\n        - RxState contains information related to Rx operations.\n          RxState value coding follow below described bitmap :\n          b7-b6  (not used)\n             xx : Should be set to 00\n          b5     Peripheral initialization status\n             0  : Reset (Peripheral not initialized)\n             1  : Init done (Peripheral not initialized)\n          b4-b2  (not used)\n            xxx : Should be set to 000\n          b1     Rx state\n             0  : Ready (no Rx operation ongoing)\n             1  : Busy (Rx operation ongoing)\n          b0     (not used)\n             x  : Should be set to 0."]
pub type HAL_UART_StateTypeDef = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UART_AdvFeatureInitTypeDef {
    #[doc = "< Specifies which advanced UART features is initialized. Several\nAdvanced Features may be initialized at the same time .\nThis parameter can be a value of @ref UART_Advanced_Features_Initialization_Type."]
    pub AdvFeatureInit: u32,
    #[doc = "< Specifies whether auto Baud rate detection is enabled.\nThis parameter can be a value of @ref UART_AutoBaudRate_Enable."]
    pub AutoBaudRateEnable: u32,
    #[doc = "< If auto Baud rate detection is enabled, specifies how the rate\ndetection is carried out.\nThis parameter can be a value of @ref UART_AutoBaud_Rate_Mode."]
    pub AutoBaudRateMode: u32,
}
#[test]
fn bindgen_test_layout_UART_AdvFeatureInitTypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<UART_AdvFeatureInitTypeDef> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<UART_AdvFeatureInitTypeDef>(),
        12usize,
        concat!("Size of: ", stringify!(UART_AdvFeatureInitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<UART_AdvFeatureInitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(UART_AdvFeatureInitTypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AdvFeatureInit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UART_AdvFeatureInitTypeDef),
            "::",
            stringify!(AdvFeatureInit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AutoBaudRateEnable) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(UART_AdvFeatureInitTypeDef),
            "::",
            stringify!(AutoBaudRateEnable)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AutoBaudRateMode) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(UART_AdvFeatureInitTypeDef),
            "::",
            stringify!(AutoBaudRateMode)
        )
    );
}
#[doc = " @brief  UART handle Structure definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __UART_HandleTypeDef {
    #[doc = "< UART registers base address"]
    pub Instance: *mut USART_TypeDef,
    #[doc = "< UART communication parameters"]
    pub Init: UART_InitTypeDef,
    #[doc = "< UART Advanced Features initialization parameters"]
    pub AdvancedInit: UART_AdvFeatureInitTypeDef,
    #[doc = "< Pointer to UART Tx transfer Buffer"]
    pub pTxBuffPtr: *mut u8,
    #[doc = "< UART Tx Transfer size"]
    pub TxXferSize: u16,
    #[doc = "< UART Tx Transfer Counter"]
    pub TxXferCount: u16,
    #[doc = "< Pointer to UART Rx transfer Buffer"]
    pub pRxBuffPtr: *mut u8,
    #[doc = "< UART Rx Transfer size"]
    pub RxXferSize: u16,
    #[doc = "< UART Rx Transfer Counter"]
    pub RxXferCount: u16,
    #[doc = "< UART Tx DMA Handle parameters"]
    pub hdmatx: *mut DMA_HandleTypeDef,
    #[doc = "< UART Rx DMA Handle parameters"]
    pub hdmarx: *mut DMA_HandleTypeDef,
    #[doc = "< Locking object"]
    pub Lock: HAL_LockTypeDef,
    #[doc = "< UART state information related to global Handle management\nand also related to Tx operations.\nThis parameter can be a value of @ref HAL_UART_StateTypeDef"]
    pub gState: HAL_UART_StateTypeDef,
    #[doc = "< UART state information related to Rx operations.\nThis parameter can be a value of @ref HAL_UART_StateTypeDef"]
    pub RxState: HAL_UART_StateTypeDef,
    #[doc = "< UART Error code"]
    pub ErrorCode: u32,
}
#[test]
fn bindgen_test_layout___UART_HandleTypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<__UART_HandleTypeDef> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__UART_HandleTypeDef>(),
        84usize,
        concat!("Size of: ", stringify!(__UART_HandleTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<__UART_HandleTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(__UART_HandleTypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__UART_HandleTypeDef),
            "::",
            stringify!(Instance)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Init) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__UART_HandleTypeDef),
            "::",
            stringify!(Init)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AdvancedInit) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__UART_HandleTypeDef),
            "::",
            stringify!(AdvancedInit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pTxBuffPtr) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(__UART_HandleTypeDef),
            "::",
            stringify!(pTxBuffPtr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TxXferSize) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__UART_HandleTypeDef),
            "::",
            stringify!(TxXferSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TxXferCount) as usize - ptr as usize },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(__UART_HandleTypeDef),
            "::",
            stringify!(TxXferCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pRxBuffPtr) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(__UART_HandleTypeDef),
            "::",
            stringify!(pRxBuffPtr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RxXferSize) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__UART_HandleTypeDef),
            "::",
            stringify!(RxXferSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RxXferCount) as usize - ptr as usize },
        58usize,
        concat!(
            "Offset of field: ",
            stringify!(__UART_HandleTypeDef),
            "::",
            stringify!(RxXferCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hdmatx) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(__UART_HandleTypeDef),
            "::",
            stringify!(hdmatx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hdmarx) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__UART_HandleTypeDef),
            "::",
            stringify!(hdmarx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Lock) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(__UART_HandleTypeDef),
            "::",
            stringify!(Lock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gState) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__UART_HandleTypeDef),
            "::",
            stringify!(gState)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RxState) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(__UART_HandleTypeDef),
            "::",
            stringify!(RxState)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ErrorCode) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(__UART_HandleTypeDef),
            "::",
            stringify!(ErrorCode)
        )
    );
}
#[doc = " @brief  UART handle Structure definition"]
pub type UART_HandleTypeDef = __UART_HandleTypeDef;
extern "C" {
    #[doc = " @addtogroup UART_Exported_Functions_Group1 Initialization and de-initialization functions\n @{"]
    pub fn HAL_UART_Init(huart: *mut UART_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_HalfDuplex_Init(huart: *mut UART_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_MultiProcessor_Init(
        huart: *mut UART_HandleTypeDef,
        Address: u8,
        WakeUpMethod: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_UART_DeInit(huart: *mut UART_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_UART_MspInit(huart: *mut UART_HandleTypeDef);
}
extern "C" {
    pub fn HAL_UART_MspDeInit(huart: *mut UART_HandleTypeDef);
}
extern "C" {
    #[doc = " @addtogroup UART_Exported_Functions_Group IO operation functions\n @{"]
    pub fn HAL_UART_Transmit(
        huart: *mut UART_HandleTypeDef,
        pData: *mut u8,
        Size: u16,
        Timeout: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_UART_Receive(
        huart: *mut UART_HandleTypeDef,
        pData: *mut u8,
        Size: u16,
        Timeout: u32,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_UART_Transmit_IT(
        huart: *mut UART_HandleTypeDef,
        pData: *mut u8,
        Size: u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_UART_Receive_IT(
        huart: *mut UART_HandleTypeDef,
        pData: *mut u8,
        Size: u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_UART_Transmit_DMA(
        huart: *mut UART_HandleTypeDef,
        pData: *mut u8,
        Size: u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_UART_Receive_DMA(
        huart: *mut UART_HandleTypeDef,
        pData: *mut u8,
        Size: u16,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_UART_DMAPause(huart: *mut UART_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_UART_DMAResume(huart: *mut UART_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_UART_DMAStop(huart: *mut UART_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_UART_Abort(huart: *mut UART_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_UART_AbortTransmit(huart: *mut UART_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_UART_AbortReceive(huart: *mut UART_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_UART_Abort_IT(huart: *mut UART_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_UART_AbortTransmit_IT(huart: *mut UART_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_UART_AbortReceive_IT(huart: *mut UART_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_UART_IRQHandler(huart: *mut UART_HandleTypeDef);
}
extern "C" {
    pub fn HAL_UART_TxCpltCallback(huart: *mut UART_HandleTypeDef);
}
extern "C" {
    pub fn HAL_UART_TxHalfCpltCallback(huart: *mut UART_HandleTypeDef);
}
extern "C" {
    pub fn HAL_UART_RxCpltCallback(huart: *mut UART_HandleTypeDef);
}
extern "C" {
    pub fn HAL_UART_RxHalfCpltCallback(huart: *mut UART_HandleTypeDef);
}
extern "C" {
    pub fn HAL_UART_ErrorCallback(huart: *mut UART_HandleTypeDef);
}
extern "C" {
    pub fn HAL_UART_AbortCpltCallback(huart: *mut UART_HandleTypeDef);
}
extern "C" {
    pub fn HAL_UART_AbortTransmitCpltCallback(huart: *mut UART_HandleTypeDef);
}
extern "C" {
    pub fn HAL_UART_AbortReceiveCpltCallback(huart: *mut UART_HandleTypeDef);
}
extern "C" {
    pub fn HAL_UART_IdleFrameDetectCpltCallback(huart: *mut UART_HandleTypeDef);
}
extern "C" {
    #[doc = " @addtogroup UART_Exported_Functions_Group3\n @{"]
    pub fn HAL_UART_SendBreak(huart: *mut UART_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_MultiProcessor_EnterMuteMode(huart: *mut UART_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_MultiProcessor_ExitMuteMode(huart: *mut UART_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_HalfDuplex_EnableTransmitter(huart: *mut UART_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_HalfDuplex_EnableReceiver(huart: *mut UART_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    #[doc = " @addtogroup UART_Exported_Functions_Group4\n @{"]
    pub fn HAL_UART_GetState(huart: *mut UART_HandleTypeDef) -> HAL_UART_StateTypeDef;
}
extern "C" {
    pub fn HAL_UART_GetError(huart: *mut UART_HandleTypeDef) -> u32;
}
#[doc = " @brief  WWDG Init structure definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WWDG_InitTypeDef {
    #[doc = "< Specifies the prescaler value of the WWDG.\nThis parameter can be a value of @ref WWDG_Prescaler"]
    pub Prescaler: u32,
    #[doc = "< Specifies the WWDG window value to be compared to the downcounter.\nThis parameter must be a number Min_Data = 0x40 and Max_Data = 0x7F"]
    pub Window: u32,
    #[doc = "< Specifies the WWDG free-running downcounter  value.\nThis parameter must be a number between Min_Data = 0x40 and Max_Data = 0x7F"]
    pub Counter: u32,
    #[doc = "< Specifies if WWDG Early Wakeup Interupt is enable or not.\nThis parameter can be a value of @ref WWDG_EWI_Mode"]
    pub EWIMode: u32,
}
#[test]
fn bindgen_test_layout_WWDG_InitTypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<WWDG_InitTypeDef> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<WWDG_InitTypeDef>(),
        16usize,
        concat!("Size of: ", stringify!(WWDG_InitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<WWDG_InitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(WWDG_InitTypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Prescaler) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WWDG_InitTypeDef),
            "::",
            stringify!(Prescaler)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Window) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(WWDG_InitTypeDef),
            "::",
            stringify!(Window)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Counter) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(WWDG_InitTypeDef),
            "::",
            stringify!(Counter)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EWIMode) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(WWDG_InitTypeDef),
            "::",
            stringify!(EWIMode)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WWDG_HandleTypeDef {
    #[doc = "< Register base address"]
    pub Instance: *mut WWDG_TypeDef,
    #[doc = "< WWDG required parameters"]
    pub Init: WWDG_InitTypeDef,
}
#[test]
fn bindgen_test_layout_WWDG_HandleTypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<WWDG_HandleTypeDef> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<WWDG_HandleTypeDef>(),
        20usize,
        concat!("Size of: ", stringify!(WWDG_HandleTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<WWDG_HandleTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(WWDG_HandleTypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WWDG_HandleTypeDef),
            "::",
            stringify!(Instance)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Init) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(WWDG_HandleTypeDef),
            "::",
            stringify!(Init)
        )
    );
}
extern "C" {
    #[doc = " @addtogroup WWDG_Exported_Functions_Group1\n @{"]
    pub fn HAL_WWDG_Init(hwwdg: *mut WWDG_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_WWDG_MspInit(hwwdg: *mut WWDG_HandleTypeDef);
}
extern "C" {
    #[doc = " @addtogroup WWDG_Exported_Functions_Group2\n @{"]
    pub fn HAL_WWDG_Refresh(hwwdg: *mut WWDG_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_WWDG_IRQHandler(hwwdg: *mut WWDG_HandleTypeDef);
}
extern "C" {
    pub fn HAL_WWDG_EarlyWakeupCallback(hwwdg: *mut WWDG_HandleTypeDef);
}
#[doc = " @brief LED Init Structure definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LED_InitTypeDef {
    #[doc = "< Specifies the LED COM drive capability.\nThis parameter can be a value of @ref LED_COMDrive"]
    pub ComDrive: u32,
    #[doc = "< Specifies the prescaler value used to divide the LED clock.\nThis parameter can be a number between Min_Data = 0x00(div1) and Max_Data = 0xFF(div256)"]
    pub Prescaler: u32,
    #[doc = "< Specifies the number of COM open.\nThis parameter can be a number between Min_Data = 0(1COM) and Max_Data = 3(4COM)"]
    pub ComNum: u32,
    #[doc = "< Specifies LED Lighting time.\nThis parameter can be a number between Min_Data = 1 and Max_Data = 0xFF"]
    pub LightTime: u32,
    #[doc = "< Specifies LED Dead time.\nThis parameter can be a number between Min_Data = 1 and Max_Data = 0xFF"]
    pub DeadTime: u32,
}
#[test]
fn bindgen_test_layout_LED_InitTypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<LED_InitTypeDef> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<LED_InitTypeDef>(),
        20usize,
        concat!("Size of: ", stringify!(LED_InitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<LED_InitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(LED_InitTypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ComDrive) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LED_InitTypeDef),
            "::",
            stringify!(ComDrive)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Prescaler) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(LED_InitTypeDef),
            "::",
            stringify!(Prescaler)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ComNum) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LED_InitTypeDef),
            "::",
            stringify!(ComNum)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LightTime) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(LED_InitTypeDef),
            "::",
            stringify!(LightTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DeadTime) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LED_InitTypeDef),
            "::",
            stringify!(DeadTime)
        )
    );
}
#[doc = "< Peripheral is not yet Initialized"]
pub const HAL_LED_StateTypeDef_HAL_LED_STATE_RESET: HAL_LED_StateTypeDef = 0;
#[doc = "< Peripheral Initialized and ready for use"]
pub const HAL_LED_StateTypeDef_HAL_LED_STATE_READY: HAL_LED_StateTypeDef = 1;
#[doc = "< an internal process is ongoing"]
pub const HAL_LED_StateTypeDef_HAL_LED_STATE_BUSY: HAL_LED_StateTypeDef = 2;
#[doc = "< Timeout state"]
pub const HAL_LED_StateTypeDef_HAL_LED_STATE_TIMEOUT: HAL_LED_StateTypeDef = 3;
#[doc = "< Error"]
pub const HAL_LED_StateTypeDef_HAL_LED_STATE_ERROR: HAL_LED_StateTypeDef = 4;
#[doc = " @brief HAL LED State structures definition"]
pub type HAL_LED_StateTypeDef = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LED_HandleTypeDef {
    pub Instance: *mut LED_TypeDef,
    pub Init: LED_InitTypeDef,
    pub Lock: HAL_LockTypeDef,
    pub State: HAL_LED_StateTypeDef,
}
#[test]
fn bindgen_test_layout_LED_HandleTypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<LED_HandleTypeDef> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<LED_HandleTypeDef>(),
        32usize,
        concat!("Size of: ", stringify!(LED_HandleTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<LED_HandleTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(LED_HandleTypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LED_HandleTypeDef),
            "::",
            stringify!(Instance)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Init) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(LED_HandleTypeDef),
            "::",
            stringify!(Init)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Lock) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(LED_HandleTypeDef),
            "::",
            stringify!(Lock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).State) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(LED_HandleTypeDef),
            "::",
            stringify!(State)
        )
    );
}
extern "C" {
    #[doc = " @defgroup LED_Exported_Functions_Group LED operation functions\n  @brief    LED operation functions\n @{"]
    pub fn HAL_LED_Init(hled: *mut LED_HandleTypeDef) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_LED_MspInit(hled: *mut LED_HandleTypeDef);
}
extern "C" {
    pub fn HAL_LED_SetComDisplay(
        hled: *mut LED_HandleTypeDef,
        comCh: u8,
        data: u8,
    ) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_LED_LightCpltCallback(hled: *mut LED_HandleTypeDef);
}
extern "C" {
    pub fn HAL_LED_IRQHandler(hled: *mut LED_HandleTypeDef);
}
pub const HAL_TickFreqTypeDef_HAL_TICK_FREQ_10HZ: HAL_TickFreqTypeDef = 100;
pub const HAL_TickFreqTypeDef_HAL_TICK_FREQ_100HZ: HAL_TickFreqTypeDef = 10;
pub const HAL_TickFreqTypeDef_HAL_TICK_FREQ_1KHZ: HAL_TickFreqTypeDef = 1;
pub const HAL_TickFreqTypeDef_HAL_TICK_FREQ_DEFAULT: HAL_TickFreqTypeDef = 1;
#[doc = " @defgroup HAL_TICK_FREQ Tick Frequency\n @{"]
pub type HAL_TickFreqTypeDef = ::core::ffi::c_uint;
extern "C" {
    #[doc = " @}"]
    pub static mut uwTickPrio: u32;
}
extern "C" {
    pub static mut uwTickFreq: u32;
}
extern "C" {
    pub fn HAL_Init() -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_DeInit() -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_MspInit();
}
extern "C" {
    pub fn HAL_MspDeInit();
}
extern "C" {
    pub fn HAL_InitTick(TickPriority: u32) -> HAL_StatusTypeDef;
}
extern "C" {
    #[doc = " @addtogroup HAL_Exported_Functions_Group2\n @{"]
    pub fn HAL_IncTick();
}
extern "C" {
    pub fn HAL_Delay(Delay: u32);
}
extern "C" {
    pub fn HAL_GetTick() -> u32;
}
extern "C" {
    pub fn HAL_GetTickPrio() -> u32;
}
extern "C" {
    pub fn HAL_SetTickFreq(Freq: u32) -> HAL_StatusTypeDef;
}
extern "C" {
    pub fn HAL_GetTickFreq() -> u32;
}
extern "C" {
    pub fn HAL_SuspendTick();
}
extern "C" {
    pub fn HAL_ResumeTick();
}
extern "C" {
    pub fn HAL_GetHalVersion() -> u32;
}
extern "C" {
    pub fn HAL_GetREVID() -> u32;
}
extern "C" {
    pub fn HAL_GetDEVID() -> u32;
}
extern "C" {
    pub fn HAL_GetUIDw0() -> u32;
}
extern "C" {
    pub fn HAL_GetUIDw1() -> u32;
}
extern "C" {
    pub fn HAL_GetUIDw2() -> u32;
}
extern "C" {
    pub fn HAL_DBGMCU_EnableDBGSleepMode();
}
extern "C" {
    pub fn HAL_DBGMCU_DisableDBGSleepMode();
}
extern "C" {
    pub fn HAL_DBGMCU_EnableDBGStopMode();
}
extern "C" {
    pub fn HAL_DBGMCU_DisableDBGStopMode();
}
extern "C" {
    pub fn HAL_SYSCFG_DMA_Req(Requset: u32);
}
